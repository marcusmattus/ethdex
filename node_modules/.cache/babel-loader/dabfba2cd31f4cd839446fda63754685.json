{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useLayoutEffect } from \"react\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport truncateEthAddress from \"truncate-eth-address\"; // This is an in-memory cache that will be lost when we refresh the page, as\n// ENS records may change, but we probably only need to check once between\n// refreshes. Format: { [chainId]: { [address]: name | null }}\n\nconst ensCachedResponses = {};\n\nconst useAddressOrEnsName = (address, truncate = true) => {\n  _s();\n\n  const {\n    library,\n    chainId\n  } = useWeb3React();\n  const fallback = truncate ? address ? truncateEthAddress(address) : null : address;\n  const [result, setResult] = useState(fallback);\n  useLayoutEffect(() => {\n    var _ensCachedResponses$c;\n\n    if (!address || !chainId || !library) {\n      setResult(fallback);\n      return;\n    }\n\n    const cached = (_ensCachedResponses$c = ensCachedResponses[chainId]) === null || _ensCachedResponses$c === void 0 ? void 0 : _ensCachedResponses$c[address];\n\n    if (cached !== undefined) {\n      setResult(cached || fallback);\n    } else {\n      library.lookupAddress(address).then(name => {\n        ensCachedResponses[chainId] = { ...ensCachedResponses[chainId],\n          [address]: name\n        };\n        setResult(name || fallback);\n      }).catch(() => {\n        setResult(fallback);\n      });\n    }\n  }, [library, address, chainId, fallback]);\n  return result;\n};\n\n_s(useAddressOrEnsName, \"cOWYZiwA7fZouLimlFT8MNuXtvU=\", false, function () {\n  return [useWeb3React];\n});\n\nexport default useAddressOrEnsName;","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/src/hooks/useAddressOrEnsName.ts"],"names":["useState","useLayoutEffect","useWeb3React","truncateEthAddress","ensCachedResponses","useAddressOrEnsName","address","truncate","library","chainId","fallback","result","setResult","cached","undefined","lookupAddress","then","name","catch"],"mappings":";;AAAA,SAASA,QAAT,EAAmBC,eAAnB,QAA0C,OAA1C;AAGA,SAASC,YAAT,QAA6B,kBAA7B;AAEA,OAAOC,kBAAP,MAA+B,sBAA/B,C,CAEA;AACA;AACA;;AACA,MAAMC,kBAAiE,GAAG,EAA1E;;AAEA,MAAMC,mBAAmB,GAAG,CAC1BC,OAD0B,EAE1BC,QAAiB,GAAG,IAFM,KAGvB;AAAA;;AACH,QAAM;AAAEC,IAAAA,OAAF;AAAWC,IAAAA;AAAX,MAAuBP,YAAY,EAAzC;AAEA,QAAMQ,QAAQ,GAAGH,QAAQ,GACrBD,OAAO,GACLH,kBAAkB,CAACG,OAAD,CADb,GAEL,IAHmB,GAIrBA,OAJJ;AAKA,QAAM,CAACK,MAAD,EAASC,SAAT,IAAsBZ,QAAQ,CAAgBU,QAAhB,CAApC;AAEAT,EAAAA,eAAe,CAAC,MAAM;AAAA;;AACpB,QAAI,CAACK,OAAD,IAAY,CAACG,OAAb,IAAwB,CAACD,OAA7B,EAAsC;AACpCI,MAAAA,SAAS,CAACF,QAAD,CAAT;AACA;AACD;;AAED,UAAMG,MAAM,4BAAGT,kBAAkB,CAACK,OAAD,CAArB,0DAAG,sBAA8BH,OAA9B,CAAf;;AACA,QAAIO,MAAM,KAAKC,SAAf,EAA0B;AACxBF,MAAAA,SAAS,CAACC,MAAM,IAAIH,QAAX,CAAT;AACD,KAFD,MAEO;AACLF,MAAAA,OAAO,CACJO,aADH,CACiBT,OADjB,EAEGU,IAFH,CAESC,IAAD,IAAU;AACdb,QAAAA,kBAAkB,CAACK,OAAD,CAAlB,GAA8B,EAC5B,GAAGL,kBAAkB,CAACK,OAAD,CADO;AAE5B,WAACH,OAAD,GAAWW;AAFiB,SAA9B;AAIAL,QAAAA,SAAS,CAACK,IAAI,IAAIP,QAAT,CAAT;AACD,OARH,EASGQ,KATH,CASS,MAAM;AACXN,QAAAA,SAAS,CAACF,QAAD,CAAT;AACD,OAXH;AAYD;AACF,GAvBc,EAuBZ,CAACF,OAAD,EAAUF,OAAV,EAAmBG,OAAnB,EAA4BC,QAA5B,CAvBY,CAAf;AAyBA,SAAOC,MAAP;AACD,CAvCD;;GAAMN,mB;UAIyBH,Y;;;AAqC/B,eAAeG,mBAAf","sourcesContent":["import { useState, useLayoutEffect } from \"react\";\n\nimport { Web3Provider } from \"@ethersproject/providers\";\nimport { useWeb3React } from \"@web3-react/core\";\n\nimport truncateEthAddress from \"truncate-eth-address\";\n\n// This is an in-memory cache that will be lost when we refresh the page, as\n// ENS records may change, but we probably only need to check once between\n// refreshes. Format: { [chainId]: { [address]: name | null }}\nconst ensCachedResponses: Record<number, Record<string, string | null>> = {};\n\nconst useAddressOrEnsName = (\n  address: string | null,\n  truncate: boolean = true\n) => {\n  const { library, chainId } = useWeb3React<Web3Provider>();\n\n  const fallback = truncate\n    ? address\n      ? truncateEthAddress(address)\n      : null\n    : address;\n  const [result, setResult] = useState<string | null>(fallback);\n\n  useLayoutEffect(() => {\n    if (!address || !chainId || !library) {\n      setResult(fallback);\n      return;\n    }\n\n    const cached = ensCachedResponses[chainId]?.[address];\n    if (cached !== undefined) {\n      setResult(cached || fallback);\n    } else {\n      library\n        .lookupAddress(address)\n        .then((name) => {\n          ensCachedResponses[chainId] = {\n            ...ensCachedResponses[chainId],\n            [address]: name,\n          };\n          setResult(name || fallback);\n        })\n        .catch(() => {\n          setResult(fallback);\n        });\n    }\n  }, [library, address, chainId, fallback]);\n\n  return result;\n};\n\nexport default useAddressOrEnsName;\n"]},"metadata":{},"sourceType":"module"}