{"ast":null,"code":"var _jsxFileName = \"/Users/marcusmattus/ethdex/airswap-web/src/components/SwapWidget/subcomponents/ActionButtons/ActionButtons.tsx\",\n    _s = $RefreshSig$();\n\nimport { useTranslation } from \"react-i18next\";\nimport { MainButton, BackButton } from \"./ActionButtons.styles\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nexport let ButtonActions;\n\n(function (ButtonActions) {\n  ButtonActions[ButtonActions[\"connectWallet\"] = 0] = \"connectWallet\";\n  ButtonActions[ButtonActions[\"switchNetwork\"] = 1] = \"switchNetwork\";\n  ButtonActions[ButtonActions[\"restart\"] = 2] = \"restart\";\n  ButtonActions[ButtonActions[\"goBack\"] = 3] = \"goBack\";\n  ButtonActions[ButtonActions[\"approve\"] = 4] = \"approve\";\n  ButtonActions[ButtonActions[\"reloadPage\"] = 5] = \"reloadPage\";\n  ButtonActions[ButtonActions[\"requestQuotes\"] = 6] = \"requestQuotes\";\n  ButtonActions[ButtonActions[\"takeQuote\"] = 7] = \"takeQuote\";\n  ButtonActions[ButtonActions[\"trackTransaction\"] = 8] = \"trackTransaction\";\n})(ButtonActions || (ButtonActions = {}));\n\nconst buttonTextMapping = {\n  [ButtonActions.connectWallet]: \"wallet.connectWallet\",\n  [ButtonActions.switchNetwork]: \"wallet.switchNetwork\",\n  [ButtonActions.reloadPage]: \"common.reloadPage\",\n  [ButtonActions.restart]: \"orders.newSwap\",\n  [ButtonActions.goBack]: \"common.back\",\n  [ButtonActions.approve]: \"orders.approve\",\n  [ButtonActions.requestQuotes]: \"orders.continue\",\n  [ButtonActions.takeQuote]: \"orders.take\",\n  [ButtonActions.trackTransaction]: \"orders.track\"\n};\n/**\n * This can either be:\n *  - Connect wallet button (Wallet not connected, OR isConnecting [loading])\n *  - Invisible (approving and swapping - TBD - could be overlay)\n *  - Back button (pair unavailable)\n *  - New swap button (to restart after order has been submitted)\n *  - \"Back\" and \"Complete Swap\" buttons (when ready to go)\n *  - \"Back\" and \"Approve\" buttons\n *  - A disabled button containing reason text (enter an amount, token info\n *    not found, or insufficient balance)\n *  - A continue button to request quotes\n */\n\nconst ActionButtons = ({\n  walletIsActive,\n  unsupportedNetwork,\n  requiresReload,\n  orderComplete,\n  pairUnavailable,\n  hasQuote,\n  needsApproval,\n  hasAmount,\n  baseTokenInfo,\n  quoteTokenInfo,\n  hasSufficientBalance,\n  isLoading,\n  transactionsTabOpen,\n  onButtonClicked\n}) => {\n  _s();\n\n  const {\n    t\n  } = useTranslation(); // First determine the next action.\n\n  let nextAction; // Note that wallet is not considered \"active\" if connected to wrong network\n\n  if (unsupportedNetwork) nextAction = ButtonActions.switchNetwork;else if (!walletIsActive) nextAction = ButtonActions.connectWallet;else if (pairUnavailable) nextAction = ButtonActions.goBack;else if (orderComplete) nextAction = ButtonActions.restart;else if (requiresReload) nextAction = ButtonActions.reloadPage;else if (hasQuote && needsApproval) nextAction = ButtonActions.approve;else if (hasQuote) nextAction = ButtonActions.takeQuote;else nextAction = ButtonActions.requestQuotes; // If a secondary action is defined, a secondary button will be displayed.\n\n  let secondaryAction = null;\n  if (orderComplete && !transactionsTabOpen) secondaryAction = ButtonActions.trackTransaction; // If there's something to fix before progress can be made, the button will\n  // be disabled. These disabled states never have a back button.\n\n  let isDisabled = walletIsActive && (!hasSufficientBalance || !baseTokenInfo || !quoteTokenInfo || !hasAmount); // Some actions require an additional back button\n\n  const hasBackButton = !isDisabled && (nextAction === ButtonActions.takeQuote || nextAction === ButtonActions.approve);\n\n  if (orderComplete) {\n    isDisabled = false;\n    nextAction = ButtonActions.restart;\n  } // The text depends on the next action, unless the button is disabled, when\n  // it depends on the reason for being disabled instead.\n\n\n  let mainButtonText;\n\n  if (isDisabled) {\n    if (!hasAmount) mainButtonText = t(\"orders.enterAmount\");else if (!baseTokenInfo || !quoteTokenInfo) mainButtonText = t(\"orders.chooseToken\");else if (!hasSufficientBalance) mainButtonText = t(\"orders.insufficentBalance\", {\n      symbol: baseTokenInfo.symbol\n    });\n  } else {\n    // @ts-ignore dynamic translation key.\n    mainButtonText = t(buttonTextMapping[nextAction]);\n  } //@ts-ignore\n\n\n  let secondaryButtonText = !!secondaryAction ? // @ts-ignore dynamic translation key.\n  t(buttonTextMapping[secondaryAction]) : null;\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [hasBackButton && /*#__PURE__*/_jsxDEV(BackButton, {\n      onClick: onButtonClicked.bind(null, ButtonActions.goBack),\n      children: t(\"common.back\")\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 136,\n      columnNumber: 9\n    }, this), secondaryAction &&\n    /*#__PURE__*/\n    // Note MainButton used to ensure secondary button is same size as main\n    _jsxDEV(MainButton, {\n      intent: \"neutral\",\n      onClick: onButtonClicked.bind(null, secondaryAction),\n      children: secondaryButtonText\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 142,\n      columnNumber: 9\n    }, this), /*#__PURE__*/_jsxDEV(MainButton, {\n      intent: nextAction === ButtonActions.goBack ? \"neutral\" : \"primary\",\n      loading: isLoading,\n      disabled: isDisabled,\n      onClick: onButtonClicked.bind(null, nextAction),\n      children: mainButtonText\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 149,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n\n_s(ActionButtons, \"zlIdU9EjM2llFt74AbE2KsUJXyM=\", false, function () {\n  return [useTranslation];\n});\n\n_c = ActionButtons;\nexport default ActionButtons;\n\nvar _c;\n\n$RefreshReg$(_c, \"ActionButtons\");","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/components/SwapWidget/subcomponents/ActionButtons/ActionButtons.tsx"],"names":["useTranslation","MainButton","BackButton","ButtonActions","buttonTextMapping","connectWallet","switchNetwork","reloadPage","restart","goBack","approve","requestQuotes","takeQuote","trackTransaction","ActionButtons","walletIsActive","unsupportedNetwork","requiresReload","orderComplete","pairUnavailable","hasQuote","needsApproval","hasAmount","baseTokenInfo","quoteTokenInfo","hasSufficientBalance","isLoading","transactionsTabOpen","onButtonClicked","t","nextAction","secondaryAction","isDisabled","hasBackButton","mainButtonText","symbol","secondaryButtonText","bind"],"mappings":"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","sourcesContent":["import { FC } from \"react\";\nimport { useTranslation } from \"react-i18next\";\n\nimport { TokenInfo } from \"@airswap/types\";\n\nimport { MainButton, BackButton } from \"./ActionButtons.styles\";\n\nexport enum ButtonActions {\n  connectWallet,\n  switchNetwork,\n  restart,\n  goBack,\n  approve,\n  reloadPage,\n  requestQuotes,\n  takeQuote,\n  trackTransaction,\n}\n\nconst buttonTextMapping: Record<ButtonActions, string> = {\n  [ButtonActions.connectWallet]: \"wallet.connectWallet\",\n  [ButtonActions.switchNetwork]: \"wallet.switchNetwork\",\n  [ButtonActions.reloadPage]: \"common.reloadPage\",\n  [ButtonActions.restart]: \"orders.newSwap\",\n  [ButtonActions.goBack]: \"common.back\",\n  [ButtonActions.approve]: \"orders.approve\",\n  [ButtonActions.requestQuotes]: \"orders.continue\",\n  [ButtonActions.takeQuote]: \"orders.take\",\n  [ButtonActions.trackTransaction]: \"orders.track\",\n};\n\n/**\n * This can either be:\n *  - Connect wallet button (Wallet not connected, OR isConnecting [loading])\n *  - Invisible (approving and swapping - TBD - could be overlay)\n *  - Back button (pair unavailable)\n *  - New swap button (to restart after order has been submitted)\n *  - \"Back\" and \"Complete Swap\" buttons (when ready to go)\n *  - \"Back\" and \"Approve\" buttons\n *  - A disabled button containing reason text (enter an amount, token info\n *    not found, or insufficient balance)\n *  - A continue button to request quotes\n */\nconst ActionButtons: FC<{\n  walletIsActive: boolean;\n  unsupportedNetwork: boolean;\n  requiresReload: boolean;\n  orderComplete: boolean;\n  pairUnavailable: boolean;\n  hasQuote: boolean;\n  needsApproval: boolean;\n  hasAmount: boolean;\n  baseTokenInfo: TokenInfo | null;\n  quoteTokenInfo: TokenInfo | null;\n  hasSufficientBalance: boolean;\n  isLoading: boolean;\n  transactionsTabOpen: boolean;\n  onButtonClicked: (action: ButtonActions) => void;\n}> = ({\n  walletIsActive,\n  unsupportedNetwork,\n  requiresReload,\n  orderComplete,\n  pairUnavailable,\n  hasQuote,\n  needsApproval,\n  hasAmount,\n  baseTokenInfo,\n  quoteTokenInfo,\n  hasSufficientBalance,\n  isLoading,\n  transactionsTabOpen,\n  onButtonClicked,\n}) => {\n  const { t } = useTranslation();\n\n  // First determine the next action.\n  let nextAction: ButtonActions;\n  // Note that wallet is not considered \"active\" if connected to wrong network\n  if (unsupportedNetwork) nextAction = ButtonActions.switchNetwork;\n  else if (!walletIsActive) nextAction = ButtonActions.connectWallet;\n  else if (pairUnavailable) nextAction = ButtonActions.goBack;\n  else if (orderComplete) nextAction = ButtonActions.restart;\n  else if (requiresReload) nextAction = ButtonActions.reloadPage;\n  else if (hasQuote && needsApproval) nextAction = ButtonActions.approve;\n  else if (hasQuote) nextAction = ButtonActions.takeQuote;\n  else nextAction = ButtonActions.requestQuotes;\n\n  // If a secondary action is defined, a secondary button will be displayed.\n  let secondaryAction: ButtonActions | null = null;\n  if (orderComplete && !transactionsTabOpen)\n    secondaryAction = ButtonActions.trackTransaction;\n\n  // If there's something to fix before progress can be made, the button will\n  // be disabled. These disabled states never have a back button.\n  let isDisabled =\n    walletIsActive &&\n    (!hasSufficientBalance || !baseTokenInfo || !quoteTokenInfo || !hasAmount);\n\n  // Some actions require an additional back button\n  const hasBackButton: boolean =\n    !isDisabled &&\n    (nextAction === ButtonActions.takeQuote ||\n      nextAction === ButtonActions.approve);\n\n  if (orderComplete) {\n    isDisabled = false;\n    nextAction = ButtonActions.restart;\n  }\n\n  // The text depends on the next action, unless the button is disabled, when\n  // it depends on the reason for being disabled instead.\n  let mainButtonText;\n  if (isDisabled) {\n    if (!hasAmount) mainButtonText = t(\"orders.enterAmount\");\n    else if (!baseTokenInfo || !quoteTokenInfo)\n      mainButtonText = t(\"orders.chooseToken\");\n    else if (!hasSufficientBalance)\n      mainButtonText = t(\"orders.insufficentBalance\", {\n        symbol: baseTokenInfo.symbol,\n      });\n  } else {\n    // @ts-ignore dynamic translation key.\n    mainButtonText = t(buttonTextMapping[nextAction]);\n  }\n\n  //@ts-ignore\n  let secondaryButtonText: string | null = !!secondaryAction\n    ? // @ts-ignore dynamic translation key.\n      t(buttonTextMapping[secondaryAction])\n    : null;\n\n  return (\n    <>\n      {hasBackButton && (\n        <BackButton onClick={onButtonClicked.bind(null, ButtonActions.goBack)}>\n          {t(\"common.back\")}\n        </BackButton>\n      )}\n      {secondaryAction && (\n        // Note MainButton used to ensure secondary button is same size as main\n        <MainButton\n          intent=\"neutral\"\n          onClick={onButtonClicked.bind(null, secondaryAction)}\n        >\n          {secondaryButtonText}\n        </MainButton>\n      )}\n      <MainButton\n        intent={nextAction === ButtonActions.goBack ? \"neutral\" : \"primary\"}\n        loading={isLoading}\n        disabled={isDisabled}\n        onClick={onButtonClicked.bind(null, nextAction)}\n      >\n        {mainButtonText}\n      </MainButton>\n    </>\n  );\n};\n\nexport default ActionButtons;\n"]},"metadata":{},"sourceType":"module"}