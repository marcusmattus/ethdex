{"ast":null,"code":"import { store } from \"../../app/store\";\nimport { notifyTransaction } from \"../../components/Toasts/ToastController\";\nimport { mineTransaction } from \"./transactionActions\";\n\nconst handleReceipt = ({\n  nonce,\n  transactionHash,\n  signerWallet,\n  transaction,\n  protocol,\n  chainId,\n  dispatch\n}) => {\n  const tokens = Object.values(store.getState().metadata.tokens.all);\n  dispatch(mineTransaction({\n    signerWallet: signerWallet,\n    nonce: nonce,\n    hash: transactionHash,\n    protocol\n  }));\n  notifyTransaction(\"Order\", //@ts-ignore\n  transaction, tokens, false, chainId);\n};\n\nfunction isSwapHex(data) {\n  return data._isBigNumber !== undefined;\n}\n\nfunction isSwapEvent(data) {\n  return data.transactionHash !== undefined;\n}\n\nfunction isSwapAddress(data) {\n  return typeof data === \"string\";\n}\n\nexport const mapSwapEvent = (data, chainId, account, transactions) => {\n  let protocol;\n  const nonce = isSwapHex(data[0]) ? data[0].toString() : \"UNKNOWN\";\n  let signerWallet = isSwapAddress(data[2]) ? data[2] : \"\";\n  const transactionHash = isSwapEvent(data[9]) ? data[9].transactionHash : \"\"; // First search for the transaction in our pending state by hash.\n  // This will match either direct RFQ orders (senderWallet === account) or\n  // RFQ orders going through the wrapper (senderWallet === wrapper).\n\n  let transaction = transactions.all.find(t => t.hash === transactionHash) || null; // If we haven't got a transaction with this hash in our history, then it's\n  // either a last look order (if we're the signer) OR it's someone else's\n  // swap. (Someone else includes \"us\" in another browser).\n\n  if (!transaction && signerWallet.toLowerCase() === account.toLowerCase()) {\n    transaction = transactions.all.find(t => {\n      var _order;\n\n      return t.nonce === nonce && ((_order = t.order) === null || _order === void 0 ? void 0 : _order.signerWallet.toLowerCase()) === signerWallet.toLowerCase();\n    });\n  }\n\n  if (transaction) protocol = transaction.protocol;\n  return {\n    signerWallet,\n    nonce,\n    transactionHash,\n    protocol,\n    transaction\n  };\n};\nexport default function subscribeToSwapEvents(params) {\n  const {\n    lightContract,\n    account,\n    dispatch,\n    chainId\n  } = params;\n  lightContract.on(\"Swap\", async (...data) => {\n    const transactions = store.getState().transactions;\n    const {\n      nonce,\n      signerWallet,\n      transactionHash,\n      protocol,\n      transaction\n    } = mapSwapEvent(data, chainId, account, transactions); // If we don't have a 'transaction', we don't already know about this swap\n    // and therefore don't need to update the UI.\n\n    if (!transaction) return;\n    return handleReceipt({\n      nonce,\n      signerWallet,\n      transactionHash,\n      protocol,\n      chainId,\n      transaction,\n      dispatch\n    });\n  });\n}","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/features/transactions/swapEventSubscriber.ts"],"names":["store","notifyTransaction","mineTransaction","handleReceipt","nonce","transactionHash","signerWallet","transaction","protocol","chainId","dispatch","tokens","Object","values","getState","metadata","all","hash","isSwapHex","data","_isBigNumber","undefined","isSwapEvent","isSwapAddress","mapSwapEvent","account","transactions","toString","find","t","toLowerCase","order","subscribeToSwapEvents","params","lightContract","on"],"mappings":"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","sourcesContent":["import { Action, Dispatch } from \"@reduxjs/toolkit\";\n\nimport BigNumber from \"bignumber.js\";\nimport { Contract } from \"ethers\";\n\nimport { store } from \"../../app/store\";\nimport { notifyTransaction } from \"../../components/Toasts/ToastController\";\nimport { mineTransaction } from \"./transactionActions\";\nimport {\n  LastLookTransaction,\n  ProtocolType,\n  SubmittedTransactionWithOrder,\n  SubmittedTransaction,\n  TransactionsState,\n} from \"./transactionsSlice\";\n\nconst handleReceipt = ({\n  nonce,\n  transactionHash,\n  signerWallet,\n  transaction,\n  protocol,\n  chainId,\n  dispatch,\n}: {\n  nonce: string;\n  transactionHash: string;\n  signerWallet: string;\n  transaction: SubmittedTransaction;\n  protocol?: ProtocolType;\n  chainId: number;\n  dispatch: Dispatch<Action>;\n}) => {\n  const tokens = Object.values(store.getState().metadata.tokens.all);\n\n  dispatch(\n    mineTransaction({\n      signerWallet: signerWallet,\n      nonce: nonce,\n      hash: transactionHash,\n      protocol,\n    })\n  );\n\n  notifyTransaction(\n    \"Order\",\n    //@ts-ignore\n    transaction,\n    tokens,\n    false,\n    chainId\n  );\n};\n\ntype SwapHex = {\n  _hex?: BigNumber;\n  _isBigNumber: boolean;\n};\ntype SwapEvent = {\n  transactionHash: string;\n  address: string;\n  removed: boolean;\n  eventSignature: string;\n  topics: string[];\n};\n\nexport type SwapRow = string | SwapHex | SwapEvent;\n\nfunction isSwapHex(data: SwapRow): data is SwapHex {\n  return (data as SwapHex)._isBigNumber !== undefined;\n}\n\nfunction isSwapEvent(data: SwapRow): data is SwapEvent {\n  return (data as SwapEvent).transactionHash !== undefined;\n}\nfunction isSwapAddress(data: SwapRow): data is string {\n  return typeof data === \"string\";\n}\n\nexport const mapSwapEvent = (\n  data: SwapRow[],\n  chainId: number,\n  account: string,\n  transactions: TransactionsState\n) => {\n  let protocol: ProtocolType | undefined;\n  const nonce = isSwapHex(data[0]) ? data[0].toString() : \"UNKNOWN\";\n  let signerWallet = isSwapAddress(data[2]) ? data[2] : \"\";\n  const transactionHash = isSwapEvent(data[9]) ? data[9].transactionHash : \"\";\n\n  // First search for the transaction in our pending state by hash.\n  // This will match either direct RFQ orders (senderWallet === account) or\n  // RFQ orders going through the wrapper (senderWallet === wrapper).\n  let transaction: SubmittedTransaction | null =\n    transactions.all.find((t: any) => t.hash === transactionHash) || null;\n\n  // If we haven't got a transaction with this hash in our history, then it's\n  // either a last look order (if we're the signer) OR it's someone else's\n  // swap. (Someone else includes \"us\" in another browser).\n  if (!transaction && signerWallet.toLowerCase() === account.toLowerCase()) {\n    transaction = transactions.all.find(\n      (t: SubmittedTransaction | SubmittedTransactionWithOrder) =>\n        t.nonce === nonce &&\n        (t as SubmittedTransactionWithOrder).order?.signerWallet.toLowerCase() ===\n          signerWallet.toLowerCase()\n    ) as LastLookTransaction;\n  }\n\n  if (transaction) protocol = transaction.protocol;\n\n  return {\n    signerWallet,\n    nonce,\n    transactionHash,\n    protocol,\n    transaction,\n  };\n};\n\nexport default function subscribeToSwapEvents(params: {\n  lightContract: Contract;\n  chainId: number;\n  account: string;\n  library: any;\n  dispatch: Dispatch;\n}) {\n  const { lightContract, account, dispatch, chainId } = params;\n  lightContract.on(\"Swap\", async (...data) => {\n    const transactions = store.getState().transactions;\n    const {\n      nonce,\n      signerWallet,\n      transactionHash,\n      protocol,\n      transaction,\n    } = mapSwapEvent(data, chainId, account, transactions);\n\n    // If we don't have a 'transaction', we don't already know about this swap\n    // and therefore don't need to update the UI.\n    if (!transaction) return;\n\n    return handleReceipt({\n      nonce,\n      signerWallet,\n      transactionHash,\n      protocol,\n      chainId,\n      transaction,\n      dispatch,\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}