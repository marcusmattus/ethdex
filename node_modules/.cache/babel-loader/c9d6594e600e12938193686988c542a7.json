{"ast":null,"code":"import { chainIds, chainNames } from \"@airswap/constants\";\nimport * as ValidatorContract from \"@airswap/validator/build/contracts/Validator.sol/Validator.json\"; // @ts-ignore\n\nimport * as ValidatorDeploys from \"@airswap/validator/deploys.js\";\nimport { ethers } from \"ethers\";\nconst ValidatorInterface = new ethers.utils.Interface(JSON.stringify(ValidatorContract.abi));\nexport class Validator {\n  constructor(chainId = chainIds.RINKEBY, signerOrProvider) {\n    this.chainId = void 0;\n    this.contract = void 0;\n    this.chainId = chainId;\n    this.contract = new ethers.Contract(ValidatorDeploys[chainId], ValidatorInterface, // @ts-ignore\n    signerOrProvider || ethers.getDefaultProvider(chainNames[chainId].toLowerCase()));\n  }\n\n  static getAddress(chainId = chainIds.RINKEBY) {\n    if (chainId in ValidatorDeploys) {\n      return ValidatorDeploys[chainId];\n    }\n\n    throw new Error(`Light Validator deploy not found or chainId ${chainId}`);\n  }\n\n  async checkSwap(order, senderWallet, signer) {\n    let contract = this.contract;\n\n    if (!this.contract.signer) {\n      if (signer === undefined) {\n        throw new Error(\"Signer must be provided\");\n      } else {\n        contract = contract.connect(signer);\n      }\n    }\n\n    const [count, errors] = await contract.checkSwap(order.nonce, order.expiry, order.signerWallet, order.signerToken, order.signerAmount, order.senderToken, order.senderAmount, order.v, order.r, order.s, senderWallet);\n    return this.convertToArray(count, errors);\n  }\n\n  convertToArray(count, errors) {\n    const res = [];\n\n    for (let idx = 0; idx < count.toNumber(); idx++) {\n      res.push(ethers.utils.parseBytes32String(errors[idx]));\n    }\n\n    return res;\n  }\n\n}","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/src/helpers/Validator.ts"],"names":["chainIds","chainNames","ValidatorContract","ValidatorDeploys","ethers","ValidatorInterface","utils","Interface","JSON","stringify","abi","Validator","constructor","chainId","RINKEBY","signerOrProvider","contract","Contract","getDefaultProvider","toLowerCase","getAddress","Error","checkSwap","order","senderWallet","signer","undefined","connect","count","errors","nonce","expiry","signerWallet","signerToken","signerAmount","senderToken","senderAmount","v","r","s","convertToArray","res","idx","toNumber","push","parseBytes32String"],"mappings":"AAAA,SAASA,QAAT,EAAmBC,UAAnB,QAAqC,oBAArC;AAEA,OAAO,KAAKC,iBAAZ,MAAmC,iEAAnC,C,CACA;;AACA,OAAO,KAAKC,gBAAZ,MAAkC,+BAAlC;AAEA,SAASC,MAAT,QAAuB,QAAvB;AAGA,MAAMC,kBAAkB,GAAG,IAAID,MAAM,CAACE,KAAP,CAAaC,SAAjB,CACzBC,IAAI,CAACC,SAAL,CAAeP,iBAAiB,CAACQ,GAAjC,CADyB,CAA3B;AAIA,OAAO,MAAMC,SAAN,CAAgB;AAIdC,EAAAA,WAAW,CAChBC,OAAO,GAAGb,QAAQ,CAACc,OADH,EAEhBC,gBAFgB,EAGhB;AAAA,SANKF,OAML;AAAA,SALMG,QAKN;AACA,SAAKH,OAAL,GAAeA,OAAf;AACA,SAAKG,QAAL,GAAgB,IAAIZ,MAAM,CAACa,QAAX,CACdd,gBAAgB,CAACU,OAAD,CADF,EAEdR,kBAFc,EAGd;AACAU,IAAAA,gBAAgB,IACdX,MAAM,CAACc,kBAAP,CAA0BjB,UAAU,CAACY,OAAD,CAAV,CAAoBM,WAApB,EAA1B,CALY,CAAhB;AAOD;;AAEuB,SAAVC,UAAU,CAACP,OAAO,GAAGb,QAAQ,CAACc,OAApB,EAAqC;AAC3D,QAAID,OAAO,IAAIV,gBAAf,EAAiC;AAC/B,aAAOA,gBAAgB,CAACU,OAAD,CAAvB;AACD;;AACD,UAAM,IAAIQ,KAAJ,CAAW,+CAA8CR,OAAQ,EAAjE,CAAN;AACD;;AAEqB,QAATS,SAAS,CACpBC,KADoB,EAEpBC,YAFoB,EAGpBC,MAHoB,EAII;AACxB,QAAIT,QAAQ,GAAG,KAAKA,QAApB;;AACA,QAAI,CAAC,KAAKA,QAAL,CAAcS,MAAnB,EAA2B;AACzB,UAAIA,MAAM,KAAKC,SAAf,EAA0B;AACxB,cAAM,IAAIL,KAAJ,CAAU,yBAAV,CAAN;AACD,OAFD,MAEO;AACLL,QAAAA,QAAQ,GAAGA,QAAQ,CAACW,OAAT,CAAiBF,MAAjB,CAAX;AACD;AACF;;AACD,UAAM,CAACG,KAAD,EAAQC,MAAR,IAAkB,MAAMb,QAAQ,CAACM,SAAT,CAC5BC,KAAK,CAACO,KADsB,EAE5BP,KAAK,CAACQ,MAFsB,EAG5BR,KAAK,CAACS,YAHsB,EAI5BT,KAAK,CAACU,WAJsB,EAK5BV,KAAK,CAACW,YALsB,EAM5BX,KAAK,CAACY,WANsB,EAO5BZ,KAAK,CAACa,YAPsB,EAQ5Bb,KAAK,CAACc,CARsB,EAS5Bd,KAAK,CAACe,CATsB,EAU5Bf,KAAK,CAACgB,CAVsB,EAW5Bf,YAX4B,CAA9B;AAaA,WAAO,KAAKgB,cAAL,CAAoBZ,KAApB,EAA2BC,MAA3B,CAAP;AACD;;AAEOW,EAAAA,cAAc,CAACZ,KAAD,EAAmBC,MAAnB,EAA0C;AAC9D,UAAMY,GAAkB,GAAG,EAA3B;;AACA,SAAK,IAAIC,GAAG,GAAG,CAAf,EAAkBA,GAAG,GAAGd,KAAK,CAACe,QAAN,EAAxB,EAA0CD,GAAG,EAA7C,EAAiD;AAC/CD,MAAAA,GAAG,CAACG,IAAJ,CAASxC,MAAM,CAACE,KAAP,CAAauC,kBAAb,CAAgChB,MAAM,CAACa,GAAD,CAAtC,CAAT;AACD;;AACD,WAAOD,GAAP;AACD;;AA5DoB","sourcesContent":["import { chainIds, chainNames } from \"@airswap/constants\";\nimport { LightOrder } from \"@airswap/types\";\nimport * as ValidatorContract from \"@airswap/validator/build/contracts/Validator.sol/Validator.json\";\n// @ts-ignore\nimport * as ValidatorDeploys from \"@airswap/validator/deploys.js\";\n\nimport { ethers } from \"ethers\";\nimport { BigNumber } from \"ethers\";\n\nconst ValidatorInterface = new ethers.utils.Interface(\n  JSON.stringify(ValidatorContract.abi)\n);\n\nexport class Validator {\n  public chainId: number;\n  private contract: ethers.Contract;\n\n  public constructor(\n    chainId = chainIds.RINKEBY,\n    signerOrProvider?: ethers.Signer | ethers.providers.Provider\n  ) {\n    this.chainId = chainId;\n    this.contract = new ethers.Contract(\n      ValidatorDeploys[chainId],\n      ValidatorInterface,\n      // @ts-ignore\n      signerOrProvider ||\n        ethers.getDefaultProvider(chainNames[chainId].toLowerCase())\n    );\n  }\n\n  public static getAddress(chainId = chainIds.RINKEBY): string {\n    if (chainId in ValidatorDeploys) {\n      return ValidatorDeploys[chainId];\n    }\n    throw new Error(`Light Validator deploy not found or chainId ${chainId}`);\n  }\n\n  public async checkSwap(\n    order: LightOrder,\n    senderWallet: string,\n    signer?: ethers.Signer\n  ): Promise<Array<string>> {\n    let contract = this.contract;\n    if (!this.contract.signer) {\n      if (signer === undefined) {\n        throw new Error(\"Signer must be provided\");\n      } else {\n        contract = contract.connect(signer);\n      }\n    }\n    const [count, errors] = await contract.checkSwap(\n      order.nonce,\n      order.expiry,\n      order.signerWallet,\n      order.signerToken,\n      order.signerAmount,\n      order.senderToken,\n      order.senderAmount,\n      order.v,\n      order.r,\n      order.s,\n      senderWallet\n    );\n    return this.convertToArray(count, errors);\n  }\n\n  private convertToArray(count: BigNumber, errors: Array<string>) {\n    const res: Array<string> = [];\n    for (let idx = 0; idx < count.toNumber(); idx++) {\n      res.push(ethers.utils.parseBytes32String(errors[idx]));\n    }\n    return res;\n  }\n}\n"]},"metadata":{},"sourceType":"module"}