{"ast":null,"code":"'use strict';\n\nconst tls = require('tls');\n\nconst utils = require('../utils');\n\nconst Client = require('../client');\n/**\n *  Constructor for a Jayson TLS-encrypted TCP Client\n *  @class ClientTls\n *  @constructor\n *  @extends Client\n *  @param {Object|String} [options] Object goes into options for tls.connect, String goes into options.path. String option argument is NOT recommended.\n *  @return {ClientTls}\n */\n\n\nconst ClientTls = function (options) {\n  if (typeof options === 'string') {\n    options = {\n      path: options\n    };\n  }\n\n  if (!(this instanceof ClientTls)) {\n    return new ClientTls(options);\n  }\n\n  Client.call(this, options);\n  const defaults = utils.merge(this.options, {\n    encoding: 'utf8'\n  });\n  this.options = utils.merge(defaults, options || {});\n};\n\nrequire('util').inherits(ClientTls, Client);\n\nmodule.exports = ClientTls;\n\nClientTls.prototype._request = function (request, callback) {\n  const self = this; // copies options so object can be modified in this context\n\n  const options = utils.merge({}, this.options);\n  utils.JSON.stringify(request, options, function (err, body) {\n    if (err) {\n      return callback(err);\n    }\n\n    let handled = false;\n    const conn = tls.connect(options, function () {\n      conn.setEncoding(options.encoding); // wont get anything for notifications, just end here\n\n      if (utils.Request.isNotification(request)) {\n        handled = true;\n        conn.end(body + '\\n');\n        callback();\n      } else {\n        utils.parseStream(conn, options, function (err, response) {\n          handled = true;\n          conn.end();\n\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, response);\n        });\n        conn.write(body + '\\n');\n      }\n    });\n    self.emit('tcp socket', conn);\n    conn.on('error', function (err) {\n      self.emit('tcp error', err);\n      callback(err);\n    });\n    conn.on('end', function () {\n      if (!handled) {\n        callback();\n      }\n    });\n  });\n};","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/node_modules/jayson/lib/client/tls.js"],"names":["tls","require","utils","Client","ClientTls","options","path","call","defaults","merge","encoding","inherits","module","exports","prototype","_request","request","callback","self","JSON","stringify","err","body","handled","conn","connect","setEncoding","Request","isNotification","end","parseStream","response","write","emit","on"],"mappings":"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","sourcesContent":["'use strict';\n\nconst tls = require('tls');\nconst utils = require('../utils');\nconst Client = require('../client');\n\n/**\n *  Constructor for a Jayson TLS-encrypted TCP Client\n *  @class ClientTls\n *  @constructor\n *  @extends Client\n *  @param {Object|String} [options] Object goes into options for tls.connect, String goes into options.path. String option argument is NOT recommended.\n *  @return {ClientTls}\n */\nconst ClientTls = function(options) {\n  if(typeof(options) === 'string') {\n    options = {path: options};\n  }\n\n  if(!(this instanceof ClientTls)) {\n    return new ClientTls(options);\n  }\n  Client.call(this, options);\n\n  const defaults = utils.merge(this.options, {\n    encoding: 'utf8'\n  });\n\n  this.options = utils.merge(defaults, options || {});\n};\nrequire('util').inherits(ClientTls, Client);\n\nmodule.exports = ClientTls;\n\nClientTls.prototype._request = function(request, callback) {\n  const self = this;\n\n  // copies options so object can be modified in this context\n  const options = utils.merge({}, this.options);\n\n  utils.JSON.stringify(request, options, function(err, body) {\n    if(err) {\n      return callback(err);\n    }\n\n    let handled = false;\n\n    const conn = tls.connect(options, function() {\n\n      conn.setEncoding(options.encoding);\n\n      // wont get anything for notifications, just end here\n      if(utils.Request.isNotification(request)) {\n\n        handled = true;\n        conn.end(body + '\\n');\n        callback();\n\n      } else {\n\n        utils.parseStream(conn, options, function(err, response) {\n          handled = true;\n          conn.end();\n          if(err) {\n            return callback(err);\n          }\n          callback(null, response);\n        });\n\n        conn.write(body + '\\n');\n      \n      }\n\n    });\n\n    self.emit('tcp socket', conn);\n\n    conn.on('error', function(err) {\n      self.emit('tcp error', err);\n      callback(err);\n    });\n\n    conn.on('end', function() {\n      if(!handled) {\n        callback();\n      }\n    });\n  });\n};\n"]},"metadata":{},"sourceType":"script"}