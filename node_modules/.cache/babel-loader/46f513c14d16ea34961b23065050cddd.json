{"ast":null,"code":"import BalanceChecker from \"@airswap/balances/build/contracts/BalanceChecker.json\";\nimport balancesDeploys from \"@airswap/balances/deploys.js\";\nimport { Light, Wrapper } from \"@airswap/libraries\";\nimport erc20Abi from \"erc-20-abi\";\nimport { ethers } from \"ethers\";\nimport { hexZeroPad, id } from \"ethers/lib/utils\";\nconst balancesInterface = new ethers.utils.Interface(JSON.stringify(BalanceChecker.abi));\nconst erc20Interface = new ethers.utils.Interface(erc20Abi);\n\nconst getContract = (chainId, provider) => {\n  return new ethers.Contract(balancesDeploys[chainId], balancesInterface, provider);\n};\n/**\n * Fetches balances or allowances for a wallet using the airswap utility\n * contract `BalanceChecker.sol`. Balances are returned in base units.\n */\n\n\nconst fetchBalancesOrAllowances = async (method, spenderAddressType, {\n  chainId,\n  provider,\n  tokenAddresses,\n  walletAddress\n}) => {\n  const contract = getContract(chainId, provider);\n  const args = method === \"walletBalances\" ? [walletAddress, tokenAddresses] : spenderAddressType === \"Light\" ? // sender, spender, tokens.\n  [walletAddress, Light.getAddress(chainId), tokenAddresses] : [walletAddress, Wrapper.getAddress(chainId), tokenAddresses];\n  const amounts = await contract[method].apply(null, args);\n  return amounts.map(amount => amount.toString());\n};\n\nconst fetchBalances = fetchBalancesOrAllowances.bind(null, \"walletBalances\", \"None\");\nconst fetchAllowancesLight = fetchBalancesOrAllowances.bind(null, \"walletAllowances\", \"Light\");\nconst fetchAllowancesWrapper = fetchBalancesOrAllowances.bind(null, \"walletAllowances\", \"Wrapper\"); // event Transfer(address indexed _from, address indexed _to, uint256 _value)\n// event Approval(address indexed _owner, address indexed _spender, uint256 _value)\n\nlet subscribeToTransfersAndApprovals;\n\nsubscribeToTransfersAndApprovals = ({\n  activeTokenAddresses,\n  walletAddress,\n  provider,\n  onBalanceChange,\n  spenderAddress,\n  onApproval\n}) => {\n  // event Transfer(address indexed _from, address indexed _to, uint256 _value)\n  const filters = {\n    // Tokens being transferred out of our account or approved by our account\n    out: {\n      topics: [[id(\"Transfer(address,address,uint256)\"), id(\"Approval(address,address,uint256)\")], // event name\n      hexZeroPad(walletAddress, 32) // from\n      ]\n    },\n    // Tokens being transferred in to our account\n    in: {\n      topics: [id(\"Transfer(address,address,uint256)\"), // event name\n      [], hexZeroPad(walletAddress, 32) // to\n      ]\n    }\n  };\n  const tearDowns = [];\n  Object.keys(filters).forEach(direction => {\n    // in or out?\n    const typedDirection = direction;\n    const filter = filters[typedDirection];\n\n    function listener(event) {\n      const {\n        address\n      } = event;\n      const lowerCasedTokenAddress = address.toLowerCase(); // Ignore transactions for non-active tokens.\n\n      if (!activeTokenAddresses.includes(lowerCasedTokenAddress)) return;\n      const parsedEvent = erc20Interface.parseLog(event);\n      const isApproval = parsedEvent.name === \"Approval\"; // Ignore approvals for other spenders.\n\n      const approvalAddress = parsedEvent.args[1].toLowerCase();\n      const wrapperAddress = Wrapper.getAddress().toLowerCase();\n      if (isApproval && approvalAddress !== spenderAddress.toLowerCase() && approvalAddress !== wrapperAddress) return;\n      const amount = parsedEvent.args[2];\n      isApproval ? onApproval(lowerCasedTokenAddress, approvalAddress, amount) : onBalanceChange(lowerCasedTokenAddress, amount, typedDirection);\n    }\n\n    provider.on(filter, listener);\n    tearDowns.push(provider.off.bind(provider, filter, listener));\n  });\n  return () => {\n    tearDowns.forEach(fn => fn());\n  };\n};\n\nexport { fetchBalances, fetchAllowancesLight, fetchAllowancesWrapper, subscribeToTransfersAndApprovals };","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/features/balances/balancesApi.ts"],"names":["BalanceChecker","balancesDeploys","Light","Wrapper","erc20Abi","ethers","hexZeroPad","id","balancesInterface","utils","Interface","JSON","stringify","abi","erc20Interface","getContract","chainId","provider","Contract","fetchBalancesOrAllowances","method","spenderAddressType","tokenAddresses","walletAddress","contract","args","getAddress","amounts","apply","map","amount","toString","fetchBalances","bind","fetchAllowancesLight","fetchAllowancesWrapper","subscribeToTransfersAndApprovals","activeTokenAddresses","onBalanceChange","spenderAddress","onApproval","filters","out","topics","in","tearDowns","Object","keys","forEach","direction","typedDirection","filter","listener","event","address","lowerCasedTokenAddress","toLowerCase","includes","parsedEvent","parseLog","isApproval","name","approvalAddress","wrapperAddress","on","push","off","fn"],"mappings":"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","sourcesContent":["import BalanceChecker from \"@airswap/balances/build/contracts/BalanceChecker.json\";\nimport balancesDeploys from \"@airswap/balances/deploys.js\";\nimport { Light, Wrapper } from \"@airswap/libraries\";\n\nimport erc20Abi from \"erc-20-abi\";\nimport { BigNumber, ethers, EventFilter, Event, providers } from \"ethers\";\nimport { hexZeroPad, id } from \"ethers/lib/utils\";\n\ninterface SubscribeParams {\n  activeTokenAddresses: string[];\n  walletAddress: string;\n  spenderAddress: string;\n  provider: ethers.providers.Web3Provider;\n  onBalanceChange: (\n    tokenAddress: string,\n    amount: BigNumber,\n    direction: \"in\" | \"out\"\n  ) => void;\n  onApproval: (\n    tokenAddress: string,\n    spenderAddress: string,\n    amount: BigNumber\n  ) => void;\n}\n\ninterface WalletParams {\n  chainId: number;\n  provider: ethers.providers.Web3Provider;\n  walletAddress: string;\n  tokenAddresses: string[];\n}\n\nconst balancesInterface = new ethers.utils.Interface(\n  JSON.stringify(BalanceChecker.abi)\n);\n\nconst erc20Interface = new ethers.utils.Interface(erc20Abi);\n\nconst getContract = (\n  chainId: keyof typeof balancesDeploys,\n  provider: ethers.providers.Web3Provider\n) => {\n  return new ethers.Contract(\n    balancesDeploys[chainId],\n    balancesInterface,\n    provider as providers.Provider\n  );\n};\n\n/**\n * Fetches balances or allowances for a wallet using the airswap utility\n * contract `BalanceChecker.sol`. Balances are returned in base units.\n */\nconst fetchBalancesOrAllowances: (\n  method: \"walletBalances\" | \"walletAllowances\",\n  spenderAddressType: \"Wrapper\" | \"Light\" | \"None\",\n  params: WalletParams\n) => Promise<string[]> = async (\n  method,\n  spenderAddressType,\n  { chainId, provider, tokenAddresses, walletAddress }\n) => {\n  const contract = getContract(chainId, provider);\n  const args =\n    method === \"walletBalances\"\n      ? [walletAddress, tokenAddresses]\n      : spenderAddressType === \"Light\"\n      ? // sender, spender, tokens.\n        [walletAddress, Light.getAddress(chainId), tokenAddresses]\n      : [walletAddress, Wrapper.getAddress(chainId), tokenAddresses];\n  const amounts: BigNumber[] = await contract[method].apply(null, args);\n  return amounts.map((amount) => amount.toString());\n};\n\nconst fetchBalances = fetchBalancesOrAllowances.bind(\n  null,\n  \"walletBalances\",\n  \"None\"\n);\nconst fetchAllowancesLight = fetchBalancesOrAllowances.bind(\n  null,\n  \"walletAllowances\",\n  \"Light\"\n);\nconst fetchAllowancesWrapper = fetchBalancesOrAllowances.bind(\n  null,\n  \"walletAllowances\",\n  \"Wrapper\"\n);\n\n// event Transfer(address indexed _from, address indexed _to, uint256 _value)\n// event Approval(address indexed _owner, address indexed _spender, uint256 _value)\nlet subscribeToTransfersAndApprovals: (params: SubscribeParams) => () => void;\nsubscribeToTransfersAndApprovals = ({\n  activeTokenAddresses,\n  walletAddress,\n  provider,\n  onBalanceChange,\n  spenderAddress,\n  onApproval,\n}) => {\n  // event Transfer(address indexed _from, address indexed _to, uint256 _value)\n  const filters: {\n    in: EventFilter;\n    out: EventFilter;\n  } = {\n    // Tokens being transferred out of our account or approved by our account\n    out: {\n      topics: [\n        [\n          id(\"Transfer(address,address,uint256)\"),\n          id(\"Approval(address,address,uint256)\"),\n        ], // event name\n        hexZeroPad(walletAddress, 32), // from\n      ],\n    },\n\n    // Tokens being transferred in to our account\n    in: {\n      topics: [\n        id(\"Transfer(address,address,uint256)\"), // event name\n        [],\n        hexZeroPad(walletAddress, 32), // to\n      ],\n    },\n  };\n\n  const tearDowns: (() => void)[] = [];\n\n  Object.keys(filters).forEach((direction) => {\n    // in or out?\n    const typedDirection = direction as keyof typeof filters;\n    const filter = filters[typedDirection];\n\n    function listener(event: Event) {\n      const { address } = event;\n      const lowerCasedTokenAddress = address.toLowerCase();\n\n      // Ignore transactions for non-active tokens.\n      if (!activeTokenAddresses.includes(lowerCasedTokenAddress)) return;\n\n      const parsedEvent = erc20Interface.parseLog(event);\n      const isApproval = parsedEvent.name === \"Approval\";\n\n      // Ignore approvals for other spenders.\n      const approvalAddress = parsedEvent.args[1].toLowerCase();\n      const wrapperAddress = Wrapper.getAddress().toLowerCase();\n      if (\n        isApproval &&\n        approvalAddress !== spenderAddress.toLowerCase() &&\n        approvalAddress !== wrapperAddress\n      )\n        return;\n\n      const amount: BigNumber = parsedEvent.args[2];\n      isApproval\n        ? onApproval(lowerCasedTokenAddress, approvalAddress, amount)\n        : onBalanceChange(lowerCasedTokenAddress, amount, typedDirection);\n    }\n    provider.on(filter, listener);\n    tearDowns.push(provider.off.bind(provider, filter, listener));\n  });\n\n  return () => {\n    tearDowns.forEach((fn) => fn());\n  };\n};\n\nexport {\n  fetchBalances,\n  fetchAllowancesLight,\n  fetchAllowancesWrapper,\n  subscribeToTransfersAndApprovals,\n};\n"]},"metadata":{},"sourceType":"module"}