{"ast":null,"code":"import { combineReducers, createAction, createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport { BigNumber } from \"ethers\";\nimport { setWalletConnected } from \"../wallet/walletSlice\";\nimport { fetchAllowancesLight, fetchAllowancesWrapper, fetchBalances } from \"./balancesApi\";\n// Initially empty.\nexport const initialState = {\n  status: \"idle\",\n  lastFetch: null,\n  inFlightFetchTokens: null,\n  values: {}\n};\n\nconst getSetInFlightRequestTokensAction = type => {\n  return createAction(`${type}/setInFlightRequestTokens`);\n};\n\nconst getThunk = type => {\n  const methods = {\n    balances: fetchBalances,\n    \"allowances.light\": fetchAllowancesLight,\n    \"allowances.wrapper\": fetchAllowancesWrapper\n  };\n  return createAsyncThunk(`${type}/requestForActiveTokens`, async (params, {\n    getState,\n    dispatch\n  }) => {\n    try {\n      const state = getState();\n      const activeTokensAddresses = [...state.metadata.tokens.active, \"0x0000000000000000000000000000000000000000\"];\n      const {\n        chainId,\n        address\n      } = state.wallet;\n      dispatch(getSetInFlightRequestTokensAction(type)(activeTokensAddresses));\n      const amounts = await methods[type]({ ...params,\n        chainId: chainId,\n        walletAddress: address,\n        tokenAddresses: activeTokensAddresses\n      });\n      return activeTokensAddresses.map((address, i) => ({\n        address,\n        amount: amounts[i]\n      }));\n    } catch (e) {\n      console.error(`Error fetching ${type}: ` + e.message);\n      throw e;\n    }\n  }, {\n    // Logic to prevent fetching again if we're already fetching the same or more tokens.\n    condition: (params, {\n      getState\n    }) => {\n      const pathParts = type.split(\".\");\n      const sliceState = pathParts.length > 1 ? // @ts-ignore\n      getState()[pathParts[0]][pathParts[1]] : // @ts-ignore\n      getState()[type]; // If we're not fetching, definitely continue\n\n      if (sliceState.status !== \"fetching\") return true;\n\n      if (sliceState.inFlightFetchTokens) {\n        const tokensToFetch = getState().metadata.tokens.active; // only fetch if new list is larger.\n\n        return tokensToFetch.length > sliceState.inFlightFetchTokens.length;\n      }\n    }\n  });\n};\n\nconst getSlice = (type, asyncThunk) => {\n  return createSlice({\n    name: type,\n    initialState,\n    reducers: {\n      incrementBy: (state, action) => {\n        const currentAmount = BigNumber.from(state.values[action.payload.tokenAddress.toLowerCase()] || 0);\n        state.values[action.payload.tokenAddress.toLowerCase()] = currentAmount.add(action.payload.amount).toString();\n      },\n      decrementBy: (state, action) => {\n        const currentAmount = BigNumber.from(state.values[action.payload.tokenAddress.toLowerCase()] || 0);\n        let newAmount = currentAmount.sub(action.payload.amount);\n        if (newAmount.lt(\"0\")) newAmount = BigNumber.from(\"0\");\n        state.values[action.payload.tokenAddress.toLowerCase()] = newAmount.toString();\n      },\n      set: (state, action) => {\n        state.values[action.payload.tokenAddress.toLowerCase()] = action.payload.amount;\n      }\n    },\n    extraReducers: builder => {\n      builder // Reset to initial state if a new account is connected.\n      .addCase(setWalletConnected, () => initialState) // Handle requesting balances\n      .addCase(asyncThunk.pending, state => {\n        state.status = \"fetching\";\n      }).addCase(getSetInFlightRequestTokensAction(type), (state, action) => {\n        state.inFlightFetchTokens = action.payload;\n      }).addCase(asyncThunk.fulfilled, (state, action) => {\n        state.lastFetch = Date.now();\n        const tokenBalances = action.payload;\n        tokenBalances === null || tokenBalances === void 0 ? void 0 : tokenBalances.forEach(({\n          address,\n          amount\n        }) => {\n          state.values[address] = amount;\n        }); // Only clear fetching status if this request contained the largest\n        // list of tokens (which will be stored in inFlightFetchTokens)\n\n        if (state.inFlightFetchTokens && tokenBalances.every((result, i) => state.inFlightFetchTokens[i] === result.address)) {\n          state.inFlightFetchTokens = null;\n          state.status = \"idle\";\n        }\n      }).addCase(asyncThunk.rejected, (state, action) => {\n        state.status = \"failed\";\n      });\n    }\n  });\n};\n\nexport const selectBalances = state => state.balances;\nexport const selectAllowances = state => state.allowances;\nexport const selectAllowancesLight = state => state.allowances.light;\nexport const selectAllowancesWrapper = state => state.allowances.wrapper;\nexport const requestActiveTokenBalances = getThunk(\"balances\");\nexport const requestActiveTokenAllowancesLight = getThunk(\"allowances.light\");\nexport const requestActiveTokenAllowancesWrapper = getThunk(\"allowances.wrapper\");\nexport const balancesSlice = getSlice(\"balances\", requestActiveTokenBalances);\nexport const allowancesLightSlice = getSlice(\"allowances.light\", requestActiveTokenAllowancesLight);\nexport const allowancesWrapperSlice = getSlice(\"allowances.wrapper\", requestActiveTokenAllowancesWrapper);\nexport const {\n  incrementBy: incrementBalanceBy,\n  decrementBy: decrementBalanceBy,\n  set: setBalance\n} = balancesSlice.actions;\nexport const {\n  incrementBy: incrementAllowanceLightBy,\n  decrementBy: decrementAllowanceLightBy,\n  set: setAllowanceLight\n} = allowancesLightSlice.actions;\nexport const {\n  incrementBy: incrementAllowanceWrapperBy,\n  decrementBy: decreementAllowanceWrapperBy,\n  set: setAllowanceWrapper\n} = allowancesWrapperSlice.actions;\nexport const balancesActions = balancesSlice.actions;\nexport const allowancesLightActions = allowancesLightSlice.actions;\nexport const allowancesWrapperActions = allowancesWrapperSlice.actions;\nexport const balancesReducer = balancesSlice.reducer;\nexport const allowancesLightReducer = allowancesLightSlice.reducer;\nexport const allowancesWrapperReducer = allowancesWrapperSlice.reducer;\nexport const allowancesReducer = combineReducers({\n  light: allowancesLightReducer,\n  wrapper: allowancesWrapperReducer\n});","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/features/balances/balancesSlice.ts"],"names":["combineReducers","createAction","createAsyncThunk","createSlice","BigNumber","setWalletConnected","fetchAllowancesLight","fetchAllowancesWrapper","fetchBalances","initialState","status","lastFetch","inFlightFetchTokens","values","getSetInFlightRequestTokensAction","type","getThunk","methods","balances","params","getState","dispatch","state","activeTokensAddresses","metadata","tokens","active","chainId","address","wallet","amounts","walletAddress","tokenAddresses","map","i","amount","e","console","error","message","condition","pathParts","split","sliceState","length","tokensToFetch","getSlice","asyncThunk","name","reducers","incrementBy","action","currentAmount","from","payload","tokenAddress","toLowerCase","add","toString","decrementBy","newAmount","sub","lt","set","extraReducers","builder","addCase","pending","fulfilled","Date","now","tokenBalances","forEach","every","result","rejected","selectBalances","selectAllowances","allowances","selectAllowancesLight","light","selectAllowancesWrapper","wrapper","requestActiveTokenBalances","requestActiveTokenAllowancesLight","requestActiveTokenAllowancesWrapper","balancesSlice","allowancesLightSlice","allowancesWrapperSlice","incrementBalanceBy","decrementBalanceBy","setBalance","actions","incrementAllowanceLightBy","decrementAllowanceLightBy","setAllowanceLight","incrementAllowanceWrapperBy","decreementAllowanceWrapperBy","setAllowanceWrapper","balancesActions","allowancesLightActions","allowancesWrapperActions","balancesReducer","reducer","allowancesLightReducer","allowancesWrapperReducer","allowancesReducer"],"mappings":"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","sourcesContent":["import {\n  AsyncThunk,\n  combineReducers,\n  createAction,\n  createAsyncThunk,\n  createSlice,\n  PayloadAction,\n} from \"@reduxjs/toolkit\";\n\nimport { BigNumber, ethers } from \"ethers\";\n\nimport { AppDispatch, RootState } from \"../../app/store\";\nimport { setWalletConnected } from \"../wallet/walletSlice\";\nimport {\n  fetchAllowancesLight,\n  fetchAllowancesWrapper,\n  fetchBalances,\n} from \"./balancesApi\";\n\nexport interface BalancesState {\n  status: \"idle\" | \"fetching\" | \"failed\";\n  /** Timestamp of last successful fetch */\n  lastFetch: number | null;\n  /** An array of token addresses currently being fetched. If there are two\n   * fetches in flight, this array will contain the list of addresses in the\n   * largest request.\n   */\n  inFlightFetchTokens: string[] | null; // used to prevent duplicate fetches\n  /** Token balances */\n  values: {\n    [tokenAddress: string]: string | null; // null while fetching\n  };\n}\n\n// Initially empty.\nexport const initialState: BalancesState = {\n  status: \"idle\",\n  lastFetch: null,\n  inFlightFetchTokens: null,\n  values: {},\n};\n\nconst getSetInFlightRequestTokensAction = (\n  type: \"balances\" | \"allowances.light\" | \"allowances.wrapper\"\n) => {\n  return createAction<string[]>(`${type}/setInFlightRequestTokens`);\n};\n\nconst getThunk: (\n  type: \"balances\" | \"allowances.light\" | \"allowances.wrapper\"\n) => AsyncThunk<\n  { address: string; amount: string }[],\n  {\n    provider: ethers.providers.Web3Provider;\n  },\n  {}\n> = (type: \"balances\" | \"allowances.light\" | \"allowances.wrapper\") => {\n  const methods = {\n    balances: fetchBalances,\n    \"allowances.light\": fetchAllowancesLight,\n    \"allowances.wrapper\": fetchAllowancesWrapper,\n  };\n  return createAsyncThunk<\n    { address: string; amount: string }[],\n    {\n      provider: ethers.providers.Web3Provider;\n    },\n    {\n      // Optional fields for defining thunkApi field types\n      dispatch: AppDispatch;\n      state: RootState;\n    }\n  >(\n    `${type}/requestForActiveTokens`,\n    async (params, { getState, dispatch }) => {\n      try {\n        const state = getState();\n        const activeTokensAddresses = [\n          ...state.metadata.tokens.active,\n          \"0x0000000000000000000000000000000000000000\",\n        ];\n        const { chainId, address } = state.wallet;\n        dispatch(\n          getSetInFlightRequestTokensAction(type)(activeTokensAddresses)\n        );\n        const amounts = await methods[type]({\n          ...params,\n          chainId: chainId!,\n          walletAddress: address!,\n          tokenAddresses: activeTokensAddresses,\n        });\n        return activeTokensAddresses.map((address, i) => ({\n          address,\n          amount: amounts[i],\n        }));\n      } catch (e: any) {\n        console.error(`Error fetching ${type}: ` + e.message);\n        throw e;\n      }\n    },\n    {\n      // Logic to prevent fetching again if we're already fetching the same or more tokens.\n      condition: (params, { getState }) => {\n        const pathParts = type.split(\".\");\n        const sliceState =\n          pathParts.length > 1\n            ? // @ts-ignore\n              getState()[pathParts[0]][pathParts[1]]\n            : // @ts-ignore\n              getState()[type];\n        // If we're not fetching, definitely continue\n        if (sliceState.status !== \"fetching\") return true;\n        if (sliceState.inFlightFetchTokens) {\n          const tokensToFetch = getState().metadata.tokens.active;\n          // only fetch if new list is larger.\n          return tokensToFetch.length > sliceState.inFlightFetchTokens.length;\n        }\n      },\n    }\n  );\n};\n\nconst getSlice = (\n  type: \"balances\" | \"allowances.light\" | \"allowances.wrapper\",\n  asyncThunk: ReturnType<typeof getThunk>\n) => {\n  return createSlice({\n    name: type,\n    initialState,\n    reducers: {\n      incrementBy: (\n        state,\n        action: PayloadAction<{ tokenAddress: string; amount: string }>\n      ) => {\n        const currentAmount = BigNumber.from(\n          state.values[action.payload.tokenAddress.toLowerCase()] || 0\n        );\n        state.values[\n          action.payload.tokenAddress.toLowerCase()\n        ] = currentAmount.add(action.payload.amount).toString();\n      },\n      decrementBy: (\n        state,\n        action: PayloadAction<{ tokenAddress: string; amount: string }>\n      ) => {\n        const currentAmount = BigNumber.from(\n          state.values[action.payload.tokenAddress.toLowerCase()] || 0\n        );\n        let newAmount = currentAmount.sub(action.payload.amount);\n        if (newAmount.lt(\"0\")) newAmount = BigNumber.from(\"0\");\n        state.values[\n          action.payload.tokenAddress.toLowerCase()\n        ] = newAmount.toString();\n      },\n      set: (\n        state,\n        action: PayloadAction<{ tokenAddress: string; amount: string }>\n      ) => {\n        state.values[action.payload.tokenAddress.toLowerCase()] =\n          action.payload.amount;\n      },\n    },\n    extraReducers: (builder) => {\n      builder\n        // Reset to initial state if a new account is connected.\n        .addCase(setWalletConnected, () => initialState)\n\n        // Handle requesting balances\n        .addCase(asyncThunk.pending, (state) => {\n          state.status = \"fetching\";\n        })\n        .addCase(getSetInFlightRequestTokensAction(type), (state, action) => {\n          state.inFlightFetchTokens = action.payload;\n        })\n        .addCase(asyncThunk.fulfilled, (state, action) => {\n          state.lastFetch = Date.now();\n          const tokenBalances = action.payload;\n\n          tokenBalances?.forEach(({ address, amount }) => {\n            state.values[address] = amount;\n          });\n\n          // Only clear fetching status if this request contained the largest\n          // list of tokens (which will be stored in inFlightFetchTokens)\n          if (\n            state.inFlightFetchTokens &&\n            tokenBalances.every(\n              (result, i) => state.inFlightFetchTokens![i] === result.address\n            )\n          ) {\n            state.inFlightFetchTokens = null;\n            state.status = \"idle\";\n          }\n        })\n        .addCase(asyncThunk.rejected, (state, action) => {\n          state.status = \"failed\";\n        });\n    },\n  });\n};\n\nexport const selectBalances = (state: RootState) => state.balances;\nexport const selectAllowances = (state: RootState) => state.allowances;\nexport const selectAllowancesLight = (state: RootState) =>\n  state.allowances.light;\nexport const selectAllowancesWrapper = (state: RootState) =>\n  state.allowances.wrapper;\n\nexport const requestActiveTokenBalances = getThunk(\"balances\");\nexport const requestActiveTokenAllowancesLight = getThunk(\"allowances.light\");\nexport const requestActiveTokenAllowancesWrapper = getThunk(\n  \"allowances.wrapper\"\n);\n\nexport const balancesSlice = getSlice(\"balances\", requestActiveTokenBalances);\nexport const allowancesLightSlice = getSlice(\n  \"allowances.light\",\n  requestActiveTokenAllowancesLight\n);\nexport const allowancesWrapperSlice = getSlice(\n  \"allowances.wrapper\",\n  requestActiveTokenAllowancesWrapper\n);\n\nexport const {\n  incrementBy: incrementBalanceBy,\n  decrementBy: decrementBalanceBy,\n  set: setBalance,\n} = balancesSlice.actions;\nexport const {\n  incrementBy: incrementAllowanceLightBy,\n  decrementBy: decrementAllowanceLightBy,\n  set: setAllowanceLight,\n} = allowancesLightSlice.actions;\nexport const {\n  incrementBy: incrementAllowanceWrapperBy,\n  decrementBy: decreementAllowanceWrapperBy,\n  set: setAllowanceWrapper,\n} = allowancesWrapperSlice.actions;\n\nexport const balancesActions = balancesSlice.actions;\nexport const allowancesLightActions = allowancesLightSlice.actions;\nexport const allowancesWrapperActions = allowancesWrapperSlice.actions;\n\nexport const balancesReducer = balancesSlice.reducer;\nexport const allowancesLightReducer = allowancesLightSlice.reducer;\nexport const allowancesWrapperReducer = allowancesWrapperSlice.reducer;\nexport const allowancesReducer = combineReducers({\n  light: allowancesLightReducer,\n  wrapper: allowancesWrapperReducer,\n});\n"]},"metadata":{},"sourceType":"module"}