{"ast":null,"code":"import { ethers } from \"ethers\";\n/**\n * Create a filter function to apply to a token for whether it matches a particular search query\n * @param search the search query to apply to the token\n */\n\nexport function createTokenFilterFunction(search) {\n  const searchingAddress = ethers.utils.isAddress(search);\n\n  if (searchingAddress) {\n    return t => t.address.toLowerCase() === search.toLowerCase();\n  }\n\n  const lowerSearchParts = search.toLowerCase().split(/\\s+/).filter(s => s.length > 0);\n  if (lowerSearchParts.length === 0) return () => true;\n\n  const matchesSearch = s => {\n    const sParts = s.toLowerCase().split(/\\s+/).filter(s => s.length > 0);\n    return lowerSearchParts.every(p => p.length === 0 || sParts.some(sp => sp.startsWith(p) || sp.endsWith(p)));\n  };\n\n  return ({\n    name,\n    symbol\n  }) => Boolean(symbol && matchesSearch(symbol) || name && matchesSearch(name));\n}\nexport function filterTokens(tokens, search) {\n  return tokens.filter(createTokenFilterFunction(search));\n}","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/components/TokenList/filter.ts"],"names":["ethers","createTokenFilterFunction","search","searchingAddress","utils","isAddress","t","address","toLowerCase","lowerSearchParts","split","filter","s","length","matchesSearch","sParts","every","p","some","sp","startsWith","endsWith","name","symbol","Boolean","filterTokens","tokens"],"mappings":"AAEA,SAASA,MAAT,QAAuB,QAAvB;AAEA;AACA;AACA;AACA;;AACA,OAAO,SAASC,yBAAT,CACLC,MADK,EAEmB;AACxB,QAAMC,gBAAgB,GAAGH,MAAM,CAACI,KAAP,CAAaC,SAAb,CAAuBH,MAAvB,CAAzB;;AAEA,MAAIC,gBAAJ,EAAsB;AACpB,WAAQG,CAAD,IAAUA,CAAC,CAACC,OAAF,CAAUC,WAAV,OAA4BN,MAAM,CAACM,WAAP,EAA7C;AACD;;AAED,QAAMC,gBAAgB,GAAGP,MAAM,CAC5BM,WADsB,GAEtBE,KAFsB,CAEhB,KAFgB,EAGtBC,MAHsB,CAGdC,CAAD,IAAOA,CAAC,CAACC,MAAF,GAAW,CAHH,CAAzB;AAKA,MAAIJ,gBAAgB,CAACI,MAAjB,KAA4B,CAAhC,EAAmC,OAAO,MAAM,IAAb;;AAEnC,QAAMC,aAAa,GAAIF,CAAD,IAAwB;AAC5C,UAAMG,MAAM,GAAGH,CAAC,CACbJ,WADY,GAEZE,KAFY,CAEN,KAFM,EAGZC,MAHY,CAGJC,CAAD,IAAOA,CAAC,CAACC,MAAF,GAAW,CAHb,CAAf;AAKA,WAAOJ,gBAAgB,CAACO,KAAjB,CACJC,CAAD,IACEA,CAAC,CAACJ,MAAF,KAAa,CAAb,IACAE,MAAM,CAACG,IAAP,CAAaC,EAAD,IAAQA,EAAE,CAACC,UAAH,CAAcH,CAAd,KAAoBE,EAAE,CAACE,QAAH,CAAYJ,CAAZ,CAAxC,CAHG,CAAP;AAKD,GAXD;;AAaA,SAAO,CAAC;AAAEK,IAAAA,IAAF;AAAQC,IAAAA;AAAR,GAAD,KACLC,OAAO,CAAED,MAAM,IAAIT,aAAa,CAACS,MAAD,CAAxB,IAAsCD,IAAI,IAAIR,aAAa,CAACQ,IAAD,CAA5D,CADT;AAED;AAED,OAAO,SAASG,YAAT,CACLC,MADK,EAELxB,MAFK,EAGA;AACL,SAAOwB,MAAM,CAACf,MAAP,CAAcV,yBAAyB,CAACC,MAAD,CAAvC,CAAP;AACD","sourcesContent":["import { TokenInfo } from \"@airswap/types\";\n\nimport { ethers } from \"ethers\";\n\n/**\n * Create a filter function to apply to a token for whether it matches a particular search query\n * @param search the search query to apply to the token\n */\nexport function createTokenFilterFunction<T extends TokenInfo>(\n  search: string\n): (tokens: T) => boolean {\n  const searchingAddress = ethers.utils.isAddress(search);\n\n  if (searchingAddress) {\n    return (t: T) => t.address.toLowerCase() === search.toLowerCase();\n  }\n\n  const lowerSearchParts = search\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter((s) => s.length > 0);\n\n  if (lowerSearchParts.length === 0) return () => true;\n\n  const matchesSearch = (s: string): boolean => {\n    const sParts = s\n      .toLowerCase()\n      .split(/\\s+/)\n      .filter((s) => s.length > 0);\n\n    return lowerSearchParts.every(\n      (p) =>\n        p.length === 0 ||\n        sParts.some((sp) => sp.startsWith(p) || sp.endsWith(p))\n    );\n  };\n\n  return ({ name, symbol }: T): boolean =>\n    Boolean((symbol && matchesSearch(symbol)) || (name && matchesSearch(name)));\n}\n\nexport function filterTokens<T extends TokenInfo>(\n  tokens: T[],\n  search: string\n): T[] {\n  return tokens.filter(createTokenFilterFunction(search));\n}\n"]},"metadata":{},"sourceType":"module"}