{"ast":null,"code":"var _jsxFileName = \"/Users/marcusmattus/ethdex/airswap-web/src/contexts/lastLook/LastLook.tsx\",\n    _s = $RefreshSig$();\n\nimport { createContext, useCallback, useMemo } from \"react\";\nimport { useTranslation } from \"react-i18next\";\n// TODO: type defs for this.\n// @ts-ignore\nimport lightDeploys from \"@airswap/light/deploys.js\";\nimport { createOrder, createSwapSignature } from \"@airswap/utils\";\nimport { useWeb3React } from \"@web3-react/core\";\nimport BigNumber from \"bignumber.js\";\nimport { useAppDispatch } from \"../../app/hooks\";\nimport { notifyError } from \"../../components/Toasts/ToastController\";\nimport { LAST_LOOK_ORDER_EXPIRY_SEC } from \"../../constants/configParams\";\nimport { updatePricing } from \"../../features/pricing/pricingSlice\";\nimport { submitTransactionWithExpiry } from \"../../features/transactions/transactionsSlice\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nexport const LastLookContext = /*#__PURE__*/createContext({\n  subscribeAllServers(servers, pair) {\n    return [];\n  },\n\n  unsubscribeAllServers: () => {},\n  sendOrderForConsideration: async () => {\n    return false;\n  },\n  getSignedOrder: async params => {\n    return {};\n  }\n});\nconst connectedServers = {};\n\nconst LastLookProvider = ({\n  children\n}) => {\n  _s();\n\n  const {\n    account,\n    library,\n    chainId\n  } = useWeb3React();\n  const {\n    t\n  } = useTranslation();\n  const dispatch = useAppDispatch();\n  const subscribeAllServers = useCallback((servers, pair) => {\n    return servers.map(async s => {\n      return new Promise(async resolve => {\n        let server = s;\n        if (connectedServers[s.locator]) server = connectedServers[s.locator];\n        connectedServers[server.locator] = server;\n\n        const handlePricing = pricing => {\n          const pairPricing = pricing.find(p => p && p.baseToken === pair.baseToken && p.quoteToken === pair.quoteToken);\n\n          if (pairPricing) {\n            resolve(pairPricing);\n            dispatch(updatePricing({\n              locator: server.locator,\n              pricing: pairPricing\n            }));\n          } else {\n            console.warn(`Didn't receive pricing for pair in update from ${server.locator}`);\n          }\n        };\n\n        server.on(\"pricing\", handlePricing.bind(null));\n        server.on(\"error\", e => {\n          console.error(`RPC WebSocket error: [${server.locator}]: ${e.code} - ${e.message}`, e);\n        });\n        const pricing = await server.subscribe([pair]);\n        handlePricing(pricing);\n      });\n    });\n  }, [dispatch]);\n  const unsubscribeAllServers = useCallback(() => {\n    Object.keys(connectedServers).forEach(locator => {\n      const server = connectedServers[locator];\n      server.removeAllListeners();\n      server.disconnect();\n      delete connectedServers[locator];\n    });\n  }, []);\n  const getSignedOrder = useCallback(async params => {\n    const {\n      locator,\n      terms\n    } = params;\n    const server = connectedServers[locator];\n    const isSell = terms.side === \"sell\";\n    if (terms.quoteAmount === null) throw new Error(\"No quote amount specified\");\n    const baseAmountAtomic = new BigNumber(terms.baseAmount).multipliedBy(10 ** terms.baseToken.decimals) // Note that we remove the signer fee from the amount that we send.\n    // This was already done to determine quoteAmount.\n    .dividedBy(terms.side === \"sell\" ? 1.0007 : 1).integerValue(BigNumber.ROUND_CEIL).toString();\n    const quoteAmountAtomic = new BigNumber(terms.quoteAmount).multipliedBy(10 ** terms.quoteToken.decimals).integerValue(BigNumber.ROUND_FLOOR).toString();\n    const unsignedOrder = createOrder({\n      expiry: Math.floor(Date.now() / 1000 + LAST_LOOK_ORDER_EXPIRY_SEC),\n      nonce: Date.now().toString(),\n      senderWallet: server.getSenderWallet(),\n      signerWallet: account,\n      signerToken: terms.baseToken.address,\n      senderToken: terms.quoteToken.address,\n      signerFee: \"7\",\n      signerAmount: isSell ? baseAmountAtomic : quoteAmountAtomic,\n      senderAmount: !isSell ? baseAmountAtomic : quoteAmountAtomic\n    });\n    const signature = await createSwapSignature(unsignedOrder, library.getSigner(), lightDeploys[chainId], chainId);\n    const order = {\n      expiry: unsignedOrder.expiry,\n      nonce: unsignedOrder.nonce,\n      senderToken: unsignedOrder.senderToken,\n      senderAmount: unsignedOrder.senderAmount,\n      signerWallet: unsignedOrder.signerWallet,\n      signerToken: unsignedOrder.signerToken,\n      signerAmount: unsignedOrder.signerAmount,\n      ...signature\n    };\n    const transaction = {\n      type: \"Order\",\n      order: order,\n      nonce: order.nonce,\n      status: \"processing\",\n      protocol: \"last-look\",\n      expiry: unsignedOrder.expiry,\n      timestamp: Date.now()\n    };\n    dispatch(submitTransactionWithExpiry({\n      transaction,\n      signerWallet: unsignedOrder.signerWallet,\n      onExpired: () => {\n        notifyError({\n          heading: t(\"orders.swapExpired\"),\n          cta: t(\"orders.swapExpiredCallToAction\")\n        });\n      }\n    }));\n    return {\n      order,\n      senderWallet: unsignedOrder.senderWallet\n    };\n  }, [account, chainId, dispatch, library, t]);\n  const sendOrderForConsideration = useCallback(async params => {\n    const {\n      locator,\n      order\n    } = params;\n    const server = connectedServers[locator];\n\n    try {\n      return server.consider(order);\n    } catch (e) {\n      console.error(\"Server unable to consider order: \", e);\n      throw e;\n    }\n  }, []);\n  const value = useMemo(() => ({\n    subscribeAllServers,\n    unsubscribeAllServers,\n    sendOrderForConsideration,\n    getSignedOrder\n  }), [getSignedOrder, subscribeAllServers, unsubscribeAllServers, sendOrderForConsideration]);\n  return /*#__PURE__*/_jsxDEV(LastLookContext.Provider, {\n    value: value,\n    children: children\n  }, void 0, false, {\n    fileName: _jsxFileName,\n    lineNumber: 230,\n    columnNumber: 5\n  }, this);\n};\n\n_s(LastLookProvider, \"+kWYGm4vC5Ig9EBY4MtdI67WyGc=\", false, function () {\n  return [useWeb3React, useTranslation, useAppDispatch];\n});\n\n_c = LastLookProvider;\nexport default LastLookProvider;\n\nvar _c;\n\n$RefreshReg$(_c, \"LastLookProvider\");","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/contexts/lastLook/LastLook.tsx"],"names":["createContext","useCallback","useMemo","useTranslation","lightDeploys","createOrder","createSwapSignature","useWeb3React","BigNumber","useAppDispatch","notifyError","LAST_LOOK_ORDER_EXPIRY_SEC","updatePricing","submitTransactionWithExpiry","LastLookContext","subscribeAllServers","servers","pair","unsubscribeAllServers","sendOrderForConsideration","getSignedOrder","params","connectedServers","LastLookProvider","children","account","library","chainId","t","dispatch","map","s","Promise","resolve","server","locator","handlePricing","pricing","pairPricing","find","p","baseToken","quoteToken","console","warn","on","bind","e","error","code","message","subscribe","Object","keys","forEach","removeAllListeners","disconnect","terms","isSell","side","quoteAmount","Error","baseAmountAtomic","baseAmount","multipliedBy","decimals","dividedBy","integerValue","ROUND_CEIL","toString","quoteAmountAtomic","ROUND_FLOOR","unsignedOrder","expiry","Math","floor","Date","now","nonce","senderWallet","getSenderWallet","signerWallet","signerToken","address","senderToken","signerFee","signerAmount","senderAmount","signature","getSigner","order","transaction","type","status","protocol","timestamp","onExpired","heading","cta","consider","value"],"mappings":"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","sourcesContent":["import { createContext, FC, useCallback, useMemo } from \"react\";\nimport { useTranslation } from \"react-i18next\";\n\nimport { Server } from \"@airswap/libraries\";\n// TODO: type defs for this.\n// @ts-ignore\nimport lightDeploys from \"@airswap/light/deploys.js\";\nimport { LightOrder, Pricing } from \"@airswap/types\";\nimport { createOrder, createSwapSignature } from \"@airswap/utils\";\nimport { useWeb3React } from \"@web3-react/core\";\n\nimport BigNumber from \"bignumber.js\";\n\nimport { useAppDispatch } from \"../../app/hooks\";\nimport { notifyError } from \"../../components/Toasts/ToastController\";\nimport { LAST_LOOK_ORDER_EXPIRY_SEC } from \"../../constants/configParams\";\nimport { updatePricing } from \"../../features/pricing/pricingSlice\";\nimport { TradeTerms } from \"../../features/tradeTerms/tradeTermsSlice\";\nimport {\n  SubmittedTransactionWithOrder,\n  submitTransactionWithExpiry,\n} from \"../../features/transactions/transactionsSlice\";\n\ntype Pair = {\n  baseToken: string;\n  quoteToken: string;\n};\n\nexport const LastLookContext = createContext<{\n  subscribeAllServers: (servers: Server[], pair: Pair) => Promise<Pricing>[];\n  unsubscribeAllServers: () => void;\n  sendOrderForConsideration: (params: {\n    locator: string;\n    order: LightOrder;\n  }) => Promise<boolean>;\n  getSignedOrder: (params: {\n    locator: string;\n    terms: TradeTerms;\n  }) => Promise<{ order: LightOrder; senderWallet: string }>;\n}>({\n  subscribeAllServers(servers: Server[], pair: Pair): Promise<Pricing | any>[] {\n    return [];\n  },\n  unsubscribeAllServers: () => {},\n  sendOrderForConsideration: async () => {\n    return false;\n  },\n  getSignedOrder: async (params: {\n    locator: string;\n    terms: TradeTerms;\n  }): Promise<LightOrder | any> => {\n    return {};\n  },\n});\n\nconst connectedServers: Record<string, Server> = {};\nconst LastLookProvider: FC = ({ children }) => {\n  const { account, library, chainId } = useWeb3React();\n\n  const { t } = useTranslation();\n\n  const dispatch = useAppDispatch();\n\n  const subscribeAllServers = useCallback(\n    (servers: Server[], pair: Pair) => {\n      return servers.map(async (s) => {\n        return new Promise<Pricing>(async (resolve) => {\n          let server = s;\n          if (connectedServers[s.locator]) server = connectedServers[s.locator];\n          connectedServers[server.locator] = server;\n\n          const handlePricing = (pricing: Pricing[]) => {\n            const pairPricing = pricing.find(\n              (p) =>\n                p &&\n                p.baseToken === pair.baseToken &&\n                p.quoteToken === pair.quoteToken\n            );\n            if (pairPricing) {\n              resolve(pairPricing);\n              dispatch(\n                updatePricing({\n                  locator: server.locator,\n                  pricing: pairPricing,\n                })\n              );\n            } else {\n              console.warn(\n                `Didn't receive pricing for pair in update from ${server.locator}`\n              );\n            }\n          };\n\n          server.on(\"pricing\", handlePricing.bind(null));\n          server.on(\"error\", (e) => {\n            console.error(\n              `RPC WebSocket error: [${server.locator}]: ${e.code} - ${e.message}`,\n              e\n            );\n          });\n          const pricing = await server.subscribe([pair]);\n          handlePricing(pricing);\n        });\n      });\n    },\n    [dispatch]\n  );\n\n  const unsubscribeAllServers = useCallback(() => {\n    Object.keys(connectedServers).forEach((locator) => {\n      const server = connectedServers[locator];\n      server.removeAllListeners();\n      server.disconnect();\n      delete connectedServers[locator];\n    });\n  }, []);\n\n  const getSignedOrder = useCallback(\n    async (params: {\n      locator: string;\n      terms: TradeTerms;\n    }): Promise<{ order: LightOrder; senderWallet: string }> => {\n      const { locator, terms } = params;\n      const server = connectedServers[locator];\n\n      const isSell = terms.side === \"sell\";\n\n      if (terms.quoteAmount === null)\n        throw new Error(\"No quote amount specified\");\n      const baseAmountAtomic = new BigNumber(terms.baseAmount)\n        .multipliedBy(10 ** terms.baseToken.decimals)\n        // Note that we remove the signer fee from the amount that we send.\n        // This was already done to determine quoteAmount.\n        .dividedBy(terms.side === \"sell\" ? 1.0007 : 1)\n        .integerValue(BigNumber.ROUND_CEIL)\n        .toString();\n      const quoteAmountAtomic = new BigNumber(terms.quoteAmount!)\n        .multipliedBy(10 ** terms.quoteToken.decimals)\n        .integerValue(BigNumber.ROUND_FLOOR)\n        .toString();\n\n      const unsignedOrder = createOrder({\n        expiry: Math.floor(Date.now() / 1000 + LAST_LOOK_ORDER_EXPIRY_SEC),\n        nonce: Date.now().toString(),\n        senderWallet: server.getSenderWallet(),\n        signerWallet: account,\n        signerToken: terms.baseToken.address,\n        senderToken: terms.quoteToken.address,\n        signerFee: \"7\",\n        signerAmount: isSell ? baseAmountAtomic : quoteAmountAtomic,\n        senderAmount: !isSell ? baseAmountAtomic : quoteAmountAtomic,\n      });\n      const signature = await createSwapSignature(\n        unsignedOrder,\n        library.getSigner(),\n        lightDeploys[chainId],\n        chainId!\n      );\n      const order: LightOrder = {\n        expiry: unsignedOrder.expiry,\n        nonce: unsignedOrder.nonce,\n        senderToken: unsignedOrder.senderToken,\n        senderAmount: unsignedOrder.senderAmount,\n        signerWallet: unsignedOrder.signerWallet,\n        signerToken: unsignedOrder.signerToken,\n        signerAmount: unsignedOrder.signerAmount,\n        ...signature,\n      };\n\n      const transaction: SubmittedTransactionWithOrder = {\n        type: \"Order\",\n        order: order,\n        nonce: order.nonce,\n        status: \"processing\",\n        protocol: \"last-look\",\n        expiry: unsignedOrder.expiry,\n        timestamp: Date.now(),\n      };\n      dispatch(\n        submitTransactionWithExpiry({\n          transaction,\n          signerWallet: unsignedOrder.signerWallet,\n          onExpired: () => {\n            notifyError({\n              heading: t(\"orders.swapExpired\"),\n              cta: t(\"orders.swapExpiredCallToAction\"),\n            });\n          },\n        })\n      );\n\n      return {\n        order,\n        senderWallet: unsignedOrder.senderWallet,\n      };\n    },\n    [account, chainId, dispatch, library, t]\n  );\n\n  const sendOrderForConsideration = useCallback(\n    async (params: { locator: string; order: LightOrder }) => {\n      const { locator, order } = params;\n      const server = connectedServers[locator];\n      try {\n        return server.consider(order);\n      } catch (e) {\n        console.error(\"Server unable to consider order: \", e);\n        throw e;\n      }\n    },\n    []\n  );\n\n  const value = useMemo(\n    () => ({\n      subscribeAllServers,\n      unsubscribeAllServers,\n      sendOrderForConsideration,\n      getSignedOrder,\n    }),\n    [\n      getSignedOrder,\n      subscribeAllServers,\n      unsubscribeAllServers,\n      sendOrderForConsideration,\n    ]\n  );\n\n  return (\n    <LastLookContext.Provider value={value}>\n      {children}\n    </LastLookContext.Provider>\n  );\n};\n\nexport default LastLookProvider;\n"]},"metadata":{},"sourceType":"module"}