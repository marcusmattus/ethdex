{"ast":null,"code":"'use strict';\n\nconst events = require('events');\n\nconst isPlainObject = require('lodash/isPlainObject');\n\nconst utils = require('../utils');\n/**\n *  Constructor for a Jayson Client\n *  @class Client\n *  @extends require('events').EventEmitter\n *  @param {Server} [server] An instance of Server (a object with a \"call\" method\")\n *  @param {Object} [options]\n *  @param {Function} [options.reviver] Reviver function for JSON\n *  @param {Function} [options.replacer] Replacer function for JSON\n *  @param {Number} [options.version=2] JSON-RPC version to use (1|2)\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n *  @param {Function} [options.generator] Function to use for generating request IDs\n *  @return {Client}\n */\n\n\nconst Client = function (server, options) {\n  if (arguments.length === 1 && isPlainObject(server)) {\n    options = server;\n    server = null;\n  }\n\n  if (!(this instanceof Client)) {\n    return new Client(server, options);\n  }\n\n  const defaults = {\n    reviver: null,\n    replacer: null,\n    generator: utils.generateId,\n    version: 2,\n    notificationIdNull: false\n  };\n  this.options = utils.merge(defaults, options || {});\n\n  if (server) {\n    this.server = server;\n  }\n};\n\nrequire('util').inherits(Client, events.EventEmitter);\n\nmodule.exports = Client;\n/**\n * HTTP client constructor\n * @type ClientHttp\n * @static\n */\n\nClient.http = require('./http');\n/**\n * HTTPS client constructor\n * @type ClientHttps\n * @static\n */\n\nClient.https = require('./https');\n/**\n * TCP client constructor\n * @type ClientTcp\n * @static\n */\n\nClient.tcp = require('./tcp');\n/**\n * TLS client constructor\n * @type ClientTls\n * @static\n */\n\nClient.tls = require('./tls');\n/**\n * Browser client constructor\n * @type ClientBrowser\n * @static\n */\n\nClient.browser = require('./browser');\n/**\n * Websocket client constructor\n * @type ClientWebsocket\n * @static\n */\n\nClient.websocket = require('./websocket');\n/**\n *  Creates a request and dispatches it if given a callback.\n *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String\n *  @param {Array|Object} params Parameters for the method\n *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request\n *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.\n *  @throws {TypeError} Invalid parameters\n *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request\n */\n\nClient.prototype.request = function (method, params, id, callback) {\n  const self = this;\n  let request = null; // is this a batch request?\n\n  const isBatch = Array.isArray(method) && typeof params === 'function';\n\n  if (this.options.version === 1 && isBatch) {\n    throw new TypeError('JSON-RPC 1.0 does not support batching');\n  } // is this a raw request?\n\n\n  const isRaw = !isBatch && method && typeof method === 'object' && typeof params === 'function';\n\n  if (isBatch || isRaw) {\n    callback = params;\n    request = method;\n  } else {\n    if (typeof id === 'function') {\n      callback = id; // specifically undefined because \"null\" is a notification request\n\n      id = undefined;\n    }\n\n    const hasCallback = typeof callback === 'function';\n\n    try {\n      request = utils.request(method, params, id, {\n        generator: this.options.generator,\n        version: this.options.version,\n        notificationIdNull: this.options.notificationIdNull\n      });\n    } catch (err) {\n      if (hasCallback) {\n        callback(err);\n        return;\n      }\n\n      throw err;\n    } // no callback means we should just return a raw request before sending\n\n\n    if (!hasCallback) {\n      return request;\n    }\n  }\n\n  this.emit('request', request);\n\n  this._request(request, function (err, response) {\n    self.emit('response', request, response);\n\n    self._parseResponse(err, response, callback);\n  }); // always return the raw request\n\n\n  return request;\n};\n/**\n *  Executes a request on a directly bound server\n *  @param {Object} request A JSON-RPC 1.0 or 2.0 request\n *  @param {Function} callback Request callback that will receive the server response as the second argument\n *  @private\n */\n\n\nClient.prototype._request = function (request, callback) {\n  const self = this; // serializes the request as a JSON string so that we get a copy and can run the replacer as intended\n\n  utils.JSON.stringify(request, this.options, function (err, message) {\n    if (err) {\n      callback(err);\n      return;\n    }\n\n    self.server.call(message, function (error, success) {\n      const response = error || success;\n      callback(null, response);\n    });\n  });\n};\n/**\n * Parses a response from a server, taking care of sugaring\n * @param {Object} err Error to pass on that is unrelated to the actual response\n * @param {Object} response JSON-RPC 1.0 or 2.0 response\n * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters\n * @private\n */\n\n\nClient.prototype._parseResponse = function (err, response, callback) {\n  if (err) {\n    return callback(err);\n  }\n\n  if (!response || typeof response !== 'object') {\n    return callback();\n  }\n\n  if (callback.length === 3) {\n    // if callback length is 3, we split callback arguments on error and response\n    // is batch response?\n    if (Array.isArray(response)) {\n      // neccesary to split strictly on validity according to spec here\n      const isError = function (res) {\n        return typeof res.error !== 'undefined';\n      };\n\n      const isNotError = function (res) {\n        return !isError(res);\n      };\n\n      return callback(null, response.filter(isError), response.filter(isNotError));\n    } else {\n      // split regardless of validity\n      return callback(null, response.error, response.result);\n    }\n  }\n\n  return callback(null, response);\n};","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/node_modules/jayson/lib/client/index.js"],"names":["events","require","isPlainObject","utils","Client","server","options","arguments","length","defaults","reviver","replacer","generator","generateId","version","notificationIdNull","merge","inherits","EventEmitter","module","exports","http","https","tcp","tls","browser","websocket","prototype","request","method","params","id","callback","self","isBatch","Array","isArray","TypeError","isRaw","undefined","hasCallback","err","emit","_request","response","_parseResponse","JSON","stringify","message","call","error","success","isError","res","isNotError","filter","result"],"mappings":"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","sourcesContent":["'use strict';\n\nconst events = require('events');\nconst isPlainObject = require('lodash/isPlainObject');\nconst utils = require('../utils');\n\n/**\n *  Constructor for a Jayson Client\n *  @class Client\n *  @extends require('events').EventEmitter\n *  @param {Server} [server] An instance of Server (a object with a \"call\" method\")\n *  @param {Object} [options]\n *  @param {Function} [options.reviver] Reviver function for JSON\n *  @param {Function} [options.replacer] Replacer function for JSON\n *  @param {Number} [options.version=2] JSON-RPC version to use (1|2)\n *  @param {Boolean} [options.notificationIdNull=false] When true, version 2 requests will set id to null instead of omitting it\n *  @param {Function} [options.generator] Function to use for generating request IDs\n *  @return {Client}\n */\nconst Client = function(server, options) {\n  if(arguments.length === 1 && isPlainObject(server)) {\n    options = server;\n    server = null;\n  }\n\n  if(!(this instanceof Client)) {\n    return new Client(server, options);\n  }\n\n  const defaults = {\n    reviver: null,\n    replacer: null,\n    generator: utils.generateId,\n    version: 2,\n    notificationIdNull: false,\n  };\n\n  this.options = utils.merge(defaults, options || {});\n\n  if(server) {\n    this.server = server;\n  }\n};\nrequire('util').inherits(Client, events.EventEmitter);\n\nmodule.exports = Client;\n\n/**\n * HTTP client constructor\n * @type ClientHttp\n * @static\n */\nClient.http = require('./http');\n\n/**\n * HTTPS client constructor\n * @type ClientHttps\n * @static\n */\nClient.https = require('./https');\n\n/**\n * TCP client constructor\n * @type ClientTcp\n * @static\n */\nClient.tcp = require('./tcp');\n\n/**\n * TLS client constructor\n * @type ClientTls\n * @static\n */\nClient.tls = require('./tls');\n\n/**\n * Browser client constructor\n * @type ClientBrowser\n * @static\n */\nClient.browser = require('./browser');\n\n/**\n * Websocket client constructor\n * @type ClientWebsocket\n * @static\n */\nClient.websocket = require('./websocket');\n\n/**\n *  Creates a request and dispatches it if given a callback.\n *  @param {String|Array} method A batch request if passed an Array, or a method name if passed a String\n *  @param {Array|Object} params Parameters for the method\n *  @param {String|Number} [id] Optional id. If undefined an id will be generated. If null it creates a notification request\n *  @param {Function} [callback] Request callback. If specified, executes the request rather than only returning it.\n *  @throws {TypeError} Invalid parameters\n *  @return {Object} JSON-RPC 1.0 or 2.0 compatible request\n */\nClient.prototype.request = function(method, params, id, callback) {\n  const self = this;\n  let request = null;\n\n  // is this a batch request?\n  const isBatch = Array.isArray(method) && typeof(params) === 'function';\n\n  if (this.options.version === 1 && isBatch) {\n    throw new TypeError('JSON-RPC 1.0 does not support batching');\n  }\n\n  // is this a raw request?\n  const isRaw = !isBatch && method && typeof(method) === 'object' && typeof(params) === 'function';\n\n  if(isBatch || isRaw) {\n    callback = params;\n    request = method;\n  } else {\n    if(typeof(id) === 'function') {\n      callback = id;\n      // specifically undefined because \"null\" is a notification request\n      id = undefined;\n    }\n\n    const hasCallback = typeof(callback) === 'function';\n\n    try {\n      request = utils.request(method, params, id, {\n        generator: this.options.generator,\n        version: this.options.version,\n        notificationIdNull: this.options.notificationIdNull,\n      });\n    } catch(err) {\n      if(hasCallback) {\n        callback(err);\n        return;\n      }\n      throw err;\n    }\n\n    // no callback means we should just return a raw request before sending\n    if(!hasCallback) {\n      return request;\n    }\n\n  }\n\n  this.emit('request', request);\n\n  this._request(request, function(err, response) {\n    self.emit('response', request, response);\n    self._parseResponse(err, response, callback);\n  });\n\n  // always return the raw request\n  return request;\n};\n\n/**\n *  Executes a request on a directly bound server\n *  @param {Object} request A JSON-RPC 1.0 or 2.0 request\n *  @param {Function} callback Request callback that will receive the server response as the second argument\n *  @private\n */\nClient.prototype._request = function(request, callback) {\n  const self = this;\n\n  // serializes the request as a JSON string so that we get a copy and can run the replacer as intended\n  utils.JSON.stringify(request, this.options, function(err, message) {\n    if(err) {\n      callback(err);\n      return;\n    }\n\n    self.server.call(message, function(error, success) {\n      const response = error || success;\n      callback(null, response);\n    });\n\n  });\n\n};\n\n/**\n * Parses a response from a server, taking care of sugaring\n * @param {Object} err Error to pass on that is unrelated to the actual response\n * @param {Object} response JSON-RPC 1.0 or 2.0 response\n * @param {Function} callback Callback that will receive different arguments depending on the amount of parameters\n * @private\n */\nClient.prototype._parseResponse = function(err, response, callback) {\n  if(err) {\n    return callback(err);\n  }\n\n  if(!response || typeof(response) !== 'object') {\n    return callback();\n  }\n\n  if(callback.length === 3) {\n    // if callback length is 3, we split callback arguments on error and response\n\n    // is batch response?\n    if(Array.isArray(response)) {\n\n      // neccesary to split strictly on validity according to spec here\n      const isError = function(res) { return typeof(res.error) !== 'undefined'; };\n      const isNotError = function(res) { return !isError(res); };\n\n      return callback(null, response.filter(isError), response.filter(isNotError));\n    \n    } else {\n\n      // split regardless of validity\n      return callback(null, response.error, response.result);\n    \n    }\n  \n  }\n\n  return callback(null, response);\n\n};\n"]},"metadata":{},"sourceType":"script"}