{"ast":null,"code":"import { fetchTokens } from \"@airswap/metadata\";\nimport { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nimport { fetchSupportedTokens } from \"../registry/registrySlice\";\nimport { setWalletConnected, setWalletDisconnected } from \"../wallet/walletSlice\";\nimport { getActiveTokensFromLocalStorage, getUnknownTokens } from \"./metadataApi\";\nconst initialState = {\n  tokens: {\n    all: {},\n    active: []\n  }\n};\nexport const fetchAllTokens = createAsyncThunk(\"metadata/fetchTokens\", async (_, thunkApi) => {\n  const {\n    wallet\n  } = thunkApi.getState();\n  if (!wallet.connected) return [];\n  return (await fetchTokens(wallet.chainId)).tokens;\n});\nexport const fetchUnkownTokens = createAsyncThunk(\"metadata/fetchUnknownTokens\", async ({\n  provider\n}, thunkApi) => {\n  const {\n    registry,\n    metadata,\n    wallet\n  } = thunkApi.getState();\n  if (wallet.chainId === null) return [];\n  return await getUnknownTokens(wallet.chainId, registry.allSupportedTokens, Object.values(metadata.tokens.all), provider);\n});\nexport const metadataSlice = createSlice({\n  name: \"metadata\",\n  initialState,\n  reducers: {\n    addActiveToken: (state, action) => {\n      const lowerCasedToken = action.payload.trim().toLowerCase();\n\n      if (!state.tokens.active.includes(lowerCasedToken)) {\n        state.tokens.active.push(lowerCasedToken);\n      }\n    },\n    removeActiveToken: (state, action) => {\n      if (state.tokens.active.includes(action.payload)) {\n        state.tokens.active = state.tokens.active.filter(tokenAddress => tokenAddress !== action.payload);\n      }\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchAllTokens.pending, state => {// TODO: consider whether we need to put a pending state to prevent dupes\n    }).addCase(fetchAllTokens.fulfilled, (state, action) => {\n      const {\n        payload: tokenInfo\n      } = action;\n      state.tokens.all = tokenInfo.reduce((allTokens, token) => {\n        const {\n          address\n        } = token;\n\n        if (!allTokens[address]) {\n          allTokens[address] = { ...token\n          };\n        }\n\n        return allTokens;\n      }, {});\n    }).addCase(fetchAllTokens.rejected, state => {// TODO: handle failure?\n      // perhaps rejected state can be for when errors.length === known.length ?\n    }).addCase(fetchSupportedTokens.fulfilled, (state, action) => {\n      var _state$tokens$active;\n\n      if (!((_state$tokens$active = state.tokens.active) === null || _state$tokens$active === void 0 ? void 0 : _state$tokens$active.length)) state.tokens.active = action.payload.activeTokens || [];\n    }).addCase(fetchUnkownTokens.fulfilled, (state, action) => {\n      action.payload.forEach(token => {\n        state.tokens.all[token.address] = token;\n      });\n    }).addCase(setWalletConnected, (state, action) => {\n      const {\n        chainId,\n        address\n      } = action.payload;\n      state.tokens.active = getActiveTokensFromLocalStorage(address, chainId) || [];\n    }).addCase(setWalletDisconnected, state => {\n      state.tokens.active = [];\n    });\n  }\n});\nexport const {\n  addActiveToken,\n  removeActiveToken\n} = metadataSlice.actions;\n\nconst selectActiveTokenAddresses = state => state.metadata.tokens.active;\n\nexport const selectAllTokenInfo = state => Object.values(state.metadata.tokens.all);\nexport const selectActiveTokens = createSelector([selectActiveTokenAddresses, selectAllTokenInfo], (activeTokenAddresses, allTokenInfo) => {\n  return Object.values(allTokenInfo).filter(tokenInfo => activeTokenAddresses.includes(tokenInfo.address));\n});\nexport default metadataSlice.reducer;","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/src/features/metadata/metadataSlice.ts"],"names":["fetchTokens","createAsyncThunk","createSelector","createSlice","fetchSupportedTokens","setWalletConnected","setWalletDisconnected","getActiveTokensFromLocalStorage","getUnknownTokens","initialState","tokens","all","active","fetchAllTokens","_","thunkApi","wallet","getState","connected","chainId","fetchUnkownTokens","provider","registry","metadata","allSupportedTokens","Object","values","metadataSlice","name","reducers","addActiveToken","state","action","lowerCasedToken","payload","trim","toLowerCase","includes","push","removeActiveToken","filter","tokenAddress","extraReducers","builder","addCase","pending","fulfilled","tokenInfo","reduce","allTokens","token","address","rejected","length","activeTokens","forEach","actions","selectActiveTokenAddresses","selectAllTokenInfo","selectActiveTokens","activeTokenAddresses","allTokenInfo","reducer"],"mappings":"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","sourcesContent":["import { fetchTokens } from \"@airswap/metadata\";\nimport { TokenInfo } from \"@airswap/types\";\nimport {\n  createAsyncThunk,\n  createSelector,\n  createSlice,\n  PayloadAction,\n} from \"@reduxjs/toolkit\";\n\nimport { providers } from \"ethers\";\n\nimport { AppDispatch, RootState } from \"../../app/store\";\nimport { fetchSupportedTokens } from \"../registry/registrySlice\";\nimport {\n  setWalletConnected,\n  setWalletDisconnected,\n} from \"../wallet/walletSlice\";\nimport {\n  getActiveTokensFromLocalStorage,\n  getUnknownTokens,\n} from \"./metadataApi\";\n\nexport interface MetadataState {\n  tokens: {\n    all: {\n      [address: string]: TokenInfo;\n    };\n    active: string[];\n  };\n}\n\nconst initialState: MetadataState = {\n  tokens: {\n    all: {},\n    active: [],\n  },\n};\n\nexport const fetchAllTokens = createAsyncThunk<\n  TokenInfo[], // Return type\n  void, // First argument\n  {\n    // thunkApi\n    dispatch: AppDispatch;\n    state: RootState;\n  }\n>(\"metadata/fetchTokens\", async (_, thunkApi) => {\n  const { wallet } = thunkApi.getState();\n  if (!wallet.connected) return [];\n  return (await fetchTokens(wallet.chainId!)).tokens;\n});\n\nexport const fetchUnkownTokens = createAsyncThunk<\n  TokenInfo[], // Return type\n  {\n    // First argument\n    provider: providers.Provider;\n  },\n  {\n    // thunkApi\n    dispatch: AppDispatch;\n    state: RootState;\n  }\n>(\"metadata/fetchUnknownTokens\", async ({ provider }, thunkApi) => {\n  const { registry, metadata, wallet } = thunkApi.getState();\n  if (wallet.chainId === null) return [];\n  return await getUnknownTokens(\n    wallet.chainId,\n    registry.allSupportedTokens,\n    Object.values(metadata.tokens.all),\n    provider\n  );\n});\n\nexport const metadataSlice = createSlice({\n  name: \"metadata\",\n  initialState,\n  reducers: {\n    addActiveToken: (state, action: PayloadAction<string>) => {\n      const lowerCasedToken = action.payload.trim().toLowerCase();\n      if (!state.tokens.active.includes(lowerCasedToken)) {\n        state.tokens.active.push(lowerCasedToken);\n      }\n    },\n    removeActiveToken: (state, action: PayloadAction<string>) => {\n      if (state.tokens.active.includes(action.payload)) {\n        state.tokens.active = state.tokens.active.filter(\n          (tokenAddress) => tokenAddress !== action.payload\n        );\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchAllTokens.pending, (state) => {\n        // TODO: consider whether we need to put a pending state to prevent dupes\n      })\n      .addCase(fetchAllTokens.fulfilled, (state, action) => {\n        const { payload: tokenInfo } = action;\n        state.tokens.all = tokenInfo.reduce(\n          (allTokens: { [address: string]: TokenInfo }, token) => {\n            const { address } = token;\n            if (!allTokens[address]) {\n              allTokens[address] = { ...token };\n            }\n            return allTokens;\n          },\n          {}\n        );\n      })\n      .addCase(fetchAllTokens.rejected, (state) => {\n        // TODO: handle failure?\n        // perhaps rejected state can be for when errors.length === known.length ?\n      })\n      .addCase(fetchSupportedTokens.fulfilled, (state, action) => {\n        if (!state.tokens.active?.length)\n          state.tokens.active = action.payload.activeTokens || [];\n      })\n      .addCase(fetchUnkownTokens.fulfilled, (state, action) => {\n        action.payload.forEach((token) => {\n          state.tokens.all[token.address] = token;\n        });\n      })\n      .addCase(setWalletConnected, (state, action) => {\n        const { chainId, address } = action.payload;\n        state.tokens.active =\n          getActiveTokensFromLocalStorage(address, chainId) || [];\n      })\n      .addCase(setWalletDisconnected, (state) => {\n        state.tokens.active = [];\n      });\n  },\n});\n\nexport const { addActiveToken, removeActiveToken } = metadataSlice.actions;\n\nconst selectActiveTokenAddresses = (state: RootState) =>\n  state.metadata.tokens.active;\nexport const selectAllTokenInfo = (state: RootState) =>\n  Object.values(state.metadata.tokens.all);\nexport const selectActiveTokens = createSelector(\n  [selectActiveTokenAddresses, selectAllTokenInfo],\n  (activeTokenAddresses, allTokenInfo) => {\n    return Object.values(allTokenInfo).filter((tokenInfo) =>\n      activeTokenAddresses.includes(tokenInfo.address)\n    );\n  }\n);\n\nexport default metadataSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}