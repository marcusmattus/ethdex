{"ast":null,"code":"import * as WETHContract from \"@airswap/balances/build/contracts/WETH9.json\";\nimport { wethAddresses } from \"@airswap/constants\";\nimport { Light, Wrapper } from \"@airswap/libraries\";\nimport { toAtomicString } from \"@airswap/utils\";\nimport erc20Abi from \"erc-20-abi\";\nimport { BigNumber, constants, Contract, ethers, utils } from \"ethers\";\nconst REQUEST_ORDER_TIMEOUT_MS = 5000;\nconst erc20Interface = new ethers.utils.Interface(erc20Abi);\nconst WETHInterface = new utils.Interface(JSON.stringify(WETHContract.abi));\n\nasync function swapLight(chainId, provider, order) {\n  // @ts-ignore TODO: type compatability issue with AirSwap lib\n  return await new Light(chainId, provider).swap(order, // @ts-ignore\n  provider.getSigner());\n}\n\nasync function swapWrapper(chainId, provider, order) {\n  // @ts-ignore TODO: type compatability issue with AirSwap lib\n  return await new Wrapper(chainId, provider).swap(order, // @ts-ignore\n  provider.getSigner());\n}\n\nexport async function requestOrders(servers, quoteToken, baseToken, baseTokenAmount, baseTokenDecimals, senderWallet) {\n  if (!servers.length) {\n    throw new Error(\"no counterparties\");\n  }\n\n  const rfqOrderPromises = servers.map(async server => {\n    const order = await Promise.race([server.getSignerSideOrder(toAtomicString(baseTokenAmount, baseTokenDecimals), quoteToken, baseToken, senderWallet), // Servers should respond in a timely manner for orders to be considered\n    new Promise((resolve, reject) => setTimeout(() => {\n      reject(\"ETIMEDOUT\");\n    }, REQUEST_ORDER_TIMEOUT_MS))]);\n    return order;\n  });\n  const rfqOrders = await Promise.allSettled(rfqOrderPromises);\n  return rfqOrders.filter(result => result.status === \"fulfilled\").map(result => result.value).filter(o => BigNumber.from(o.signerAmount).gt(\"0\"));\n}\nexport async function approveToken(baseToken, provider, contractType) {\n  const spender = contractType === \"Light\" ? Light.getAddress(provider.network.chainId) : Wrapper.getAddress(provider.network.chainId);\n  const erc20Contract = new ethers.Contract(baseToken, erc20Interface, // @ts-ignore\n  provider.getSigner());\n  const approvalTxHash = await erc20Contract.approve(spender, constants.MaxUint256);\n  return approvalTxHash;\n}\nexport async function takeOrder(order, provider, contractType) {\n  const tx = contractType === \"Light\" ? await swapLight(provider.network.chainId, provider, order) : await swapWrapper(provider.network.chainId, provider, order);\n  return tx;\n}\nexport function orderSortingFunction(a, b) {\n  // If tokens transferred are the same\n  if (a.signerAmount === b.signerAmount && a.senderAmount === b.senderAmount) {\n    return parseInt(b.expiry) - parseInt(a.expiry);\n  }\n\n  if (a.signerAmount === b.signerAmount) {\n    // Likely senderSide\n    // Sort orders by amount of senderToken sent (ascending).\n    const aAmount = BigNumber.from(a.senderAmount);\n    const bAmount = BigNumber.from(b.senderAmount);\n    if (bAmount.lt(aAmount)) return 1;else return -1;\n  } else {\n    // Likely signerSide\n    // Sort orders by amount of signerToken received (descending).\n    const aAmount = BigNumber.from(a.signerAmount);\n    const bAmount = BigNumber.from(b.signerAmount);\n    if (bAmount.gt(aAmount)) return 1;else return -1;\n  }\n}\nexport async function depositETH(chainId, senderAmount, senderTokenDecimals, provider) {\n  const WETHContract = new Contract(wethAddresses[chainId], WETHInterface, provider);\n  const signer = WETHContract.connect(provider.getSigner());\n  const tx = await signer.deposit({\n    value: toAtomicString(senderAmount, senderTokenDecimals)\n  });\n  return tx;\n}\nexport async function withdrawETH(chainId, senderAmount, senderTokenDecimals, provider) {\n  const WETHContract = new Contract(wethAddresses[chainId], WETHInterface, // @ts-ignore\n  provider); // @ts-ignore\n\n  const signer = WETHContract.connect(provider.getSigner());\n  const tx = await signer.withdraw(toAtomicString(senderAmount, senderTokenDecimals));\n  return tx;\n}","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/features/orders/orderApi.ts"],"names":["WETHContract","wethAddresses","Light","Wrapper","toAtomicString","erc20Abi","BigNumber","constants","Contract","ethers","utils","REQUEST_ORDER_TIMEOUT_MS","erc20Interface","Interface","WETHInterface","JSON","stringify","abi","swapLight","chainId","provider","order","swap","getSigner","swapWrapper","requestOrders","servers","quoteToken","baseToken","baseTokenAmount","baseTokenDecimals","senderWallet","length","Error","rfqOrderPromises","map","server","Promise","race","getSignerSideOrder","resolve","reject","setTimeout","rfqOrders","allSettled","filter","result","status","value","o","from","signerAmount","gt","approveToken","contractType","spender","getAddress","network","erc20Contract","approvalTxHash","approve","MaxUint256","takeOrder","tx","orderSortingFunction","a","b","senderAmount","parseInt","expiry","aAmount","bAmount","lt","depositETH","senderTokenDecimals","signer","connect","deposit","withdrawETH","withdraw"],"mappings":"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","sourcesContent":["import * as WETHContract from \"@airswap/balances/build/contracts/WETH9.json\";\nimport { wethAddresses } from \"@airswap/constants\";\nimport { Light, Server, Wrapper } from \"@airswap/libraries\";\nimport { LightOrder } from \"@airswap/types\";\nimport { toAtomicString } from \"@airswap/utils\";\n\nimport erc20Abi from \"erc-20-abi\";\nimport {\n  BigNumber,\n  constants,\n  Contract,\n  ethers,\n  providers,\n  Transaction,\n  utils,\n} from \"ethers\";\n\nconst REQUEST_ORDER_TIMEOUT_MS = 5000;\n\nconst erc20Interface = new ethers.utils.Interface(erc20Abi);\n\nconst WETHInterface = new utils.Interface(JSON.stringify(WETHContract.abi));\n\nasync function swapLight(\n  chainId: number,\n  provider: ethers.providers.Web3Provider,\n  order: LightOrder\n) {\n  // @ts-ignore TODO: type compatability issue with AirSwap lib\n  return await new Light(chainId, provider).swap(\n    order,\n    // @ts-ignore\n    provider.getSigner()\n  );\n}\n\nasync function swapWrapper(\n  chainId: number,\n  provider: ethers.providers.Web3Provider,\n  order: LightOrder\n) {\n  // @ts-ignore TODO: type compatability issue with AirSwap lib\n  return await new Wrapper(chainId, provider).swap(\n    order,\n    // @ts-ignore\n    provider.getSigner()\n  );\n}\n\nexport async function requestOrders(\n  servers: Server[],\n  quoteToken: string,\n  baseToken: string,\n  baseTokenAmount: string,\n  baseTokenDecimals: number,\n  senderWallet: string\n): Promise<LightOrder[]> {\n  if (!servers.length) {\n    throw new Error(\"no counterparties\");\n  }\n  const rfqOrderPromises = servers.map(async (server) => {\n    const order = await Promise.race([\n      server.getSignerSideOrder(\n        toAtomicString(baseTokenAmount, baseTokenDecimals),\n        quoteToken,\n        baseToken,\n        senderWallet\n      ),\n      // Servers should respond in a timely manner for orders to be considered\n      new Promise((resolve, reject) =>\n        setTimeout(() => {\n          reject(\"ETIMEDOUT\");\n        }, REQUEST_ORDER_TIMEOUT_MS)\n      ),\n    ]);\n    return (order as any) as LightOrder;\n  });\n  const rfqOrders = await Promise.allSettled(rfqOrderPromises);\n  return rfqOrders\n    .filter((result) => result.status === \"fulfilled\")\n    .map((result) => (result as PromiseFulfilledResult<LightOrder>).value)\n    .filter((o) => BigNumber.from(o.signerAmount).gt(\"0\"));\n}\n\nexport async function approveToken(\n  baseToken: string,\n  provider: ethers.providers.Web3Provider,\n  contractType: \"Light\" | \"Wrapper\"\n) {\n  const spender =\n    contractType === \"Light\"\n      ? Light.getAddress(provider.network.chainId)\n      : Wrapper.getAddress(provider.network.chainId);\n  const erc20Contract = new ethers.Contract(\n    baseToken,\n    erc20Interface,\n    // @ts-ignore\n    provider.getSigner()\n  );\n  const approvalTxHash = await erc20Contract.approve(\n    spender,\n    constants.MaxUint256\n  );\n  return (approvalTxHash as any) as Transaction;\n}\n\nexport async function takeOrder(\n  order: LightOrder,\n  provider: ethers.providers.Web3Provider,\n  contractType: \"Light\" | \"Wrapper\"\n) {\n  const tx =\n    contractType === \"Light\"\n      ? await swapLight(provider.network.chainId, provider, order)\n      : await swapWrapper(provider.network.chainId, provider, order);\n\n  return (tx as any) as Transaction;\n}\n\nexport function orderSortingFunction(a: LightOrder, b: LightOrder) {\n  // If tokens transferred are the same\n  if (a.signerAmount === b.signerAmount && a.senderAmount === b.senderAmount) {\n    return parseInt(b.expiry) - parseInt(a.expiry);\n  }\n  if (a.signerAmount === b.signerAmount) {\n    // Likely senderSide\n    // Sort orders by amount of senderToken sent (ascending).\n    const aAmount = BigNumber.from(a.senderAmount);\n    const bAmount = BigNumber.from(b.senderAmount);\n    if (bAmount.lt(aAmount)) return 1;\n    else return -1;\n  } else {\n    // Likely signerSide\n    // Sort orders by amount of signerToken received (descending).\n    const aAmount = BigNumber.from(a.signerAmount);\n    const bAmount = BigNumber.from(b.signerAmount);\n    if (bAmount.gt(aAmount)) return 1;\n    else return -1;\n  }\n}\n\nexport async function depositETH(\n  chainId: number,\n  senderAmount: string,\n  senderTokenDecimals: number,\n  provider: ethers.providers.Web3Provider\n) {\n  const WETHContract = new Contract(\n    wethAddresses[chainId],\n    WETHInterface,\n    provider as providers.Provider\n  );\n  const signer = WETHContract.connect(provider.getSigner() as ethers.Signer);\n  const tx = await signer.deposit({\n    value: toAtomicString(senderAmount, senderTokenDecimals),\n  });\n  return (tx as any) as Transaction;\n}\n\nexport async function withdrawETH(\n  chainId: number,\n  senderAmount: string,\n  senderTokenDecimals: number,\n  provider: ethers.providers.Web3Provider\n) {\n  const WETHContract = new Contract(\n    wethAddresses[chainId],\n    WETHInterface,\n    // @ts-ignore\n    provider\n  );\n  // @ts-ignore\n  const signer = WETHContract.connect(provider.getSigner());\n  const tx = await signer.withdraw(\n    toAtomicString(senderAmount, senderTokenDecimals)\n  );\n  return (tx as any) as Transaction;\n}\n"]},"metadata":{},"sourceType":"module"}