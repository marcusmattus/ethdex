{"ast":null,"code":"import { wethAddresses } from \"@airswap/constants\";\nimport { toAtomicString } from \"@airswap/utils\";\nimport { createAsyncThunk, createSelector, createSlice } from \"@reduxjs/toolkit\";\nimport BigNumber from \"bignumber.js\";\nimport { notifyTransaction } from \"../../components/Toasts/ToastController\";\nimport { RFQ_EXPIRY_BUFFER_MS } from \"../../constants/configParams\";\nimport nativeETH from \"../../constants/nativeETH\";\nimport { allowancesLightActions, allowancesWrapperActions } from \"../balances/balancesSlice\";\nimport { gasUsedPerSwap } from \"../gasCost/gasCostApi\";\nimport { selectGasPriceInQuoteTokens } from \"../gasCost/gasCostSlice\";\nimport { selectBestPricing } from \"../pricing/pricingSlice\";\nimport { clearTradeTerms, selectTradeTerms } from \"../tradeTerms/tradeTermsSlice\";\nimport { declineTransaction, mineTransaction, revertTransaction, submitTransaction } from \"../transactions/transactionActions\";\nimport { submitTransactionWithExpiry } from \"../transactions/transactionsSlice\";\nimport { setWalletConnected, setWalletDisconnected } from \"../wallet/walletSlice\";\nimport { approveToken, depositETH, orderSortingFunction, requestOrders, takeOrder, withdrawETH } from \"./orderApi\";\nconst initialState = {\n  orders: [],\n  status: \"idle\",\n  reRequestTimerId: null\n};\nconst APPROVE_AMOUNT = \"90071992547409910000000000\"; // replaces WETH to ETH on Wrapper orders\n\nconst refactorOrder = (order, chainId) => {\n  let newOrder = { ...order\n  };\n\n  if (order.senderToken === wethAddresses[chainId]) {\n    newOrder.senderToken = nativeETH[chainId].address;\n  } else if (order.signerToken === wethAddresses[chainId]) {\n    newOrder.signerToken = nativeETH[chainId].address;\n  }\n\n  return newOrder;\n};\n\nexport const deposit = createAsyncThunk(\"orders/deposit\", async (params, {\n  getState,\n  dispatch\n}) => {\n  let tx;\n\n  try {\n    tx = await depositETH(params.chainId, params.senderAmount, params.senderTokenDecimals, params.provider);\n\n    if (tx.hash) {\n      const senderAmount = toAtomicString(params.senderAmount, params.senderTokenDecimals); // Since this is a Deposit, senderAmount === signerAmount\n\n      const transaction = {\n        type: \"Deposit\",\n        order: {\n          signerToken: wethAddresses[params.chainId],\n          signerAmount: senderAmount,\n          senderToken: nativeETH[params.chainId].address,\n          senderAmount: senderAmount\n        },\n        hash: tx.hash,\n        status: \"processing\",\n        timestamp: Date.now()\n      };\n      dispatch(submitTransaction(transaction));\n      params.provider.once(tx.hash, async () => {\n        const receipt = await params.provider.getTransactionReceipt(tx.hash);\n        const state = getState();\n        const tokens = Object.values(state.metadata.tokens.all);\n\n        if (receipt.status === 1) {\n          dispatch(mineTransaction({\n            hash: receipt.transactionHash\n          }));\n          notifyTransaction(\"Deposit\", transaction, tokens, false, params.chainId);\n        } else {\n          dispatch(revertTransaction({\n            hash: receipt.transactionHash,\n            reason: \"Transaction reverted\"\n          }));\n          notifyTransaction(\"Deposit\", transaction, tokens, true, params.chainId);\n        }\n      });\n    }\n  } catch (e) {\n    console.error(e);\n    dispatch(declineTransaction(e.message));\n    throw e;\n  }\n});\nexport const resetOrders = createAsyncThunk(\"orders/reset\", async (params, {\n  getState,\n  dispatch\n}) => {\n  await dispatch(setResetStatus());\n  dispatch(clear());\n  dispatch(clearTradeTerms());\n});\nexport const withdraw = createAsyncThunk(\"orders/withdraw\", async (params, {\n  getState,\n  dispatch\n}) => {\n  let tx;\n\n  try {\n    tx = await withdrawETH(params.chainId, params.senderAmount, params.senderTokenDecimals, params.provider);\n\n    if (tx.hash) {\n      const transaction = {\n        type: \"Withdraw\",\n        order: {\n          signerToken: nativeETH[params.chainId].address,\n          signerAmount: toAtomicString(params.senderAmount, params.senderTokenDecimals),\n          senderToken: wethAddresses[params.chainId],\n          senderAmount: toAtomicString(params.senderAmount, params.senderTokenDecimals)\n        },\n        hash: tx.hash,\n        status: \"processing\",\n        timestamp: Date.now()\n      };\n      dispatch(submitTransaction(transaction));\n      params.provider.once(tx.hash, async () => {\n        const receipt = await params.provider.getTransactionReceipt(tx.hash);\n        const state = getState();\n        const tokens = Object.values(state.metadata.tokens.all);\n\n        if (receipt.status === 1) {\n          dispatch(mineTransaction({\n            hash: receipt.transactionHash\n          }));\n          notifyTransaction(\"Withdraw\", transaction, tokens, false, params.chainId);\n        } else {\n          dispatch(revertTransaction(receipt.transactionHash));\n          notifyTransaction(\"Withdraw\", transaction, tokens, true, params.chainId);\n        }\n      });\n    }\n  } catch (e) {\n    console.error(e);\n    dispatch(declineTransaction(e.message));\n    throw e;\n  }\n});\nexport const request = createAsyncThunk(\"orders/request\", async (params, {\n  dispatch\n}) => {\n  const orders = await requestOrders(params.servers, params.signerToken, params.senderToken, params.senderAmount, params.senderTokenDecimals, params.senderWallet);\n\n  if (orders.length) {\n    const bestOrder = [...orders].sort(orderSortingFunction)[0];\n    const expiry = parseInt(bestOrder.expiry) * 1000;\n    const timeTilReRequest = expiry - Date.now() - RFQ_EXPIRY_BUFFER_MS;\n    const reRequestTimerId = window.setTimeout(() => dispatch(request(params)), timeTilReRequest);\n    dispatch(setReRequestTimerId(reRequestTimerId));\n  }\n\n  return orders;\n});\nexport const approve = createAsyncThunk(\"orders/approve\", async (params, {\n  getState,\n  dispatch\n}) => {\n  let tx;\n\n  try {\n    tx = await approveToken(params.token, params.library, params.contractType);\n\n    if (tx.hash) {\n      const transaction = {\n        type: \"Approval\",\n        hash: tx.hash,\n        status: \"processing\",\n        tokenAddress: params.token,\n        timestamp: Date.now()\n      };\n      dispatch(submitTransaction(transaction));\n      params.library.once(tx.hash, async () => {\n        const receipt = await params.library.getTransactionReceipt(tx.hash);\n        const state = getState();\n        const tokens = Object.values(state.metadata.tokens.all);\n\n        if (receipt.status === 1) {\n          dispatch(mineTransaction({\n            hash: receipt.transactionHash\n          })); // Optimistically update allowance (this is not really optimistic,\n          // but it preempts receiving the event)\n\n          if (params.contractType === \"Light\") {\n            dispatch(allowancesLightActions.set({\n              tokenAddress: params.token,\n              amount: APPROVE_AMOUNT\n            }));\n          } else if (params.contractType === \"Wrapper\") {\n            dispatch(allowancesWrapperActions.set({\n              tokenAddress: params.token,\n              amount: APPROVE_AMOUNT\n            }));\n          }\n\n          notifyTransaction(\"Approval\", transaction, tokens, false, params.chainId);\n        } else {\n          dispatch(revertTransaction(receipt.transactionHash));\n          notifyTransaction(\"Approval\", transaction, tokens, true, params.chainId);\n        }\n      });\n    }\n  } catch (e) {\n    console.error(e);\n    dispatch(declineTransaction(e.message));\n    throw e;\n  }\n});\nexport const take = createAsyncThunk(\"orders/take\", async (params, {\n  getState,\n  dispatch\n}) => {\n  let tx;\n\n  try {\n    tx = await takeOrder(params.order, params.library, params.contractType); // When dealing with the Wrapper, since the \"actual\" swap is ETH <-> ERC20,\n    // we should change the order tokens to WETH -> ETH\n\n    let newOrder = params.contractType === \"Light\" ? params.order : refactorOrder(params.order, params.library._network.chainId);\n\n    if (tx.hash) {\n      const transaction = {\n        type: \"Order\",\n        order: newOrder,\n        protocol: \"request-for-quote\",\n        hash: tx.hash,\n        status: \"processing\",\n        timestamp: Date.now(),\n        nonce: params.order.nonce,\n        expiry: params.order.expiry\n      };\n      dispatch(submitTransactionWithExpiry({\n        transaction,\n        signerWallet: params.order.signerWallet,\n        onExpired: params.onExpired\n      }));\n    }\n  } catch (e) {\n    dispatch(declineTransaction(e.message));\n    throw e;\n  }\n});\nexport const ordersSlice = createSlice({\n  name: \"orders\",\n  initialState,\n  reducers: {\n    setResetStatus: state => {\n      state.status = \"reset\";\n    },\n    clear: state => {\n      state.orders = [];\n      state.status = \"idle\";\n\n      if (state.reRequestTimerId) {\n        clearTimeout(state.reRequestTimerId);\n        state.reRequestTimerId = null;\n      }\n    },\n    setReRequestTimerId: (state, action) => {\n      state.reRequestTimerId = action.payload;\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(request.pending, state => {\n      state.status = \"requesting\";\n    }).addCase(request.fulfilled, (state, action) => {\n      state.status = \"idle\";\n      state.orders = action.payload;\n    }).addCase(request.rejected, (state, action) => {\n      state.status = \"failed\";\n      state.orders = [];\n    }).addCase(take.pending, state => {\n      state.status = \"taking\";\n    }).addCase(take.fulfilled, (state, action) => {\n      state.status = \"idle\";\n    }).addCase(take.rejected, (state, action) => {\n      state.status = \"failed\";\n    }).addCase(approve.pending, state => {\n      state.status = \"approving\";\n    }).addCase(approve.fulfilled, state => {\n      state.status = \"idle\";\n    }).addCase(approve.rejected, state => {\n      state.status = \"failed\";\n    }).addCase(setWalletConnected, state => {\n      state.status = \"idle\";\n      state.orders = [];\n    }).addCase(setWalletDisconnected, state => {\n      state.status = \"idle\";\n      state.orders = [];\n    });\n  }\n});\nexport const {\n  clear,\n  setResetStatus,\n  setReRequestTimerId\n} = ordersSlice.actions;\n/**\n * Sorts orders and returns the best order based on tokens received or sent\n * then falling back to expiry.\n */\n\nexport const selectBestOrder = state => // Note that `.sort` mutates the array, so we need to clone it first to\n// prevent mutating state.\n[...state.orders.orders].sort(orderSortingFunction)[0];\nexport const selectSortedOrders = state => [...state.orders.orders].sort(orderSortingFunction);\nexport const selectFirstOrder = state => state.orders.orders[0];\nexport const selectBestOption = createSelector(selectTradeTerms, selectBestOrder, selectBestPricing, selectGasPriceInQuoteTokens, (terms, bestRfqOrder, bestPricing, gasPriceInQuoteTokens) => {\n  if (!terms) return null;\n\n  if (terms.side === \"buy\") {\n    console.error(`Buy orders not implemented yet`);\n    return null;\n  }\n\n  let pricing = bestPricing;\n  if (!bestRfqOrder && !pricing) return null;\n  let lastLookOrder;\n\n  if (pricing) {\n    lastLookOrder = {\n      quoteAmount: pricing.quoteAmount,\n      protocol: \"last-look\",\n      pricing: pricing\n    };\n    if (!bestRfqOrder) return lastLookOrder;\n  }\n\n  let rfqOrder;\n  let bestRFQQuoteTokens;\n\n  if (bestRfqOrder) {\n    bestRFQQuoteTokens = new BigNumber(bestRfqOrder.signerAmount).div(new BigNumber(10).pow(terms.quoteToken.decimals));\n    rfqOrder = {\n      quoteAmount: bestRFQQuoteTokens.toString(),\n      protocol: \"request-for-quote\",\n      order: bestRfqOrder\n    };\n    if (!lastLookOrder) return rfqOrder;\n  }\n\n  if (pricing && bestRFQQuoteTokens.minus((gasPriceInQuoteTokens === null || gasPriceInQuoteTokens === void 0 ? void 0 : gasPriceInQuoteTokens.multipliedBy(gasUsedPerSwap)) || 0).lte(new BigNumber(pricing.quoteAmount))) {\n    return lastLookOrder;\n  } else {\n    return rfqOrder;\n  }\n});\nexport const selectOrdersStatus = state => state.orders.status;\nexport default ordersSlice.reducer;","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/src/features/orders/ordersSlice.ts"],"names":["wethAddresses","toAtomicString","createAsyncThunk","createSelector","createSlice","BigNumber","notifyTransaction","RFQ_EXPIRY_BUFFER_MS","nativeETH","allowancesLightActions","allowancesWrapperActions","gasUsedPerSwap","selectGasPriceInQuoteTokens","selectBestPricing","clearTradeTerms","selectTradeTerms","declineTransaction","mineTransaction","revertTransaction","submitTransaction","submitTransactionWithExpiry","setWalletConnected","setWalletDisconnected","approveToken","depositETH","orderSortingFunction","requestOrders","takeOrder","withdrawETH","initialState","orders","status","reRequestTimerId","APPROVE_AMOUNT","refactorOrder","order","chainId","newOrder","senderToken","address","signerToken","deposit","params","getState","dispatch","tx","senderAmount","senderTokenDecimals","provider","hash","transaction","type","signerAmount","timestamp","Date","now","once","receipt","getTransactionReceipt","state","tokens","Object","values","metadata","all","transactionHash","reason","e","console","error","message","resetOrders","setResetStatus","clear","withdraw","request","servers","senderWallet","length","bestOrder","sort","expiry","parseInt","timeTilReRequest","window","setTimeout","setReRequestTimerId","approve","token","library","contractType","tokenAddress","set","amount","take","_network","protocol","nonce","signerWallet","onExpired","ordersSlice","name","reducers","clearTimeout","action","payload","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","selectBestOrder","selectSortedOrders","selectFirstOrder","selectBestOption","terms","bestRfqOrder","bestPricing","gasPriceInQuoteTokens","side","pricing","lastLookOrder","quoteAmount","rfqOrder","bestRFQQuoteTokens","div","pow","quoteToken","decimals","toString","minus","multipliedBy","lte","selectOrdersStatus","reducer"],"mappings":"AAAA,SAASA,aAAT,QAA8B,oBAA9B;AAGA,SAASC,cAAT,QAA+B,gBAA/B;AACA,SACEC,gBADF,EAEEC,cAFF,EAGEC,WAHF,QAKO,kBALP;AAOA,OAAOC,SAAP,MAAsB,cAAtB;AAIA,SAASC,iBAAT,QAAkC,yCAAlC;AACA,SAASC,oBAAT,QAAqC,8BAArC;AACA,OAAOC,SAAP,MAAsB,2BAAtB;AACA,SACEC,sBADF,EAEEC,wBAFF,QAGO,2BAHP;AAIA,SAASC,cAAT,QAA+B,uBAA/B;AACA,SAASC,2BAAT,QAA4C,yBAA5C;AACA,SAASC,iBAAT,QAAkC,yBAAlC;AACA,SACEC,eADF,EAEEC,gBAFF,QAGO,+BAHP;AAIA,SACEC,kBADF,EAEEC,eAFF,EAGEC,iBAHF,EAIEC,iBAJF,QAKO,oCALP;AAMA,SAKEC,2BALF,QAMO,mCANP;AAOA,SACEC,kBADF,EAEEC,qBAFF,QAGO,uBAHP;AAIA,SACEC,YADF,EAEEC,UAFF,EAGEC,oBAHF,EAIEC,aAJF,EAKEC,SALF,EAMEC,WANF,QAOO,YAPP;AAeA,MAAMC,YAAyB,GAAG;AAChCC,EAAAA,MAAM,EAAE,EADwB;AAEhCC,EAAAA,MAAM,EAAE,MAFwB;AAGhCC,EAAAA,gBAAgB,EAAE;AAHc,CAAlC;AAMA,MAAMC,cAAc,GAAG,4BAAvB,C,CAEA;;AACA,MAAMC,aAAa,GAAG,CAACC,KAAD,EAAoBC,OAApB,KAAwC;AAC5D,MAAIC,QAAQ,GAAG,EAAE,GAAGF;AAAL,GAAf;;AACA,MAAIA,KAAK,CAACG,WAAN,KAAsBtC,aAAa,CAACoC,OAAD,CAAvC,EAAkD;AAChDC,IAAAA,QAAQ,CAACC,WAAT,GAAuB9B,SAAS,CAAC4B,OAAD,CAAT,CAAmBG,OAA1C;AACD,GAFD,MAEO,IAAIJ,KAAK,CAACK,WAAN,KAAsBxC,aAAa,CAACoC,OAAD,CAAvC,EAAkD;AACvDC,IAAAA,QAAQ,CAACG,WAAT,GAAuBhC,SAAS,CAAC4B,OAAD,CAAT,CAAmBG,OAA1C;AACD;;AACD,SAAOF,QAAP;AACD,CARD;;AAUA,OAAO,MAAMI,OAAO,GAAGvC,gBAAgB,CACrC,gBADqC,EAErC,OACEwC,MADF,EAOE;AAAEC,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,CAPF,KAQK;AACH,MAAIC,EAAJ;;AACA,MAAI;AACFA,IAAAA,EAAE,GAAG,MAAMrB,UAAU,CACnBkB,MAAM,CAACN,OADY,EAEnBM,MAAM,CAACI,YAFY,EAGnBJ,MAAM,CAACK,mBAHY,EAInBL,MAAM,CAACM,QAJY,CAArB;;AAMA,QAAIH,EAAE,CAACI,IAAP,EAAa;AACX,YAAMH,YAAY,GAAG7C,cAAc,CACjCyC,MAAM,CAACI,YAD0B,EAEjCJ,MAAM,CAACK,mBAF0B,CAAnC,CADW,CAKX;;AACA,YAAMG,WAAkC,GAAG;AACzCC,QAAAA,IAAI,EAAE,SADmC;AAEzChB,QAAAA,KAAK,EAAE;AACLK,UAAAA,WAAW,EAAExC,aAAa,CAAC0C,MAAM,CAACN,OAAR,CADrB;AAELgB,UAAAA,YAAY,EAAEN,YAFT;AAGLR,UAAAA,WAAW,EAAE9B,SAAS,CAACkC,MAAM,CAACN,OAAR,CAAT,CAA0BG,OAHlC;AAILO,UAAAA,YAAY,EAAEA;AAJT,SAFkC;AAQzCG,QAAAA,IAAI,EAAEJ,EAAE,CAACI,IARgC;AASzClB,QAAAA,MAAM,EAAE,YATiC;AAUzCsB,QAAAA,SAAS,EAAEC,IAAI,CAACC,GAAL;AAV8B,OAA3C;AAYAX,MAAAA,QAAQ,CAACzB,iBAAiB,CAAC+B,WAAD,CAAlB,CAAR;AACAR,MAAAA,MAAM,CAACM,QAAP,CAAgBQ,IAAhB,CAAqBX,EAAE,CAACI,IAAxB,EAA8B,YAAY;AACxC,cAAMQ,OAAO,GAAG,MAAMf,MAAM,CAACM,QAAP,CAAgBU,qBAAhB,CAAsCb,EAAE,CAACI,IAAzC,CAAtB;AACA,cAAMU,KAAgB,GAAGhB,QAAQ,EAAjC;AACA,cAAMiB,MAAM,GAAGC,MAAM,CAACC,MAAP,CAAcH,KAAK,CAACI,QAAN,CAAeH,MAAf,CAAsBI,GAApC,CAAf;;AACA,YAAIP,OAAO,CAAC1B,MAAR,KAAmB,CAAvB,EAA0B;AACxBa,UAAAA,QAAQ,CACN3B,eAAe,CAAC;AACdgC,YAAAA,IAAI,EAAEQ,OAAO,CAACQ;AADA,WAAD,CADT,CAAR;AAKA3D,UAAAA,iBAAiB,CACf,SADe,EAEf4C,WAFe,EAGfU,MAHe,EAIf,KAJe,EAKflB,MAAM,CAACN,OALQ,CAAjB;AAOD,SAbD,MAaO;AACLQ,UAAAA,QAAQ,CACN1B,iBAAiB,CAAC;AAChB+B,YAAAA,IAAI,EAAEQ,OAAO,CAACQ,eADE;AAEhBC,YAAAA,MAAM,EAAE;AAFQ,WAAD,CADX,CAAR;AAMA5D,UAAAA,iBAAiB,CACf,SADe,EAEf4C,WAFe,EAGfU,MAHe,EAIf,IAJe,EAKflB,MAAM,CAACN,OALQ,CAAjB;AAOD;AACF,OAhCD;AAiCD;AACF,GA5DD,CA4DE,OAAO+B,CAAP,EAAe;AACfC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAvB,IAAAA,QAAQ,CAAC5B,kBAAkB,CAACmD,CAAC,CAACG,OAAH,CAAnB,CAAR;AACA,UAAMH,CAAN;AACD;AACF,CA7EoC,CAAhC;AAgFP,OAAO,MAAMI,WAAW,GAAGrE,gBAAgB,CACzC,cADyC,EAEzC,OAAOwC,MAAP,EAA0B;AAAEC,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,CAA1B,KAAqD;AACnD,QAAMA,QAAQ,CAAC4B,cAAc,EAAf,CAAd;AACA5B,EAAAA,QAAQ,CAAC6B,KAAK,EAAN,CAAR;AACA7B,EAAAA,QAAQ,CAAC9B,eAAe,EAAhB,CAAR;AACD,CANwC,CAApC;AASP,OAAO,MAAM4D,QAAQ,GAAGxE,gBAAgB,CACtC,iBADsC,EAEtC,OACEwC,MADF,EAOE;AAAEC,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,CAPF,KAQK;AACH,MAAIC,EAAJ;;AACA,MAAI;AACFA,IAAAA,EAAE,GAAG,MAAMjB,WAAW,CACpBc,MAAM,CAACN,OADa,EAEpBM,MAAM,CAACI,YAFa,EAGpBJ,MAAM,CAACK,mBAHa,EAIpBL,MAAM,CAACM,QAJa,CAAtB;;AAMA,QAAIH,EAAE,CAACI,IAAP,EAAa;AACX,YAAMC,WAAmC,GAAG;AAC1CC,QAAAA,IAAI,EAAE,UADoC;AAE1ChB,QAAAA,KAAK,EAAE;AACLK,UAAAA,WAAW,EAAEhC,SAAS,CAACkC,MAAM,CAACN,OAAR,CAAT,CAA0BG,OADlC;AAELa,UAAAA,YAAY,EAAEnD,cAAc,CAC1ByC,MAAM,CAACI,YADmB,EAE1BJ,MAAM,CAACK,mBAFmB,CAFvB;AAMLT,UAAAA,WAAW,EAAEtC,aAAa,CAAC0C,MAAM,CAACN,OAAR,CANrB;AAOLU,UAAAA,YAAY,EAAE7C,cAAc,CAC1ByC,MAAM,CAACI,YADmB,EAE1BJ,MAAM,CAACK,mBAFmB;AAPvB,SAFmC;AAc1CE,QAAAA,IAAI,EAAEJ,EAAE,CAACI,IAdiC;AAe1ClB,QAAAA,MAAM,EAAE,YAfkC;AAgB1CsB,QAAAA,SAAS,EAAEC,IAAI,CAACC,GAAL;AAhB+B,OAA5C;AAkBAX,MAAAA,QAAQ,CAACzB,iBAAiB,CAAC+B,WAAD,CAAlB,CAAR;AACAR,MAAAA,MAAM,CAACM,QAAP,CAAgBQ,IAAhB,CAAqBX,EAAE,CAACI,IAAxB,EAA8B,YAAY;AACxC,cAAMQ,OAAO,GAAG,MAAMf,MAAM,CAACM,QAAP,CAAgBU,qBAAhB,CAAsCb,EAAE,CAACI,IAAzC,CAAtB;AACA,cAAMU,KAAgB,GAAGhB,QAAQ,EAAjC;AACA,cAAMiB,MAAM,GAAGC,MAAM,CAACC,MAAP,CAAcH,KAAK,CAACI,QAAN,CAAeH,MAAf,CAAsBI,GAApC,CAAf;;AACA,YAAIP,OAAO,CAAC1B,MAAR,KAAmB,CAAvB,EAA0B;AACxBa,UAAAA,QAAQ,CACN3B,eAAe,CAAC;AACdgC,YAAAA,IAAI,EAAEQ,OAAO,CAACQ;AADA,WAAD,CADT,CAAR;AAKA3D,UAAAA,iBAAiB,CACf,UADe,EAEf4C,WAFe,EAGfU,MAHe,EAIf,KAJe,EAKflB,MAAM,CAACN,OALQ,CAAjB;AAOD,SAbD,MAaO;AACLQ,UAAAA,QAAQ,CAAC1B,iBAAiB,CAACuC,OAAO,CAACQ,eAAT,CAAlB,CAAR;AACA3D,UAAAA,iBAAiB,CACf,UADe,EAEf4C,WAFe,EAGfU,MAHe,EAIf,IAJe,EAKflB,MAAM,CAACN,OALQ,CAAjB;AAOD;AACF,OA3BD;AA4BD;AACF,GAxDD,CAwDE,OAAO+B,CAAP,EAAe;AACfC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAvB,IAAAA,QAAQ,CAAC5B,kBAAkB,CAACmD,CAAC,CAACG,OAAH,CAAnB,CAAR;AACA,UAAMH,CAAN;AACD;AACF,CAzEqC,CAAjC;AA4EP,OAAO,MAAMQ,OAAO,GAAGzE,gBAAgB,CACrC,gBADqC,EAErC,OACEwC,MADF,EASE;AAAEE,EAAAA;AAAF,CATF,KAUK;AACH,QAAMd,MAAM,GAAG,MAAMJ,aAAa,CAChCgB,MAAM,CAACkC,OADyB,EAEhClC,MAAM,CAACF,WAFyB,EAGhCE,MAAM,CAACJ,WAHyB,EAIhCI,MAAM,CAACI,YAJyB,EAKhCJ,MAAM,CAACK,mBALyB,EAMhCL,MAAM,CAACmC,YANyB,CAAlC;;AAQA,MAAI/C,MAAM,CAACgD,MAAX,EAAmB;AACjB,UAAMC,SAAS,GAAG,CAAC,GAAGjD,MAAJ,EAAYkD,IAAZ,CAAiBvD,oBAAjB,EAAuC,CAAvC,CAAlB;AACA,UAAMwD,MAAM,GAAGC,QAAQ,CAACH,SAAS,CAACE,MAAX,CAAR,GAA6B,IAA5C;AACA,UAAME,gBAAgB,GAAGF,MAAM,GAAG3B,IAAI,CAACC,GAAL,EAAT,GAAsBhD,oBAA/C;AACA,UAAMyB,gBAAgB,GAAGoD,MAAM,CAACC,UAAP,CACvB,MAAMzC,QAAQ,CAAC+B,OAAO,CAACjC,MAAD,CAAR,CADS,EAEvByC,gBAFuB,CAAzB;AAIAvC,IAAAA,QAAQ,CAAC0C,mBAAmB,CAACtD,gBAAD,CAApB,CAAR;AACD;;AACD,SAAOF,MAAP;AACD,CAhCoC,CAAhC;AAmCP,OAAO,MAAMyD,OAAO,GAAGrF,gBAAgB,CAgBrC,gBAhBqC,EAgBnB,OAAOwC,MAAP,EAAe;AAAEC,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,CAAf,KAA0C;AAC5D,MAAIC,EAAJ;;AACA,MAAI;AACFA,IAAAA,EAAE,GAAG,MAAMtB,YAAY,CAACmB,MAAM,CAAC8C,KAAR,EAAe9C,MAAM,CAAC+C,OAAtB,EAA+B/C,MAAM,CAACgD,YAAtC,CAAvB;;AACA,QAAI7C,EAAE,CAACI,IAAP,EAAa;AACX,YAAMC,WAA8B,GAAG;AACrCC,QAAAA,IAAI,EAAE,UAD+B;AAErCF,QAAAA,IAAI,EAAEJ,EAAE,CAACI,IAF4B;AAGrClB,QAAAA,MAAM,EAAE,YAH6B;AAIrC4D,QAAAA,YAAY,EAAEjD,MAAM,CAAC8C,KAJgB;AAKrCnC,QAAAA,SAAS,EAAEC,IAAI,CAACC,GAAL;AAL0B,OAAvC;AAOAX,MAAAA,QAAQ,CAACzB,iBAAiB,CAAC+B,WAAD,CAAlB,CAAR;AACAR,MAAAA,MAAM,CAAC+C,OAAP,CAAejC,IAAf,CAAoBX,EAAE,CAACI,IAAvB,EAA6B,YAAY;AACvC,cAAMQ,OAAO,GAAG,MAAMf,MAAM,CAAC+C,OAAP,CAAe/B,qBAAf,CAAqCb,EAAE,CAACI,IAAxC,CAAtB;AACA,cAAMU,KAAgB,GAAGhB,QAAQ,EAAjC;AACA,cAAMiB,MAAM,GAAGC,MAAM,CAACC,MAAP,CAAcH,KAAK,CAACI,QAAN,CAAeH,MAAf,CAAsBI,GAApC,CAAf;;AACA,YAAIP,OAAO,CAAC1B,MAAR,KAAmB,CAAvB,EAA0B;AACxBa,UAAAA,QAAQ,CACN3B,eAAe,CAAC;AACdgC,YAAAA,IAAI,EAAEQ,OAAO,CAACQ;AADA,WAAD,CADT,CAAR,CADwB,CAMxB;AACA;;AACA,cAAIvB,MAAM,CAACgD,YAAP,KAAwB,OAA5B,EAAqC;AACnC9C,YAAAA,QAAQ,CACNnC,sBAAsB,CAACmF,GAAvB,CAA2B;AACzBD,cAAAA,YAAY,EAAEjD,MAAM,CAAC8C,KADI;AAEzBK,cAAAA,MAAM,EAAE5D;AAFiB,aAA3B,CADM,CAAR;AAMD,WAPD,MAOO,IAAIS,MAAM,CAACgD,YAAP,KAAwB,SAA5B,EAAuC;AAC5C9C,YAAAA,QAAQ,CACNlC,wBAAwB,CAACkF,GAAzB,CAA6B;AAC3BD,cAAAA,YAAY,EAAEjD,MAAM,CAAC8C,KADM;AAE3BK,cAAAA,MAAM,EAAE5D;AAFmB,aAA7B,CADM,CAAR;AAMD;;AAED3B,UAAAA,iBAAiB,CACf,UADe,EAEf4C,WAFe,EAGfU,MAHe,EAIf,KAJe,EAKflB,MAAM,CAACN,OALQ,CAAjB;AAOD,SA/BD,MA+BO;AACLQ,UAAAA,QAAQ,CAAC1B,iBAAiB,CAACuC,OAAO,CAACQ,eAAT,CAAlB,CAAR;AACA3D,UAAAA,iBAAiB,CACf,UADe,EAEf4C,WAFe,EAGfU,MAHe,EAIf,IAJe,EAKflB,MAAM,CAACN,OALQ,CAAjB;AAOD;AACF,OA7CD;AA8CD;AACF,GA1DD,CA0DE,OAAO+B,CAAP,EAAe;AACfC,IAAAA,OAAO,CAACC,KAAR,CAAcF,CAAd;AACAvB,IAAAA,QAAQ,CAAC5B,kBAAkB,CAACmD,CAAC,CAACG,OAAH,CAAnB,CAAR;AACA,UAAMH,CAAN;AACD;AACF,CAjFsC,CAAhC;AAmFP,OAAO,MAAM2B,IAAI,GAAG5F,gBAAgB,CAelC,aAfkC,EAenB,OAAOwC,MAAP,EAAe;AAAEC,EAAAA,QAAF;AAAYC,EAAAA;AAAZ,CAAf,KAA0C;AACzD,MAAIC,EAAJ;;AACA,MAAI;AACFA,IAAAA,EAAE,GAAG,MAAMlB,SAAS,CAACe,MAAM,CAACP,KAAR,EAAeO,MAAM,CAAC+C,OAAtB,EAA+B/C,MAAM,CAACgD,YAAtC,CAApB,CADE,CAEF;AACA;;AACA,QAAIrD,QAAQ,GACVK,MAAM,CAACgD,YAAP,KAAwB,OAAxB,GACIhD,MAAM,CAACP,KADX,GAEID,aAAa,CAACQ,MAAM,CAACP,KAAR,EAAeO,MAAM,CAAC+C,OAAP,CAAeM,QAAf,CAAwB3D,OAAvC,CAHnB;;AAIA,QAAIS,EAAE,CAACI,IAAP,EAAa;AACX,YAAMC,WAA8B,GAAG;AACrCC,QAAAA,IAAI,EAAE,OAD+B;AAErChB,QAAAA,KAAK,EAAEE,QAF8B;AAGrC2D,QAAAA,QAAQ,EAAE,mBAH2B;AAIrC/C,QAAAA,IAAI,EAAEJ,EAAE,CAACI,IAJ4B;AAKrClB,QAAAA,MAAM,EAAE,YAL6B;AAMrCsB,QAAAA,SAAS,EAAEC,IAAI,CAACC,GAAL,EAN0B;AAOrC0C,QAAAA,KAAK,EAAEvD,MAAM,CAACP,KAAP,CAAa8D,KAPiB;AAQrChB,QAAAA,MAAM,EAAEvC,MAAM,CAACP,KAAP,CAAa8C;AARgB,OAAvC;AAUArC,MAAAA,QAAQ,CACNxB,2BAA2B,CAAC;AAC1B8B,QAAAA,WAD0B;AAE1BgD,QAAAA,YAAY,EAAExD,MAAM,CAACP,KAAP,CAAa+D,YAFD;AAG1BC,QAAAA,SAAS,EAAEzD,MAAM,CAACyD;AAHQ,OAAD,CADrB,CAAR;AAOD;AACF,GA3BD,CA2BE,OAAOhC,CAAP,EAAe;AACfvB,IAAAA,QAAQ,CAAC5B,kBAAkB,CAACmD,CAAC,CAACG,OAAH,CAAnB,CAAR;AACA,UAAMH,CAAN;AACD;AACF,CAhDmC,CAA7B;AAkDP,OAAO,MAAMiC,WAAW,GAAGhG,WAAW,CAAC;AACrCiG,EAAAA,IAAI,EAAE,QAD+B;AAErCxE,EAAAA,YAFqC;AAGrCyE,EAAAA,QAAQ,EAAE;AACR9B,IAAAA,cAAc,EAAGb,KAAD,IAAW;AACzBA,MAAAA,KAAK,CAAC5B,MAAN,GAAe,OAAf;AACD,KAHO;AAIR0C,IAAAA,KAAK,EAAGd,KAAD,IAAW;AAChBA,MAAAA,KAAK,CAAC7B,MAAN,GAAe,EAAf;AACA6B,MAAAA,KAAK,CAAC5B,MAAN,GAAe,MAAf;;AACA,UAAI4B,KAAK,CAAC3B,gBAAV,EAA4B;AAC1BuE,QAAAA,YAAY,CAAC5C,KAAK,CAAC3B,gBAAP,CAAZ;AACA2B,QAAAA,KAAK,CAAC3B,gBAAN,GAAyB,IAAzB;AACD;AACF,KAXO;AAYRsD,IAAAA,mBAAmB,EAAE,CAAC3B,KAAD,EAAQ6C,MAAR,KAA0C;AAC7D7C,MAAAA,KAAK,CAAC3B,gBAAN,GAAyBwE,MAAM,CAACC,OAAhC;AACD;AAdO,GAH2B;AAmBrCC,EAAAA,aAAa,EAAGC,OAAD,IAAa;AAC1BA,IAAAA,OAAO,CACJC,OADH,CACWjC,OAAO,CAACkC,OADnB,EAC6BlD,KAAD,IAAW;AACnCA,MAAAA,KAAK,CAAC5B,MAAN,GAAe,YAAf;AACD,KAHH,EAIG6E,OAJH,CAIWjC,OAAO,CAACmC,SAJnB,EAI8B,CAACnD,KAAD,EAAQ6C,MAAR,KAAmB;AAC7C7C,MAAAA,KAAK,CAAC5B,MAAN,GAAe,MAAf;AACA4B,MAAAA,KAAK,CAAC7B,MAAN,GAAe0E,MAAM,CAACC,OAAtB;AACD,KAPH,EAQGG,OARH,CAQWjC,OAAO,CAACoC,QARnB,EAQ6B,CAACpD,KAAD,EAAQ6C,MAAR,KAAmB;AAC5C7C,MAAAA,KAAK,CAAC5B,MAAN,GAAe,QAAf;AACA4B,MAAAA,KAAK,CAAC7B,MAAN,GAAe,EAAf;AACD,KAXH,EAYG8E,OAZH,CAYWd,IAAI,CAACe,OAZhB,EAY0BlD,KAAD,IAAW;AAChCA,MAAAA,KAAK,CAAC5B,MAAN,GAAe,QAAf;AACD,KAdH,EAeG6E,OAfH,CAeWd,IAAI,CAACgB,SAfhB,EAe2B,CAACnD,KAAD,EAAQ6C,MAAR,KAAmB;AAC1C7C,MAAAA,KAAK,CAAC5B,MAAN,GAAe,MAAf;AACD,KAjBH,EAkBG6E,OAlBH,CAkBWd,IAAI,CAACiB,QAlBhB,EAkB0B,CAACpD,KAAD,EAAQ6C,MAAR,KAAmB;AACzC7C,MAAAA,KAAK,CAAC5B,MAAN,GAAe,QAAf;AACD,KApBH,EAqBG6E,OArBH,CAqBWrB,OAAO,CAACsB,OArBnB,EAqB6BlD,KAAD,IAAW;AACnCA,MAAAA,KAAK,CAAC5B,MAAN,GAAe,WAAf;AACD,KAvBH,EAwBG6E,OAxBH,CAwBWrB,OAAO,CAACuB,SAxBnB,EAwB+BnD,KAAD,IAAW;AACrCA,MAAAA,KAAK,CAAC5B,MAAN,GAAe,MAAf;AACD,KA1BH,EA2BG6E,OA3BH,CA2BWrB,OAAO,CAACwB,QA3BnB,EA2B8BpD,KAAD,IAAW;AACpCA,MAAAA,KAAK,CAAC5B,MAAN,GAAe,QAAf;AACD,KA7BH,EA8BG6E,OA9BH,CA8BWvF,kBA9BX,EA8BgCsC,KAAD,IAAW;AACtCA,MAAAA,KAAK,CAAC5B,MAAN,GAAe,MAAf;AACA4B,MAAAA,KAAK,CAAC7B,MAAN,GAAe,EAAf;AACD,KAjCH,EAkCG8E,OAlCH,CAkCWtF,qBAlCX,EAkCmCqC,KAAD,IAAW;AACzCA,MAAAA,KAAK,CAAC5B,MAAN,GAAe,MAAf;AACA4B,MAAAA,KAAK,CAAC7B,MAAN,GAAe,EAAf;AACD,KArCH;AAsCD;AA1DoC,CAAD,CAA/B;AA6DP,OAAO,MAAM;AACX2C,EAAAA,KADW;AAEXD,EAAAA,cAFW;AAGXc,EAAAA;AAHW,IAITc,WAAW,CAACY,OAJT;AAKP;AACA;AACA;AACA;;AACA,OAAO,MAAMC,eAAe,GAAItD,KAAD,IAC7B;AACA;AACA,CAAC,GAAGA,KAAK,CAAC7B,MAAN,CAAaA,MAAjB,EAAyBkD,IAAzB,CAA8BvD,oBAA9B,EAAoD,CAApD,CAHK;AAKP,OAAO,MAAMyF,kBAAkB,GAAIvD,KAAD,IAChC,CAAC,GAAGA,KAAK,CAAC7B,MAAN,CAAaA,MAAjB,EAAyBkD,IAAzB,CAA8BvD,oBAA9B,CADK;AAGP,OAAO,MAAM0F,gBAAgB,GAAIxD,KAAD,IAAsBA,KAAK,CAAC7B,MAAN,CAAaA,MAAb,CAAoB,CAApB,CAA/C;AAEP,OAAO,MAAMsF,gBAAgB,GAAGjH,cAAc,CAC5CY,gBAD4C,EAE5CkG,eAF4C,EAG5CpG,iBAH4C,EAI5CD,2BAJ4C,EAK5C,CAACyG,KAAD,EAAQC,YAAR,EAAsBC,WAAtB,EAAmCC,qBAAnC,KAA6D;AAC3D,MAAI,CAACH,KAAL,EAAY,OAAO,IAAP;;AAEZ,MAAIA,KAAK,CAACI,IAAN,KAAe,KAAnB,EAA0B;AACxBrD,IAAAA,OAAO,CAACC,KAAR,CAAe,gCAAf;AACA,WAAO,IAAP;AACD;;AAED,MAAIqD,OAAO,GAAIH,WAAf;AAMA,MAAI,CAACD,YAAD,IAAiB,CAACI,OAAtB,EAA+B,OAAO,IAAP;AAE/B,MAAIC,aAAJ;;AACA,MAAID,OAAJ,EAAa;AACXC,IAAAA,aAAa,GAAG;AACdC,MAAAA,WAAW,EAAEF,OAAO,CAAEE,WADR;AAEd5B,MAAAA,QAAQ,EAAE,WAFI;AAGd0B,MAAAA,OAAO,EAAEA;AAHK,KAAhB;AAKA,QAAI,CAACJ,YAAL,EAAmB,OAAOK,aAAP;AACpB;;AAED,MAAIE,QAAJ;AACA,MAAIC,kBAAJ;;AACA,MAAIR,YAAJ,EAAkB;AAChBQ,IAAAA,kBAAkB,GAAG,IAAIzH,SAAJ,CAAciH,YAAY,CAAClE,YAA3B,EAAyC2E,GAAzC,CACnB,IAAI1H,SAAJ,CAAc,EAAd,EAAkB2H,GAAlB,CAAsBX,KAAK,CAACY,UAAN,CAAiBC,QAAvC,CADmB,CAArB;AAGAL,IAAAA,QAAQ,GAAG;AACTD,MAAAA,WAAW,EAAEE,kBAAkB,CAACK,QAAnB,EADJ;AAETnC,MAAAA,QAAQ,EAAE,mBAFD;AAGT7D,MAAAA,KAAK,EAAEmF;AAHE,KAAX;AAKA,QAAI,CAACK,aAAL,EAAoB,OAAOE,QAAP;AACrB;;AAED,MACEH,OAAO,IACPI,kBAAkB,CACfM,KADH,CACS,CAAAZ,qBAAqB,SAArB,IAAAA,qBAAqB,WAArB,YAAAA,qBAAqB,CAAEa,YAAvB,CAAoC1H,cAApC,MAAuD,CADhE,EAEG2H,GAFH,CAEO,IAAIjI,SAAJ,CAAcqH,OAAO,CAACE,WAAtB,CAFP,CAFF,EAKE;AACA,WAAOD,aAAP;AACD,GAPD,MAOO;AACL,WAAOE,QAAP;AACD;AACF,CAvD2C,CAAvC;AA0DP,OAAO,MAAMU,kBAAkB,GAAI5E,KAAD,IAAsBA,KAAK,CAAC7B,MAAN,CAAaC,MAA9D;AACP,eAAeqE,WAAW,CAACoC,OAA3B","sourcesContent":["import { wethAddresses } from \"@airswap/constants\";\nimport { Server } from \"@airswap/libraries\";\nimport { Levels, LightOrder } from \"@airswap/types\";\nimport { toAtomicString } from \"@airswap/utils\";\nimport {\n  createAsyncThunk,\n  createSelector,\n  createSlice,\n  PayloadAction,\n} from \"@reduxjs/toolkit\";\n\nimport BigNumber from \"bignumber.js\";\nimport { Transaction, providers } from \"ethers\";\n\nimport { AppDispatch, RootState } from \"../../app/store\";\nimport { notifyTransaction } from \"../../components/Toasts/ToastController\";\nimport { RFQ_EXPIRY_BUFFER_MS } from \"../../constants/configParams\";\nimport nativeETH from \"../../constants/nativeETH\";\nimport {\n  allowancesLightActions,\n  allowancesWrapperActions,\n} from \"../balances/balancesSlice\";\nimport { gasUsedPerSwap } from \"../gasCost/gasCostApi\";\nimport { selectGasPriceInQuoteTokens } from \"../gasCost/gasCostSlice\";\nimport { selectBestPricing } from \"../pricing/pricingSlice\";\nimport {\n  clearTradeTerms,\n  selectTradeTerms,\n} from \"../tradeTerms/tradeTermsSlice\";\nimport {\n  declineTransaction,\n  mineTransaction,\n  revertTransaction,\n  submitTransaction,\n} from \"../transactions/transactionActions\";\nimport {\n  SubmittedApproval,\n  SubmittedDepositOrder,\n  SubmittedRFQOrder,\n  SubmittedWithdrawOrder,\n  submitTransactionWithExpiry,\n} from \"../transactions/transactionsSlice\";\nimport {\n  setWalletConnected,\n  setWalletDisconnected,\n} from \"../wallet/walletSlice\";\nimport {\n  approveToken,\n  depositETH,\n  orderSortingFunction,\n  requestOrders,\n  takeOrder,\n  withdrawETH,\n} from \"./orderApi\";\n\nexport interface OrdersState {\n  orders: LightOrder[];\n  status: \"idle\" | \"requesting\" | \"approving\" | \"taking\" | \"failed\" | \"reset\";\n  reRequestTimerId: number | null;\n}\n\nconst initialState: OrdersState = {\n  orders: [],\n  status: \"idle\",\n  reRequestTimerId: null,\n};\n\nconst APPROVE_AMOUNT = \"90071992547409910000000000\";\n\n// replaces WETH to ETH on Wrapper orders\nconst refactorOrder = (order: LightOrder, chainId: number) => {\n  let newOrder = { ...order };\n  if (order.senderToken === wethAddresses[chainId]) {\n    newOrder.senderToken = nativeETH[chainId].address;\n  } else if (order.signerToken === wethAddresses[chainId]) {\n    newOrder.signerToken = nativeETH[chainId].address;\n  }\n  return newOrder;\n};\n\nexport const deposit = createAsyncThunk(\n  \"orders/deposit\",\n  async (\n    params: {\n      chainId: number;\n      senderAmount: string;\n      senderTokenDecimals: number;\n      provider: providers.Web3Provider;\n    },\n    { getState, dispatch }\n  ) => {\n    let tx: Transaction;\n    try {\n      tx = await depositETH(\n        params.chainId,\n        params.senderAmount,\n        params.senderTokenDecimals,\n        params.provider\n      );\n      if (tx.hash) {\n        const senderAmount = toAtomicString(\n          params.senderAmount,\n          params.senderTokenDecimals\n        );\n        // Since this is a Deposit, senderAmount === signerAmount\n        const transaction: SubmittedDepositOrder = {\n          type: \"Deposit\",\n          order: {\n            signerToken: wethAddresses[params.chainId],\n            signerAmount: senderAmount,\n            senderToken: nativeETH[params.chainId].address,\n            senderAmount: senderAmount,\n          },\n          hash: tx.hash,\n          status: \"processing\",\n          timestamp: Date.now(),\n        };\n        dispatch(submitTransaction(transaction));\n        params.provider.once(tx.hash, async () => {\n          const receipt = await params.provider.getTransactionReceipt(tx.hash!);\n          const state: RootState = getState() as RootState;\n          const tokens = Object.values(state.metadata.tokens.all);\n          if (receipt.status === 1) {\n            dispatch(\n              mineTransaction({\n                hash: receipt.transactionHash,\n              })\n            );\n            notifyTransaction(\n              \"Deposit\",\n              transaction,\n              tokens,\n              false,\n              params.chainId\n            );\n          } else {\n            dispatch(\n              revertTransaction({\n                hash: receipt.transactionHash,\n                reason: \"Transaction reverted\",\n              })\n            );\n            notifyTransaction(\n              \"Deposit\",\n              transaction,\n              tokens,\n              true,\n              params.chainId\n            );\n          }\n        });\n      }\n    } catch (e: any) {\n      console.error(e);\n      dispatch(declineTransaction(e.message));\n      throw e;\n    }\n  }\n);\n\nexport const resetOrders = createAsyncThunk(\n  \"orders/reset\",\n  async (params: undefined, { getState, dispatch }) => {\n    await dispatch(setResetStatus());\n    dispatch(clear());\n    dispatch(clearTradeTerms());\n  }\n);\n\nexport const withdraw = createAsyncThunk(\n  \"orders/withdraw\",\n  async (\n    params: {\n      chainId: number;\n      senderAmount: string;\n      senderTokenDecimals: number;\n      provider: any;\n    },\n    { getState, dispatch }\n  ) => {\n    let tx: Transaction;\n    try {\n      tx = await withdrawETH(\n        params.chainId,\n        params.senderAmount,\n        params.senderTokenDecimals,\n        params.provider\n      );\n      if (tx.hash) {\n        const transaction: SubmittedWithdrawOrder = {\n          type: \"Withdraw\",\n          order: {\n            signerToken: nativeETH[params.chainId].address,\n            signerAmount: toAtomicString(\n              params.senderAmount,\n              params.senderTokenDecimals\n            ),\n            senderToken: wethAddresses[params.chainId],\n            senderAmount: toAtomicString(\n              params.senderAmount,\n              params.senderTokenDecimals\n            ),\n          },\n          hash: tx.hash,\n          status: \"processing\",\n          timestamp: Date.now(),\n        };\n        dispatch(submitTransaction(transaction));\n        params.provider.once(tx.hash, async () => {\n          const receipt = await params.provider.getTransactionReceipt(tx.hash);\n          const state: RootState = getState() as RootState;\n          const tokens = Object.values(state.metadata.tokens.all);\n          if (receipt.status === 1) {\n            dispatch(\n              mineTransaction({\n                hash: receipt.transactionHash,\n              })\n            );\n            notifyTransaction(\n              \"Withdraw\",\n              transaction,\n              tokens,\n              false,\n              params.chainId\n            );\n          } else {\n            dispatch(revertTransaction(receipt.transactionHash));\n            notifyTransaction(\n              \"Withdraw\",\n              transaction,\n              tokens,\n              true,\n              params.chainId\n            );\n          }\n        });\n      }\n    } catch (e: any) {\n      console.error(e);\n      dispatch(declineTransaction(e.message));\n      throw e;\n    }\n  }\n);\n\nexport const request = createAsyncThunk(\n  \"orders/request\",\n  async (\n    params: {\n      servers: Server[];\n      signerToken: string;\n      senderToken: string;\n      senderAmount: string;\n      senderTokenDecimals: number;\n      senderWallet: string;\n    },\n    { dispatch }\n  ) => {\n    const orders = await requestOrders(\n      params.servers,\n      params.signerToken,\n      params.senderToken,\n      params.senderAmount,\n      params.senderTokenDecimals,\n      params.senderWallet\n    );\n    if (orders.length) {\n      const bestOrder = [...orders].sort(orderSortingFunction)[0];\n      const expiry = parseInt(bestOrder.expiry) * 1000;\n      const timeTilReRequest = expiry - Date.now() - RFQ_EXPIRY_BUFFER_MS;\n      const reRequestTimerId = window.setTimeout(\n        () => dispatch(request(params)),\n        timeTilReRequest\n      );\n      dispatch(setReRequestTimerId(reRequestTimerId));\n    }\n    return orders;\n  }\n);\n\nexport const approve = createAsyncThunk<\n  // Return type of the payload creator\n  void,\n  // Params\n  {\n    token: string;\n    library: any;\n    contractType: \"Wrapper\" | \"Light\";\n    chainId: number;\n  },\n  // Types for ThunkAPI\n  {\n    // thunkApi\n    dispatch: AppDispatch;\n    state: RootState;\n  }\n>(\"orders/approve\", async (params, { getState, dispatch }) => {\n  let tx: Transaction;\n  try {\n    tx = await approveToken(params.token, params.library, params.contractType);\n    if (tx.hash) {\n      const transaction: SubmittedApproval = {\n        type: \"Approval\",\n        hash: tx.hash,\n        status: \"processing\",\n        tokenAddress: params.token,\n        timestamp: Date.now(),\n      };\n      dispatch(submitTransaction(transaction));\n      params.library.once(tx.hash, async () => {\n        const receipt = await params.library.getTransactionReceipt(tx.hash);\n        const state: RootState = getState() as RootState;\n        const tokens = Object.values(state.metadata.tokens.all);\n        if (receipt.status === 1) {\n          dispatch(\n            mineTransaction({\n              hash: receipt.transactionHash,\n            })\n          );\n          // Optimistically update allowance (this is not really optimistic,\n          // but it preempts receiving the event)\n          if (params.contractType === \"Light\") {\n            dispatch(\n              allowancesLightActions.set({\n                tokenAddress: params.token,\n                amount: APPROVE_AMOUNT,\n              })\n            );\n          } else if (params.contractType === \"Wrapper\") {\n            dispatch(\n              allowancesWrapperActions.set({\n                tokenAddress: params.token,\n                amount: APPROVE_AMOUNT,\n              })\n            );\n          }\n\n          notifyTransaction(\n            \"Approval\",\n            transaction,\n            tokens,\n            false,\n            params.chainId\n          );\n        } else {\n          dispatch(revertTransaction(receipt.transactionHash));\n          notifyTransaction(\n            \"Approval\",\n            transaction,\n            tokens,\n            true,\n            params.chainId\n          );\n        }\n      });\n    }\n  } catch (e: any) {\n    console.error(e);\n    dispatch(declineTransaction(e.message));\n    throw e;\n  }\n});\n\nexport const take = createAsyncThunk<\n  // Return type of the payload creator\n  void,\n  // Params\n  {\n    order: LightOrder;\n    library: any;\n    contractType: \"Light\" | \"Wrapper\";\n    onExpired: () => void;\n  },\n  // Types for ThunkAPI\n  {\n    dispatch: AppDispatch;\n    state: RootState;\n  }\n>(\"orders/take\", async (params, { getState, dispatch }) => {\n  let tx: Transaction;\n  try {\n    tx = await takeOrder(params.order, params.library, params.contractType);\n    // When dealing with the Wrapper, since the \"actual\" swap is ETH <-> ERC20,\n    // we should change the order tokens to WETH -> ETH\n    let newOrder =\n      params.contractType === \"Light\"\n        ? params.order\n        : refactorOrder(params.order, params.library._network.chainId);\n    if (tx.hash) {\n      const transaction: SubmittedRFQOrder = {\n        type: \"Order\",\n        order: newOrder,\n        protocol: \"request-for-quote\",\n        hash: tx.hash,\n        status: \"processing\",\n        timestamp: Date.now(),\n        nonce: params.order.nonce,\n        expiry: params.order.expiry,\n      };\n      dispatch(\n        submitTransactionWithExpiry({\n          transaction,\n          signerWallet: params.order.signerWallet,\n          onExpired: params.onExpired,\n        })\n      );\n    }\n  } catch (e: any) {\n    dispatch(declineTransaction(e.message));\n    throw e;\n  }\n});\n\nexport const ordersSlice = createSlice({\n  name: \"orders\",\n  initialState,\n  reducers: {\n    setResetStatus: (state) => {\n      state.status = \"reset\";\n    },\n    clear: (state) => {\n      state.orders = [];\n      state.status = \"idle\";\n      if (state.reRequestTimerId) {\n        clearTimeout(state.reRequestTimerId);\n        state.reRequestTimerId = null;\n      }\n    },\n    setReRequestTimerId: (state, action: PayloadAction<number>) => {\n      state.reRequestTimerId = action.payload;\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(request.pending, (state) => {\n        state.status = \"requesting\";\n      })\n      .addCase(request.fulfilled, (state, action) => {\n        state.status = \"idle\";\n        state.orders = action.payload!;\n      })\n      .addCase(request.rejected, (state, action) => {\n        state.status = \"failed\";\n        state.orders = [];\n      })\n      .addCase(take.pending, (state) => {\n        state.status = \"taking\";\n      })\n      .addCase(take.fulfilled, (state, action) => {\n        state.status = \"idle\";\n      })\n      .addCase(take.rejected, (state, action) => {\n        state.status = \"failed\";\n      })\n      .addCase(approve.pending, (state) => {\n        state.status = \"approving\";\n      })\n      .addCase(approve.fulfilled, (state) => {\n        state.status = \"idle\";\n      })\n      .addCase(approve.rejected, (state) => {\n        state.status = \"failed\";\n      })\n      .addCase(setWalletConnected, (state) => {\n        state.status = \"idle\";\n        state.orders = [];\n      })\n      .addCase(setWalletDisconnected, (state) => {\n        state.status = \"idle\";\n        state.orders = [];\n      });\n  },\n});\n\nexport const {\n  clear,\n  setResetStatus,\n  setReRequestTimerId,\n} = ordersSlice.actions;\n/**\n * Sorts orders and returns the best order based on tokens received or sent\n * then falling back to expiry.\n */\nexport const selectBestOrder = (state: RootState) =>\n  // Note that `.sort` mutates the array, so we need to clone it first to\n  // prevent mutating state.\n  [...state.orders.orders].sort(orderSortingFunction)[0];\n\nexport const selectSortedOrders = (state: RootState) =>\n  [...state.orders.orders].sort(orderSortingFunction);\n\nexport const selectFirstOrder = (state: RootState) => state.orders.orders[0];\n\nexport const selectBestOption = createSelector(\n  selectTradeTerms,\n  selectBestOrder,\n  selectBestPricing,\n  selectGasPriceInQuoteTokens,\n  (terms, bestRfqOrder, bestPricing, gasPriceInQuoteTokens) => {\n    if (!terms) return null;\n\n    if (terms.side === \"buy\") {\n      console.error(`Buy orders not implemented yet`);\n      return null;\n    }\n\n    let pricing = (bestPricing as unknown) as {\n      pricing: Levels;\n      locator: string;\n      quoteAmount: string;\n    } | null;\n\n    if (!bestRfqOrder && !pricing) return null;\n\n    let lastLookOrder;\n    if (pricing) {\n      lastLookOrder = {\n        quoteAmount: pricing!.quoteAmount,\n        protocol: \"last-look\",\n        pricing: pricing!,\n      };\n      if (!bestRfqOrder) return lastLookOrder;\n    }\n\n    let rfqOrder;\n    let bestRFQQuoteTokens: BigNumber | undefined;\n    if (bestRfqOrder) {\n      bestRFQQuoteTokens = new BigNumber(bestRfqOrder.signerAmount).div(\n        new BigNumber(10).pow(terms.quoteToken.decimals)\n      );\n      rfqOrder = {\n        quoteAmount: bestRFQQuoteTokens.toString(),\n        protocol: \"request-for-quote\",\n        order: bestRfqOrder,\n      };\n      if (!lastLookOrder) return rfqOrder;\n    }\n\n    if (\n      pricing &&\n      bestRFQQuoteTokens!\n        .minus(gasPriceInQuoteTokens?.multipliedBy(gasUsedPerSwap) || 0)\n        .lte(new BigNumber(pricing.quoteAmount))\n    ) {\n      return lastLookOrder;\n    } else {\n      return rfqOrder;\n    }\n  }\n);\n\nexport const selectOrdersStatus = (state: RootState) => state.orders.status;\nexport default ordersSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}