{"ast":null,"code":"var _jsxFileName = \"/Users/marcusmattus/ethdex/airswap-web/src/components/SwapWidget/SwapWidget.tsx\",\n    _s = $RefreshSig$();\n\nimport React, { useContext, useEffect, useMemo, useState } from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { useHistory } from \"react-router-dom\";\nimport { wethAddresses } from \"@airswap/constants\";\nimport { Registry, Wrapper } from \"@airswap/libraries\";\nimport { findTokensBySymbol } from \"@airswap/metadata\";\nimport { unwrapResult } from \"@reduxjs/toolkit\";\nimport { UnsupportedChainIdError, useWeb3React } from \"@web3-react/core\";\nimport { BigNumber } from \"bignumber.js\";\nimport { formatUnits } from \"ethers/lib/utils\";\nimport { useAppDispatch, useAppSelector } from \"../../app/hooks\";\nimport { ADDITIONAL_QUOTE_BUFFER, RECEIVE_QUOTE_TIMEOUT_MS } from \"../../constants/configParams\";\nimport nativeETH from \"../../constants/nativeETH\";\nimport { LastLookContext } from \"../../contexts/lastLook/LastLook\";\nimport { requestActiveTokenAllowancesLight, requestActiveTokenAllowancesWrapper, requestActiveTokenBalances, selectAllowances, selectBalances } from \"../../features/balances/balancesSlice\";\nimport { addActiveToken, removeActiveToken, selectActiveTokens, selectAllTokenInfo } from \"../../features/metadata/metadataSlice\";\nimport { approve, clear, deposit, request, resetOrders, selectBestOption, selectBestOrder, selectOrdersStatus, take, withdraw } from \"../../features/orders/ordersSlice\";\nimport { selectAllSupportedTokens } from \"../../features/registry/registrySlice\";\nimport { clearTradeTerms, clearTradeTermsQuoteAmount, selectTradeTerms, setTradeTerms, setTradeTermsQuoteAmount } from \"../../features/tradeTerms/tradeTermsSlice\";\nimport { declineTransaction, revertTransaction } from \"../../features/transactions/transactionActions\";\nimport { selectPendingApprovals } from \"../../features/transactions/transactionsSlice\";\nimport { setUserTokens, selectUserTokens } from \"../../features/userSettings/userSettingsSlice\";\nimport { setActiveProvider } from \"../../features/wallet/walletSlice\";\nimport { Validator } from \"../../helpers/Validator\";\nimport findEthOrTokenByAddress from \"../../helpers/findEthOrTokenByAddress\";\nimport useAppRouteParams from \"../../hooks/useAppRouteParams\";\nimport useReferencePriceSubscriber from \"../../hooks/useReferencePriceSubscriber\";\nimport { AppRoutes } from \"../../routes\";\nimport { ErrorList } from \"../ErrorList/ErrorList\";\nimport GasFreeSwapsModal from \"../InformationModals/subcomponents/GasFreeSwapsModal/GasFreeSwapsModal\";\nimport JoinModal from \"../InformationModals/subcomponents/JoinModal/JoinModal\";\nimport ProtocolFeeDiscountModal from \"../InformationModals/subcomponents/ProtocolFeeDiscountModal/ProtocolFeeDiscountModal\";\nimport Overlay from \"../Overlay/Overlay\";\nimport { notifyError } from \"../Toasts/ToastController\";\nimport TokenList from \"../TokenList/TokenList\";\nimport InfoSection from \"./InfoSection\";\nimport StyledSwapWidget, { ButtonContainer, HugeTicks, InfoContainer, StyledWalletProviderList } from \"./SwapWidget.styles\";\nimport getTokenPairs from \"./helpers/getTokenPairs\";\nimport ActionButtons, { ButtonActions } from \"./subcomponents/ActionButtons/ActionButtons\";\nimport SwapInputs from \"./subcomponents/SwapInputs/SwapInputs\";\nimport SwapWidgetHeader from \"./subcomponents/SwapWidgetHeader/SwapWidgetHeader\";\nimport { jsxDEV as _jsxDEV } from \"react/jsx-dev-runtime\";\nimport { Fragment as _Fragment } from \"react/jsx-dev-runtime\";\nconst initialBaseAmount = \"\";\n\nconst SwapWidget = ({\n  showWalletList,\n  activeInformationModal,\n  setShowWalletList,\n  transactionsTabOpen,\n  onTrackTransactionClicked,\n  onInformationModalCloseButtonClick\n}) => {\n  _s();\n\n  var _bestTradeOption$orde;\n\n  // Redux\n  const dispatch = useAppDispatch();\n  const history = useHistory();\n  const balances = useAppSelector(selectBalances);\n  const allowances = useAppSelector(selectAllowances);\n  const bestRfqOrder = useAppSelector(selectBestOrder);\n  const ordersStatus = useAppSelector(selectOrdersStatus);\n  const bestTradeOption = useAppSelector(selectBestOption);\n  const activeTokens = useAppSelector(selectActiveTokens);\n  const allTokens = useAppSelector(selectAllTokenInfo);\n  const supportedTokens = useAppSelector(selectAllSupportedTokens);\n  const pendingApprovals = useAppSelector(selectPendingApprovals);\n  const tradeTerms = useAppSelector(selectTradeTerms);\n  const userTokens = useAppSelector(selectUserTokens); // Contexts\n\n  const LastLook = useContext(LastLookContext); // Input states\n\n  const appRouteParams = useAppRouteParams();\n  const [tokenFrom, setTokenFrom] = useState();\n  const [tokenTo, setTokenTo] = useState();\n  const [baseAmount, setBaseAmount] = useState(initialBaseAmount); // Pricing\n\n  const {\n    subscribeToGasPrice,\n    subscribeToTokenPrice,\n    unsubscribeFromGasPrice,\n    unsubscribeFromTokenPrice\n  } = useReferencePriceSubscriber(); // Modals\n\n  const [showOrderSubmitted, setShowOrderSubmitted] = useState(false);\n  const [showTokenSelectModalFor, setShowTokenSelectModalFor] = useState(null);\n  const [showGasFeeInfo, setShowGasFeeInfo] = useState(false);\n  const [protocolFeeDiscountInfo, setProtocolFeeDiscountInfo] = useState(false); // Loading states\n\n  const [isApproving, setIsApproving] = useState(false);\n  const [isSwapping, setIsSwapping] = useState(false);\n  const [isWrapping, setIsWrapping] = useState(false);\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [isRequestingQuotes, setIsRequestingQuotes] = useState(false); // Error states\n\n  const [pairUnavailable, setPairUnavailable] = useState(false);\n  const [validatorErrors, setValidatorErrors] = useState([]);\n  const [allowanceFetchFailed, setAllowanceFetchFailed] = useState(false);\n  const {\n    t\n  } = useTranslation();\n  const {\n    chainId,\n    account,\n    library,\n    active,\n    activate,\n    error: web3Error\n  } = useWeb3React();\n  const defaultBaseTokenAddress = allTokens.length ? findTokensBySymbol(\"USDT\", allTokens)[0].address : null;\n  const defaultQuoteTokenAddress = allTokens.length ? findTokensBySymbol(\"WETH\", allTokens)[0].address : null; // Use default tokens only if neither are specified in the URL or store.\n\n  const baseToken = tokenFrom ? tokenFrom : tokenTo ? null : userTokens.tokenFrom || defaultBaseTokenAddress;\n  const quoteToken = tokenTo ? tokenTo : tokenFrom ? null : userTokens.tokenTo || defaultQuoteTokenAddress;\n  const baseTokenInfo = useMemo(() => baseToken ? findEthOrTokenByAddress(baseToken, activeTokens, chainId) : null, [baseToken, activeTokens, chainId]);\n  const quoteTokenInfo = useMemo(() => quoteToken ? findEthOrTokenByAddress(quoteToken, activeTokens, chainId) : null, [quoteToken, activeTokens, chainId]);\n  const maxAmount = useMemo(() => {\n    if (!baseToken || !balances || !baseTokenInfo || !balances.values[baseToken] || balances.values[baseToken] === \"0\") {\n      return null;\n    }\n\n    return formatUnits(balances.values[baseToken] || \"0\", baseTokenInfo.decimals);\n  }, [balances, baseToken, baseTokenInfo]);\n  useEffect(() => {\n    setAllowanceFetchFailed(false);\n    setBaseAmount(initialBaseAmount);\n    dispatch(clearTradeTerms());\n    unsubscribeFromGasPrice();\n    unsubscribeFromTokenPrice();\n    dispatch(clear());\n    LastLook.unsubscribeAllServers();\n  }, [chainId, dispatch, LastLook, unsubscribeFromGasPrice, unsubscribeFromTokenPrice]);\n  useEffect(() => {\n    setTokenFrom(appRouteParams.tokenFrom);\n    setTokenTo(appRouteParams.tokenTo);\n  }, [appRouteParams]);\n  useEffect(() => {\n    if (ordersStatus === \"reset\") {\n      setIsApproving(false);\n      setIsSwapping(false);\n      setIsWrapping(false);\n      setIsRequestingQuotes(false);\n      setAllowanceFetchFailed(false);\n      setPairUnavailable(false);\n      setProtocolFeeDiscountInfo(false);\n      setShowGasFeeInfo(false);\n      setBaseAmount(initialBaseAmount);\n      LastLook.unsubscribeAllServers();\n    }\n  }, [ordersStatus, LastLook, dispatch]); // Reset when the chainId changes.\n\n  useEffect(() => {\n    if (chainId) {\n      dispatch(resetOrders());\n    }\n  }, [chainId, dispatch]);\n  useEffect(() => {\n    setAllowanceFetchFailed(allowances.light.status === \"failed\" || allowances.wrapper.status === \"failed\");\n  }, [allowances.light.status, allowances.wrapper.status]);\n  let swapType = \"swap\";\n\n  if (chainId && baseToken && quoteToken) {\n    const eth = nativeETH[chainId].address;\n    const weth = wethAddresses[chainId];\n\n    if ([weth, eth].includes(baseToken) && [weth, eth].includes(quoteToken)) {\n      swapType = \"wrapOrUnwrap\";\n    } else if ([quoteToken, baseToken].includes(eth)) {\n      swapType = \"swapWithWrap\";\n    }\n  }\n\n  const quoteAmount = swapType === \"wrapOrUnwrap\" ? baseAmount : tradeTerms.quoteAmount || (bestTradeOption === null || bestTradeOption === void 0 ? void 0 : bestTradeOption.quoteAmount) || \"\";\n\n  const hasApprovalPending = tokenId => {\n    if (tokenId === undefined) return false;\n    return pendingApprovals.some(tx => tx.tokenAddress === tokenId);\n  };\n\n  const hasSufficientAllowance = tokenAddress => {\n    if (tokenAddress === nativeETH[chainId || 1].address) return true;\n    if (!tokenAddress) return false;\n\n    if (allowances[swapType === \"swapWithWrap\" ? \"wrapper\" : \"light\"].values[tokenAddress] === undefined) {\n      // We don't currently know what the user's allowance is, this is an error\n      // state we shouldn't repeatedly hit, so we'll prompt a reload.\n      if (!allowanceFetchFailed) setAllowanceFetchFailed(true); // safter to return true here (has allowance) as validator will catch the\n      // missing allowance, so the user won't swap, and they won't pay\n      // unnecessary gas for an approval they may not need.\n\n      return true;\n    }\n\n    return new BigNumber(allowances[swapType === \"swapWithWrap\" ? \"wrapper\" : \"light\"].values[tokenAddress]).div(10 ** ((baseTokenInfo === null || baseTokenInfo === void 0 ? void 0 : baseTokenInfo.decimals) || 18)).gte(baseAmount);\n  };\n\n  const handleSetToken = (type, value) => {\n    const baseRoute = `${appRouteParams.justifiedBaseUrl}/${AppRoutes.swap}`;\n    const {\n      tokenFrom,\n      tokenTo\n    } = getTokenPairs(type, value, quoteToken, baseToken);\n\n    if (type === \"base\") {\n      setBaseAmount(\"\");\n    }\n\n    if (tokenFrom && tokenTo) {\n      dispatch(setUserTokens({\n        tokenFrom,\n        tokenTo\n      }));\n    }\n\n    history.push({\n      pathname: `${baseRoute}/${tokenFrom}/${tokenTo}`\n    });\n  };\n\n  let insufficientBalance = false;\n\n  if (baseAmount && baseToken && Object.keys(balances.values).length) {\n    if (parseFloat(baseAmount) === 0 || baseAmount === \".\") {\n      insufficientBalance = false;\n    } else {\n      const baseDecimals = baseTokenInfo === null || baseTokenInfo === void 0 ? void 0 : baseTokenInfo.decimals;\n\n      if (baseDecimals) {\n        insufficientBalance = new BigNumber(balances.values[baseToken] || \"0\").lt(new BigNumber(baseAmount).multipliedBy(10 ** baseDecimals));\n      }\n    }\n  }\n\n  const handleAddActiveToken = address => {\n    if (library) {\n      dispatch(addActiveToken(address));\n      dispatch(requestActiveTokenBalances({\n        provider: library\n      }));\n      dispatch(requestActiveTokenAllowancesLight({\n        provider: library\n      }));\n      dispatch(requestActiveTokenAllowancesWrapper({\n        provider: library\n      }));\n    }\n  };\n\n  const handleRemoveActiveToken = address => {\n    if (library) {\n      if (address === baseToken) {\n        history.push({\n          pathname: `/${AppRoutes.swap}/-/${quoteToken || \"-\"}`\n        });\n        setBaseAmount(initialBaseAmount);\n      } else if (address === quoteToken) {\n        history.push({\n          pathname: `/${AppRoutes.swap}/${baseToken || \"-\"}/-`\n        });\n      }\n\n      dispatch(removeActiveToken(address));\n      dispatch(requestActiveTokenBalances({\n        provider: library\n      }));\n      dispatch(requestActiveTokenAllowancesLight({\n        provider: library\n      }));\n      dispatch(requestActiveTokenAllowancesWrapper({\n        provider: library\n      }));\n    }\n  };\n\n  const requestQuotes = async () => {\n    if (swapType === \"wrapOrUnwrap\") {\n      // This will re-render with a 1:1 price and a take button.\n      setIsWrapping(true);\n      return;\n    }\n\n    setIsRequestingQuotes(true);\n    const usesWrapper = swapType === \"swapWithWrap\";\n    const weth = wethAddresses[chainId];\n    const eth = nativeETH[chainId];\n\n    const _quoteToken = quoteToken === eth.address ? weth : quoteToken;\n\n    const _baseToken = baseToken === eth.address ? weth : baseToken;\n\n    let rfqServers, lastLookServers;\n\n    try {\n      try {\n        const servers = await new Registry(chainId, // @ts-ignore provider type mismatch\n        library).getServers(_quoteToken, _baseToken, {\n          initializeTimeout: 10 * 1000\n        });\n        rfqServers = servers.filter(s => s.supportsProtocol(\"request-for-quote\"));\n        lastLookServers = servers.filter(s => s.supportsProtocol(\"last-look\"));\n      } catch (e) {\n        console.error(\"Error requesting orders:\", e);\n        throw new Error(\"error requesting orders\");\n      }\n\n      let rfqPromise = null,\n          lastLookPromises = null;\n\n      if (rfqServers.length) {\n        let rfqDispatchResult = dispatch(request({\n          servers: rfqServers,\n          senderToken: _baseToken,\n          senderAmount: baseAmount,\n          signerToken: _quoteToken,\n          senderTokenDecimals: baseTokenInfo.decimals,\n          senderWallet: usesWrapper ? Wrapper.getAddress(chainId) : account\n        }));\n        rfqPromise = rfqDispatchResult.then(result => {\n          return unwrapResult(result);\n        }).then(orders => {\n          if (!orders.length) throw new Error(\"no valid orders\");\n          return orders;\n        });\n      }\n\n      if (lastLookServers.length) {\n        if (usesWrapper) {\n          lastLookServers.forEach(s => s.disconnect());\n        } else {\n          lastLookPromises = LastLook.subscribeAllServers(lastLookServers, {\n            baseToken: baseToken,\n            quoteToken: quoteToken\n          });\n        }\n      }\n\n      let orderPromises = [];\n      if (rfqPromise) orderPromises.push(rfqPromise);\n\n      if (lastLookPromises) {\n        orderPromises = orderPromises.concat(lastLookPromises);\n      } // This promise times out if _no_ orders are received before the timeout\n      // but resolves if _any_ are.\n\n\n      const timeoutOnNoOrdersPromise = Promise.race([Promise.any(orderPromises), new Promise((_, reject) => setTimeout(() => {\n        reject(\"no valid orders\");\n      }, RECEIVE_QUOTE_TIMEOUT_MS))]); // This promise resolves either when all orders are received or X seconds\n      // after the first order is received.\n\n      const waitExtraForAllOrdersPromise = Promise.race([Promise.allSettled(orderPromises), Promise.any(orderPromises).then(() => new Promise(resolve => setTimeout(resolve, ADDITIONAL_QUOTE_BUFFER)))]);\n      await Promise.all([waitExtraForAllOrdersPromise, timeoutOnNoOrdersPromise]);\n    } catch (e) {\n      switch (e.message) {\n        case \"error requesting orders\":\n          {\n            notifyError({\n              heading: t(\"orders.errorRequesting\"),\n              cta: t(\"orders.errorRequestingCta\")\n            });\n            break;\n          }\n\n        default:\n          {\n            console.error(e);\n            setPairUnavailable(true);\n          }\n      }\n    } finally {\n      setIsRequestingQuotes(false);\n    }\n  };\n\n  const takeBestOption = async () => {\n    let order = null;\n\n    try {\n      setIsSwapping(true); // @ts-ignore\n      // TODO: figure out type issues\n\n      const validator = new Validator(chainId, library === null || library === void 0 ? void 0 : library.getSigner());\n\n      if (bestTradeOption.protocol === \"request-for-quote\") {\n        if (swapType !== \"swapWithWrap\") {\n          const errors = await validator.checkSwap(bestTradeOption.order, // NOTE: once new swap contract is used, this (senderAddress) needs\n          // to be the wrapper address for wrapped swaps.\n          account);\n\n          if (errors.length) {\n            setValidatorErrors(errors);\n            setIsSwapping(false);\n            return;\n          }\n        }\n\n        LastLook.unsubscribeAllServers();\n        order = bestTradeOption.order;\n        const result = await dispatch(take({\n          order: bestTradeOption.order,\n          library,\n          contractType: swapType === \"swapWithWrap\" ? \"Wrapper\" : \"Light\",\n          onExpired: () => {\n            notifyError({\n              heading: t(\"orders.swapExpired\"),\n              cta: t(\"orders.swapExpiredCallToAction\")\n            });\n          }\n        }));\n        setIsSwapping(false);\n        await unwrapResult(result);\n        setShowOrderSubmitted(true);\n      } else {\n        // Setting quote amount prevents the UI from updating if pricing changes\n        dispatch(setTradeTermsQuoteAmount(bestTradeOption.quoteAmount)); // Last look order.\n\n        const {\n          order: lastLookOrder,\n          senderWallet\n        } = await LastLook.getSignedOrder({\n          locator: bestTradeOption.pricing.locator,\n          terms: { ...tradeTerms,\n            quoteAmount: bestTradeOption.quoteAmount\n          }\n        });\n        order = lastLookOrder;\n        const errors = await validator.checkSwap(order, senderWallet);\n\n        if (errors.length) {\n          setValidatorErrors(errors);\n          setIsSwapping(false);\n          return;\n        }\n\n        const accepted = await LastLook.sendOrderForConsideration({\n          locator: bestTradeOption.pricing.locator,\n          order: order\n        });\n        setIsSwapping(false);\n\n        if (accepted) {\n          setShowOrderSubmitted(true);\n          LastLook.unsubscribeAllServers();\n        } else {\n          notifyError({\n            heading: t(\"orders.swapRejected\"),\n            cta: t(\"orders.swapRejectedCallToAction\")\n          });\n          dispatch(declineTransaction({\n            signerWallet: order.signerWallet,\n            nonce: order.nonce,\n            reason: \"Pricing expired\"\n          }));\n        }\n      }\n    } catch (e) {\n      if (bestTradeOption.protocol !== \"request-for-quote\") {\n        setIsSwapping(false);\n        dispatch(clearTradeTermsQuoteAmount());\n      }\n\n      if (e.code && e.code === 4001) {// 4001 is metamask user declining transaction sig\n      } else {\n        var _order, _order2;\n\n        notifyError({\n          heading: t(\"orders.swapFailed\"),\n          cta: t(\"orders.swapFailedCallToAction\")\n        });\n        dispatch(revertTransaction({\n          signerWallet: (_order = order) === null || _order === void 0 ? void 0 : _order.signerWallet,\n          nonce: (_order2 = order) === null || _order2 === void 0 ? void 0 : _order2.nonce,\n          reason: e.message\n        }));\n      }\n    }\n  };\n\n  const doWrap = async () => {\n    const method = baseTokenInfo === nativeETH[chainId] ? deposit : withdraw;\n    setIsSwapping(true);\n\n    try {\n      const result = await dispatch(method({\n        chainId: chainId,\n        senderAmount: baseAmount,\n        senderTokenDecimals: baseTokenInfo.decimals,\n        provider: library\n      }));\n      await unwrapResult(result);\n      setIsSwapping(false);\n      setIsWrapping(false);\n      setShowOrderSubmitted(true);\n    } catch (e) {\n      // user cancelled metamask dialog\n      setIsSwapping(false);\n      setIsWrapping(false);\n    }\n  };\n\n  const handleButtonClick = async action => {\n    switch (action) {\n      case ButtonActions.goBack:\n        setIsWrapping(false);\n        setPairUnavailable(false);\n        dispatch(clearTradeTerms());\n        dispatch(clear());\n        unsubscribeFromGasPrice();\n        unsubscribeFromTokenPrice();\n        LastLook.unsubscribeAllServers();\n        break;\n\n      case ButtonActions.restart:\n        setShowOrderSubmitted(false);\n        setValidatorErrors([]);\n        dispatch(clearTradeTerms());\n        dispatch(clear());\n        unsubscribeFromGasPrice();\n        unsubscribeFromTokenPrice();\n        LastLook.unsubscribeAllServers();\n        setBaseAmount(initialBaseAmount);\n        break;\n\n      case ButtonActions.reloadPage:\n        window.location.reload();\n        break;\n\n      case ButtonActions.connectWallet:\n        setShowWalletList(true);\n        break;\n\n      case ButtonActions.switchNetwork:\n        try {\n          window.ethereum.request({\n            method: \"wallet_switchEthereumChain\",\n            params: [{\n              chainId: \"0x1\"\n            }]\n          });\n        } catch (e) {// unable to switch network, but doesn't matter too much as button\n          // looks like a call to action in this case anyway.\n        }\n\n        break;\n\n      case ButtonActions.requestQuotes:\n        dispatch(setTradeTerms({\n          baseToken: {\n            address: baseToken,\n            decimals: baseTokenInfo.decimals\n          },\n          baseAmount: baseAmount,\n          quoteToken: {\n            address: quoteToken,\n            decimals: quoteTokenInfo.decimals\n          },\n          quoteAmount: null,\n          side: \"sell\"\n        }));\n        subscribeToGasPrice();\n        subscribeToTokenPrice(quoteTokenInfo, // @ts-ignore\n        library, chainId);\n        await requestQuotes();\n        break;\n\n      case ButtonActions.approve:\n        setIsApproving(true);\n        await dispatch(approve({\n          token: baseToken,\n          library,\n          contractType: swapType === \"swapWithWrap\" ? \"Wrapper\" : \"Light\",\n          chainId: chainId\n        }));\n        setIsApproving(false);\n        break;\n\n      case ButtonActions.takeQuote:\n        if ([\"swap\", \"swapWithWrap\"].includes(swapType)) {\n          await takeBestOption();\n        } else if (swapType === \"wrapOrUnwrap\") {\n          await doWrap();\n        }\n\n        break;\n\n      case ButtonActions.trackTransaction:\n        onTrackTransactionClicked();\n        break;\n\n      default: // Do nothing.\n\n    }\n  };\n\n  return /*#__PURE__*/_jsxDEV(_Fragment, {\n    children: [/*#__PURE__*/_jsxDEV(StyledSwapWidget, {\n      children: [/*#__PURE__*/_jsxDEV(SwapWidgetHeader, {\n        title: isApproving ? t(\"orders.approve\") : t(\"common.swap\"),\n        isQuote: !isRequestingQuotes && !showOrderSubmitted,\n        onGasFreeTradeButtonClick: () => setShowGasFeeInfo(true),\n        protocol: bestTradeOption === null || bestTradeOption === void 0 ? void 0 : bestTradeOption.protocol,\n        expiry: bestTradeOption === null || bestTradeOption === void 0 ? void 0 : (_bestTradeOption$orde = bestTradeOption.order) === null || _bestTradeOption$orde === void 0 ? void 0 : _bestTradeOption$orde.expiry\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 756,\n        columnNumber: 9\n      }, this), showOrderSubmitted ? /*#__PURE__*/_jsxDEV(HugeTicks, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 764,\n        columnNumber: 11\n      }, this) : isApproving || isSwapping ? /*#__PURE__*/_jsxDEV(_Fragment, {}, void 0, false) : /*#__PURE__*/_jsxDEV(SwapInputs, {\n        baseAmount: baseAmount,\n        onBaseAmountChange: setBaseAmount,\n        baseTokenInfo: baseTokenInfo,\n        quoteTokenInfo: quoteTokenInfo,\n        onChangeTokenClick: setShowTokenSelectModalFor,\n        onMaxButtonClick: () => setBaseAmount(maxAmount || \"0\"),\n        side: \"sell\",\n        tradeNotAllowed: pairUnavailable,\n        isRequesting: isRequestingQuotes // Note that using the quoteAmount from tradeTerms will stop this\n        // updating when the user clicks the take button.\n        ,\n        quoteAmount: quoteAmount,\n        disabled: !active || !!quoteAmount && allowanceFetchFailed,\n        readOnly: !!bestTradeOption || isWrapping || isRequestingQuotes || pairUnavailable || !active,\n        showMaxButton: !!maxAmount && baseAmount !== maxAmount\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 768,\n        columnNumber: 11\n      }, this), /*#__PURE__*/_jsxDEV(InfoContainer, {\n        children: /*#__PURE__*/_jsxDEV(InfoSection, {\n          orderSubmitted: showOrderSubmitted,\n          isConnected: active,\n          isPairUnavailable: pairUnavailable,\n          isFetchingOrders: isRequestingQuotes,\n          isApproving: isApproving,\n          isSwapping: isSwapping,\n          failedToFetchAllowances: allowanceFetchFailed // @ts-ignore\n          ,\n          bestTradeOption: bestTradeOption,\n          requiresApproval: bestRfqOrder && !hasSufficientAllowance(baseToken),\n          baseTokenInfo: baseTokenInfo,\n          baseAmount: baseAmount,\n          quoteTokenInfo: quoteTokenInfo,\n          isWrapping: isWrapping,\n          onFeeButtonClick: () => setProtocolFeeDiscountInfo(true)\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 793,\n          columnNumber: 11\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 792,\n        columnNumber: 9\n      }, this), /*#__PURE__*/_jsxDEV(ButtonContainer, {\n        children: !isApproving && !isSwapping && /*#__PURE__*/_jsxDEV(ActionButtons, {\n          walletIsActive: active,\n          unsupportedNetwork: !!web3Error && web3Error instanceof UnsupportedChainIdError,\n          requiresReload: allowanceFetchFailed,\n          orderComplete: showOrderSubmitted,\n          baseTokenInfo: baseTokenInfo,\n          quoteTokenInfo: quoteTokenInfo,\n          hasAmount: !!baseAmount.length && baseAmount !== \"0\" && baseAmount !== \".\",\n          hasQuote: !isRequestingQuotes && (!!bestTradeOption || isWrapping),\n          hasSufficientBalance: !insufficientBalance,\n          needsApproval: !!baseToken && !hasSufficientAllowance(baseToken),\n          pairUnavailable: pairUnavailable,\n          onButtonClicked: handleButtonClick,\n          isLoading: isConnecting || isRequestingQuotes || [\"approving\", \"taking\"].includes(ordersStatus) || !!baseToken && hasApprovalPending(baseToken),\n          transactionsTabOpen: transactionsTabOpen\n        }, void 0, false, {\n          fileName: _jsxFileName,\n          lineNumber: 815,\n          columnNumber: 13\n        }, this)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 813,\n        columnNumber: 9\n      }, this)]\n    }, void 0, true, {\n      fileName: _jsxFileName,\n      lineNumber: 755,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Overlay, {\n      onCloseButtonClick: () => setShowTokenSelectModalFor(null),\n      isHidden: !showTokenSelectModalFor,\n      children: /*#__PURE__*/_jsxDEV(TokenList, {\n        onSelectToken: newTokenAddress => {\n          // e.g. handleSetToken(\"base\", \"0x123\")\n          handleSetToken(showTokenSelectModalFor, newTokenAddress); // Close the modal\n\n          setShowTokenSelectModalFor(null);\n        },\n        balances: balances,\n        allTokens: allTokens,\n        activeTokens: activeTokens,\n        supportedTokenAddresses: supportedTokens,\n        addActiveToken: handleAddActiveToken,\n        removeActiveToken: handleRemoveActiveToken,\n        chainId: chainId || 1\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 850,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 846,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Overlay, {\n      title: t(\"wallet.selectWallet\"),\n      onCloseButtonClick: () => setShowWalletList(false),\n      isHidden: !showWalletList,\n      children: /*#__PURE__*/_jsxDEV(StyledWalletProviderList, {\n        onClose: () => setShowWalletList(false),\n        onProviderSelected: provider => {\n          dispatch(setActiveProvider(provider.name));\n          setIsConnecting(true);\n          activate(provider.getConnector()).finally(() => setIsConnecting(false));\n        }\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 872,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 867,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Overlay, {\n      title: t(\"validatorErrors.unableSwap\"),\n      subTitle: t(\"validatorErrors.swapFail\"),\n      onCloseButtonClick: () => handleButtonClick(ButtonActions.restart),\n      isHidden: !validatorErrors.length,\n      children: /*#__PURE__*/_jsxDEV(ErrorList, {\n        errors: validatorErrors,\n        handleClick: () => handleButtonClick(ButtonActions.restart)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 889,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 883,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Overlay, {\n      title: t(\"information.gasFreeSwaps.title\"),\n      onCloseButtonClick: () => setShowGasFeeInfo(false),\n      isHidden: !showGasFeeInfo,\n      children: /*#__PURE__*/_jsxDEV(GasFreeSwapsModal, {\n        onCloseButtonClick: () => setShowGasFeeInfo(false)\n      }, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 899,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 894,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Overlay, {\n      title: t(\"information.protocolFeeDiscount.title\"),\n      onCloseButtonClick: () => setProtocolFeeDiscountInfo(false),\n      isHidden: !protocolFeeDiscountInfo,\n      children: /*#__PURE__*/_jsxDEV(ProtocolFeeDiscountModal, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 908,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 903,\n      columnNumber: 7\n    }, this), /*#__PURE__*/_jsxDEV(Overlay, {\n      title: t(\"information.join.title\"),\n      onCloseButtonClick: onInformationModalCloseButtonClick,\n      isHidden: activeInformationModal !== AppRoutes.join,\n      children: /*#__PURE__*/_jsxDEV(JoinModal, {}, void 0, false, {\n        fileName: _jsxFileName,\n        lineNumber: 916,\n        columnNumber: 9\n      }, this)\n    }, void 0, false, {\n      fileName: _jsxFileName,\n      lineNumber: 911,\n      columnNumber: 7\n    }, this)]\n  }, void 0, true);\n};\n\n_s(SwapWidget, \"BNzTDYMOjX5zX9ppiCvo/7mFQCU=\", false, function () {\n  return [useAppDispatch, useHistory, useAppSelector, useAppSelector, useAppSelector, useAppSelector, useAppSelector, useAppSelector, useAppSelector, useAppSelector, useAppSelector, useAppSelector, useAppSelector, useAppRouteParams, useReferencePriceSubscriber, useTranslation, useWeb3React];\n});\n\n_c = SwapWidget;\nexport default SwapWidget;\n\nvar _c;\n\n$RefreshReg$(_c, \"SwapWidget\");","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/components/SwapWidget/SwapWidget.tsx"],"names":["React","useContext","useEffect","useMemo","useState","useTranslation","useHistory","wethAddresses","Registry","Wrapper","findTokensBySymbol","unwrapResult","UnsupportedChainIdError","useWeb3React","BigNumber","formatUnits","useAppDispatch","useAppSelector","ADDITIONAL_QUOTE_BUFFER","RECEIVE_QUOTE_TIMEOUT_MS","nativeETH","LastLookContext","requestActiveTokenAllowancesLight","requestActiveTokenAllowancesWrapper","requestActiveTokenBalances","selectAllowances","selectBalances","addActiveToken","removeActiveToken","selectActiveTokens","selectAllTokenInfo","approve","clear","deposit","request","resetOrders","selectBestOption","selectBestOrder","selectOrdersStatus","take","withdraw","selectAllSupportedTokens","clearTradeTerms","clearTradeTermsQuoteAmount","selectTradeTerms","setTradeTerms","setTradeTermsQuoteAmount","declineTransaction","revertTransaction","selectPendingApprovals","setUserTokens","selectUserTokens","setActiveProvider","Validator","findEthOrTokenByAddress","useAppRouteParams","useReferencePriceSubscriber","AppRoutes","ErrorList","GasFreeSwapsModal","JoinModal","ProtocolFeeDiscountModal","Overlay","notifyError","TokenList","InfoSection","StyledSwapWidget","ButtonContainer","HugeTicks","InfoContainer","StyledWalletProviderList","getTokenPairs","ActionButtons","ButtonActions","SwapInputs","SwapWidgetHeader","initialBaseAmount","SwapWidget","showWalletList","activeInformationModal","setShowWalletList","transactionsTabOpen","onTrackTransactionClicked","onInformationModalCloseButtonClick","dispatch","history","balances","allowances","bestRfqOrder","ordersStatus","bestTradeOption","activeTokens","allTokens","supportedTokens","pendingApprovals","tradeTerms","userTokens","LastLook","appRouteParams","tokenFrom","setTokenFrom","tokenTo","setTokenTo","baseAmount","setBaseAmount","subscribeToGasPrice","subscribeToTokenPrice","unsubscribeFromGasPrice","unsubscribeFromTokenPrice","showOrderSubmitted","setShowOrderSubmitted","showTokenSelectModalFor","setShowTokenSelectModalFor","showGasFeeInfo","setShowGasFeeInfo","protocolFeeDiscountInfo","setProtocolFeeDiscountInfo","isApproving","setIsApproving","isSwapping","setIsSwapping","isWrapping","setIsWrapping","isConnecting","setIsConnecting","isRequestingQuotes","setIsRequestingQuotes","pairUnavailable","setPairUnavailable","validatorErrors","setValidatorErrors","allowanceFetchFailed","setAllowanceFetchFailed","t","chainId","account","library","active","activate","error","web3Error","defaultBaseTokenAddress","length","address","defaultQuoteTokenAddress","baseToken","quoteToken","baseTokenInfo","quoteTokenInfo","maxAmount","values","decimals","unsubscribeAllServers","light","status","wrapper","swapType","eth","weth","includes","quoteAmount","hasApprovalPending","tokenId","undefined","some","tx","tokenAddress","hasSufficientAllowance","div","gte","handleSetToken","type","value","baseRoute","justifiedBaseUrl","swap","push","pathname","insufficientBalance","Object","keys","parseFloat","baseDecimals","lt","multipliedBy","handleAddActiveToken","provider","handleRemoveActiveToken","requestQuotes","usesWrapper","_quoteToken","_baseToken","rfqServers","lastLookServers","servers","getServers","initializeTimeout","filter","s","supportsProtocol","e","console","Error","rfqPromise","lastLookPromises","rfqDispatchResult","senderToken","senderAmount","signerToken","senderTokenDecimals","senderWallet","getAddress","then","result","orders","forEach","disconnect","subscribeAllServers","orderPromises","concat","timeoutOnNoOrdersPromise","Promise","race","any","_","reject","setTimeout","waitExtraForAllOrdersPromise","allSettled","resolve","all","message","heading","cta","takeBestOption","order","validator","getSigner","protocol","errors","checkSwap","contractType","onExpired","lastLookOrder","getSignedOrder","locator","pricing","terms","accepted","sendOrderForConsideration","signerWallet","nonce","reason","code","doWrap","method","handleButtonClick","action","goBack","restart","reloadPage","window","location","reload","connectWallet","switchNetwork","ethereum","params","side","token","takeQuote","trackTransaction","expiry","newTokenAddress","name","getConnector","finally","join"],"mappings":"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","sourcesContent":["import React, { FC, useContext, useEffect, useMemo, useState } from \"react\";\nimport { useTranslation } from \"react-i18next\";\nimport { useHistory } from \"react-router-dom\";\n\nimport { wethAddresses } from \"@airswap/constants\";\nimport { Registry, Wrapper } from \"@airswap/libraries\";\nimport { findTokensBySymbol } from \"@airswap/metadata\";\nimport { LightOrder, Pricing } from \"@airswap/types\";\nimport { Web3Provider } from \"@ethersproject/providers\";\nimport { unwrapResult } from \"@reduxjs/toolkit\";\nimport { UnsupportedChainIdError, useWeb3React } from \"@web3-react/core\";\n\nimport { BigNumber } from \"bignumber.js\";\nimport { formatUnits } from \"ethers/lib/utils\";\n\nimport { useAppDispatch, useAppSelector } from \"../../app/hooks\";\nimport {\n  ADDITIONAL_QUOTE_BUFFER,\n  RECEIVE_QUOTE_TIMEOUT_MS,\n} from \"../../constants/configParams\";\nimport nativeETH from \"../../constants/nativeETH\";\nimport { LastLookContext } from \"../../contexts/lastLook/LastLook\";\nimport {\n  requestActiveTokenAllowancesLight,\n  requestActiveTokenAllowancesWrapper,\n  requestActiveTokenBalances,\n  selectAllowances,\n  selectBalances,\n} from \"../../features/balances/balancesSlice\";\nimport {\n  addActiveToken,\n  removeActiveToken,\n  selectActiveTokens,\n  selectAllTokenInfo,\n} from \"../../features/metadata/metadataSlice\";\nimport {\n  approve,\n  clear,\n  deposit,\n  request,\n  resetOrders,\n  selectBestOption,\n  selectBestOrder,\n  selectOrdersStatus,\n  take,\n  withdraw,\n} from \"../../features/orders/ordersSlice\";\nimport { selectAllSupportedTokens } from \"../../features/registry/registrySlice\";\nimport {\n  clearTradeTerms,\n  clearTradeTermsQuoteAmount,\n  selectTradeTerms,\n  setTradeTerms,\n  setTradeTermsQuoteAmount,\n} from \"../../features/tradeTerms/tradeTermsSlice\";\nimport {\n  declineTransaction,\n  revertTransaction,\n} from \"../../features/transactions/transactionActions\";\nimport {\n  ProtocolType,\n  selectPendingApprovals,\n} from \"../../features/transactions/transactionsSlice\";\nimport {\n  setUserTokens,\n  selectUserTokens,\n} from \"../../features/userSettings/userSettingsSlice\";\nimport { setActiveProvider } from \"../../features/wallet/walletSlice\";\nimport { Validator } from \"../../helpers/Validator\";\nimport findEthOrTokenByAddress from \"../../helpers/findEthOrTokenByAddress\";\nimport useAppRouteParams from \"../../hooks/useAppRouteParams\";\nimport useReferencePriceSubscriber from \"../../hooks/useReferencePriceSubscriber\";\nimport { AppRoutes } from \"../../routes\";\nimport type { Error } from \"../ErrorList/ErrorList\";\nimport { ErrorList } from \"../ErrorList/ErrorList\";\nimport { InformationModalType } from \"../InformationModals/InformationModals\";\nimport GasFreeSwapsModal from \"../InformationModals/subcomponents/GasFreeSwapsModal/GasFreeSwapsModal\";\nimport JoinModal from \"../InformationModals/subcomponents/JoinModal/JoinModal\";\nimport ProtocolFeeDiscountModal from \"../InformationModals/subcomponents/ProtocolFeeDiscountModal/ProtocolFeeDiscountModal\";\nimport Overlay from \"../Overlay/Overlay\";\nimport { notifyError } from \"../Toasts/ToastController\";\nimport TokenList from \"../TokenList/TokenList\";\nimport InfoSection from \"./InfoSection\";\nimport StyledSwapWidget, {\n  ButtonContainer,\n  HugeTicks,\n  InfoContainer,\n  StyledWalletProviderList,\n} from \"./SwapWidget.styles\";\nimport getTokenPairs from \"./helpers/getTokenPairs\";\nimport ActionButtons, {\n  ButtonActions,\n} from \"./subcomponents/ActionButtons/ActionButtons\";\nimport SwapInputs from \"./subcomponents/SwapInputs/SwapInputs\";\nimport SwapWidgetHeader from \"./subcomponents/SwapWidgetHeader/SwapWidgetHeader\";\n\nexport type TokenSelectModalTypes = \"base\" | \"quote\" | null;\ntype SwapType = \"swap\" | \"swapWithWrap\" | \"wrapOrUnwrap\";\n\nconst initialBaseAmount = \"\";\n\ntype SwapWidgetPropsType = {\n  showWalletList: boolean;\n  transactionsTabOpen: boolean;\n  activeInformationModal?: InformationModalType;\n  setShowWalletList: (x: boolean) => void;\n  onTrackTransactionClicked: () => void;\n  onInformationModalCloseButtonClick: () => void;\n};\n\nconst SwapWidget: FC<SwapWidgetPropsType> = ({\n  showWalletList,\n  activeInformationModal,\n  setShowWalletList,\n  transactionsTabOpen,\n  onTrackTransactionClicked,\n  onInformationModalCloseButtonClick,\n}) => {\n  // Redux\n  const dispatch = useAppDispatch();\n  const history = useHistory();\n  const balances = useAppSelector(selectBalances);\n  const allowances = useAppSelector(selectAllowances);\n  const bestRfqOrder = useAppSelector(selectBestOrder);\n  const ordersStatus = useAppSelector(selectOrdersStatus);\n  const bestTradeOption = useAppSelector(selectBestOption);\n  const activeTokens = useAppSelector(selectActiveTokens);\n  const allTokens = useAppSelector(selectAllTokenInfo);\n  const supportedTokens = useAppSelector(selectAllSupportedTokens);\n  const pendingApprovals = useAppSelector(selectPendingApprovals);\n  const tradeTerms = useAppSelector(selectTradeTerms);\n  const userTokens = useAppSelector(selectUserTokens);\n\n  // Contexts\n  const LastLook = useContext(LastLookContext);\n\n  // Input states\n  const appRouteParams = useAppRouteParams();\n  const [tokenFrom, setTokenFrom] = useState<string | undefined>();\n  const [tokenTo, setTokenTo] = useState<string | undefined>();\n  const [baseAmount, setBaseAmount] = useState(initialBaseAmount);\n\n  // Pricing\n  const {\n    subscribeToGasPrice,\n    subscribeToTokenPrice,\n    unsubscribeFromGasPrice,\n    unsubscribeFromTokenPrice,\n  } = useReferencePriceSubscriber();\n\n  // Modals\n  const [showOrderSubmitted, setShowOrderSubmitted] = useState<boolean>(false);\n  const [\n    showTokenSelectModalFor,\n    setShowTokenSelectModalFor,\n  ] = useState<TokenSelectModalTypes | null>(null);\n  const [showGasFeeInfo, setShowGasFeeInfo] = useState(false);\n  const [protocolFeeDiscountInfo, setProtocolFeeDiscountInfo] = useState(false);\n\n  // Loading states\n  const [isApproving, setIsApproving] = useState(false);\n  const [isSwapping, setIsSwapping] = useState(false);\n  const [isWrapping, setIsWrapping] = useState(false);\n  const [isConnecting, setIsConnecting] = useState(false);\n  const [isRequestingQuotes, setIsRequestingQuotes] = useState(false);\n\n  // Error states\n  const [pairUnavailable, setPairUnavailable] = useState(false);\n  const [validatorErrors, setValidatorErrors] = useState<Error[]>([]);\n  const [allowanceFetchFailed, setAllowanceFetchFailed] = useState<boolean>(\n    false\n  );\n\n  const { t } = useTranslation();\n\n  const {\n    chainId,\n    account,\n    library,\n    active,\n    activate,\n    error: web3Error,\n  } = useWeb3React<Web3Provider>();\n\n  const defaultBaseTokenAddress: string | null = allTokens.length\n    ? findTokensBySymbol(\"USDT\", allTokens)[0].address\n    : null;\n  const defaultQuoteTokenAddress: string | null = allTokens.length\n    ? findTokensBySymbol(\"WETH\", allTokens)[0].address\n    : null;\n\n  // Use default tokens only if neither are specified in the URL or store.\n  const baseToken = tokenFrom\n    ? tokenFrom\n    : tokenTo\n    ? null\n    : userTokens.tokenFrom || defaultBaseTokenAddress;\n  const quoteToken = tokenTo\n    ? tokenTo\n    : tokenFrom\n    ? null\n    : userTokens.tokenTo || defaultQuoteTokenAddress;\n\n  const baseTokenInfo = useMemo(\n    () =>\n      baseToken\n        ? findEthOrTokenByAddress(baseToken, activeTokens, chainId!)\n        : null,\n    [baseToken, activeTokens, chainId]\n  );\n\n  const quoteTokenInfo = useMemo(\n    () =>\n      quoteToken\n        ? findEthOrTokenByAddress(quoteToken, activeTokens, chainId!)\n        : null,\n    [quoteToken, activeTokens, chainId]\n  );\n\n  const maxAmount = useMemo(() => {\n    if (\n      !baseToken ||\n      !balances ||\n      !baseTokenInfo ||\n      !balances.values[baseToken] ||\n      balances.values[baseToken] === \"0\"\n    ) {\n      return null;\n    }\n\n    return formatUnits(\n      balances.values[baseToken] || \"0\",\n      baseTokenInfo.decimals\n    );\n  }, [balances, baseToken, baseTokenInfo]);\n\n  useEffect(() => {\n    setAllowanceFetchFailed(false);\n    setBaseAmount(initialBaseAmount);\n    dispatch(clearTradeTerms());\n    unsubscribeFromGasPrice();\n    unsubscribeFromTokenPrice();\n    dispatch(clear());\n    LastLook.unsubscribeAllServers();\n  }, [\n    chainId,\n    dispatch,\n    LastLook,\n    unsubscribeFromGasPrice,\n    unsubscribeFromTokenPrice,\n  ]);\n\n  useEffect(() => {\n    setTokenFrom(appRouteParams.tokenFrom);\n    setTokenTo(appRouteParams.tokenTo);\n  }, [appRouteParams]);\n\n  useEffect(() => {\n    if (ordersStatus === \"reset\") {\n      setIsApproving(false);\n      setIsSwapping(false);\n      setIsWrapping(false);\n      setIsRequestingQuotes(false);\n      setAllowanceFetchFailed(false);\n      setPairUnavailable(false);\n      setProtocolFeeDiscountInfo(false);\n      setShowGasFeeInfo(false);\n      setBaseAmount(initialBaseAmount);\n      LastLook.unsubscribeAllServers();\n    }\n  }, [ordersStatus, LastLook, dispatch]);\n\n  // Reset when the chainId changes.\n  useEffect(() => {\n    if (chainId) {\n      dispatch(resetOrders());\n    }\n  }, [chainId, dispatch]);\n\n  useEffect(() => {\n    setAllowanceFetchFailed(\n      allowances.light.status === \"failed\" ||\n        allowances.wrapper.status === \"failed\"\n    );\n  }, [allowances.light.status, allowances.wrapper.status]);\n\n  let swapType: SwapType = \"swap\";\n\n  if (chainId && baseToken && quoteToken) {\n    const eth = nativeETH[chainId].address;\n    const weth = wethAddresses[chainId];\n    if ([weth, eth].includes(baseToken) && [weth, eth].includes(quoteToken)) {\n      swapType = \"wrapOrUnwrap\";\n    } else if ([quoteToken, baseToken].includes(eth)) {\n      swapType = \"swapWithWrap\";\n    }\n  }\n\n  const quoteAmount =\n    swapType === \"wrapOrUnwrap\"\n      ? baseAmount\n      : tradeTerms.quoteAmount || bestTradeOption?.quoteAmount || \"\";\n\n  const hasApprovalPending = (tokenId: string | undefined) => {\n    if (tokenId === undefined) return false;\n    return pendingApprovals.some((tx) => tx.tokenAddress === tokenId);\n  };\n\n  const hasSufficientAllowance = (tokenAddress: string | undefined) => {\n    if (tokenAddress === nativeETH[chainId || 1].address) return true;\n    if (!tokenAddress) return false;\n    if (\n      allowances[swapType === \"swapWithWrap\" ? \"wrapper\" : \"light\"].values[\n        tokenAddress\n      ] === undefined\n    ) {\n      // We don't currently know what the user's allowance is, this is an error\n      // state we shouldn't repeatedly hit, so we'll prompt a reload.\n      if (!allowanceFetchFailed) setAllowanceFetchFailed(true);\n      // safter to return true here (has allowance) as validator will catch the\n      // missing allowance, so the user won't swap, and they won't pay\n      // unnecessary gas for an approval they may not need.\n      return true;\n    }\n    return new BigNumber(\n      allowances[swapType === \"swapWithWrap\" ? \"wrapper\" : \"light\"].values[\n        tokenAddress\n      ]!\n    )\n      .div(10 ** (baseTokenInfo?.decimals || 18))\n      .gte(baseAmount);\n  };\n\n  const handleSetToken = (type: TokenSelectModalTypes, value: string) => {\n    const baseRoute = `${appRouteParams.justifiedBaseUrl}/${AppRoutes.swap}`;\n    const { tokenFrom, tokenTo } = getTokenPairs(\n      type,\n      value,\n      quoteToken,\n      baseToken\n    );\n\n    if (type === \"base\") {\n      setBaseAmount(\"\");\n    }\n\n    if (tokenFrom && tokenTo) {\n      dispatch(setUserTokens({ tokenFrom, tokenTo }));\n    }\n    history.push({\n      pathname: `${baseRoute}/${tokenFrom}/${tokenTo}`,\n    });\n  };\n\n  let insufficientBalance: boolean = false;\n  if (baseAmount && baseToken && Object.keys(balances.values).length) {\n    if (parseFloat(baseAmount) === 0 || baseAmount === \".\") {\n      insufficientBalance = false;\n    } else {\n      const baseDecimals = baseTokenInfo?.decimals;\n      if (baseDecimals) {\n        insufficientBalance = new BigNumber(\n          balances.values[baseToken!] || \"0\"\n        ).lt(new BigNumber(baseAmount).multipliedBy(10 ** baseDecimals));\n      }\n    }\n  }\n\n  const handleAddActiveToken = (address: string) => {\n    if (library) {\n      dispatch(addActiveToken(address));\n      dispatch(requestActiveTokenBalances({ provider: library! }));\n      dispatch(requestActiveTokenAllowancesLight({ provider: library! }));\n      dispatch(requestActiveTokenAllowancesWrapper({ provider: library! }));\n    }\n  };\n\n  const handleRemoveActiveToken = (address: string) => {\n    if (library) {\n      if (address === baseToken) {\n        history.push({ pathname: `/${AppRoutes.swap}/-/${quoteToken || \"-\"}` });\n        setBaseAmount(initialBaseAmount);\n      } else if (address === quoteToken) {\n        history.push({ pathname: `/${AppRoutes.swap}/${baseToken || \"-\"}/-` });\n      }\n      dispatch(removeActiveToken(address));\n      dispatch(requestActiveTokenBalances({ provider: library! }));\n      dispatch(requestActiveTokenAllowancesLight({ provider: library! }));\n      dispatch(requestActiveTokenAllowancesWrapper({ provider: library! }));\n    }\n  };\n\n  const requestQuotes = async () => {\n    if (swapType === \"wrapOrUnwrap\") {\n      // This will re-render with a 1:1 price and a take button.\n      setIsWrapping(true);\n      return;\n    }\n    setIsRequestingQuotes(true);\n\n    const usesWrapper = swapType === \"swapWithWrap\";\n    const weth = wethAddresses[chainId!];\n    const eth = nativeETH[chainId!];\n    const _quoteToken = quoteToken === eth.address ? weth : quoteToken!;\n    const _baseToken = baseToken === eth.address ? weth : baseToken!;\n\n    let rfqServers, lastLookServers;\n    try {\n      try {\n        const servers = await new Registry(\n          chainId,\n          // @ts-ignore provider type mismatch\n          library\n        ).getServers(_quoteToken, _baseToken, {\n          initializeTimeout: 10 * 1000,\n        });\n\n        rfqServers = servers.filter((s) =>\n          s.supportsProtocol(\"request-for-quote\")\n        );\n\n        lastLookServers = servers.filter((s) =>\n          s.supportsProtocol(\"last-look\")\n        );\n      } catch (e) {\n        console.error(\"Error requesting orders:\", e);\n        throw new Error(\"error requesting orders\");\n      }\n\n      let rfqPromise: Promise<LightOrder[]> | null = null,\n        lastLookPromises: Promise<Pricing>[] | null = null;\n\n      if (rfqServers.length) {\n        let rfqDispatchResult = dispatch(\n          request({\n            servers: rfqServers,\n            senderToken: _baseToken,\n            senderAmount: baseAmount,\n            signerToken: _quoteToken,\n            senderTokenDecimals: baseTokenInfo!.decimals,\n            senderWallet: usesWrapper ? Wrapper.getAddress(chainId) : account!,\n          })\n        );\n        rfqPromise = rfqDispatchResult\n          .then((result) => {\n            return unwrapResult(result);\n          })\n          .then((orders) => {\n            if (!orders.length) throw new Error(\"no valid orders\");\n            return orders;\n          });\n      }\n\n      if (lastLookServers.length) {\n        if (usesWrapper) {\n          lastLookServers.forEach((s) => s.disconnect());\n        } else {\n          lastLookPromises = LastLook.subscribeAllServers(lastLookServers, {\n            baseToken: baseToken!,\n            quoteToken: quoteToken!,\n          });\n        }\n      }\n\n      let orderPromises: Promise<LightOrder[] | Pricing>[] = [];\n      if (rfqPromise) orderPromises.push(rfqPromise);\n      if (lastLookPromises) {\n        orderPromises = orderPromises.concat(lastLookPromises);\n      }\n\n      // This promise times out if _no_ orders are received before the timeout\n      // but resolves if _any_ are.\n      const timeoutOnNoOrdersPromise = Promise.race<any>([\n        Promise.any(orderPromises),\n        new Promise((_, reject) =>\n          setTimeout(() => {\n            reject(\"no valid orders\");\n          }, RECEIVE_QUOTE_TIMEOUT_MS)\n        ),\n      ]);\n\n      // This promise resolves either when all orders are received or X seconds\n      // after the first order is received.\n      const waitExtraForAllOrdersPromise = Promise.race<any>([\n        Promise.allSettled(orderPromises),\n        Promise.any(orderPromises).then(\n          () =>\n            new Promise((resolve) =>\n              setTimeout(resolve, ADDITIONAL_QUOTE_BUFFER)\n            )\n        ),\n      ]);\n\n      await Promise.all([\n        waitExtraForAllOrdersPromise,\n        timeoutOnNoOrdersPromise,\n      ]);\n    } catch (e: any) {\n      switch (e.message) {\n        case \"error requesting orders\": {\n          notifyError({\n            heading: t(\"orders.errorRequesting\"),\n            cta: t(\"orders.errorRequestingCta\"),\n          });\n          break;\n        }\n\n        default: {\n          console.error(e);\n          setPairUnavailable(true);\n        }\n      }\n    } finally {\n      setIsRequestingQuotes(false);\n    }\n  };\n\n  const takeBestOption = async () => {\n    let order: LightOrder | null = null;\n    try {\n      setIsSwapping(true);\n      // @ts-ignore\n      // TODO: figure out type issues\n      const validator = new Validator(chainId, library?.getSigner());\n      if (bestTradeOption!.protocol === \"request-for-quote\") {\n        if (swapType !== \"swapWithWrap\") {\n          const errors = (await validator.checkSwap(\n            bestTradeOption!.order!,\n            // NOTE: once new swap contract is used, this (senderAddress) needs\n            // to be the wrapper address for wrapped swaps.\n            account!\n          )) as Error[];\n          if (errors.length) {\n            setValidatorErrors(errors);\n            setIsSwapping(false);\n            return;\n          }\n        }\n        LastLook.unsubscribeAllServers();\n        order = bestTradeOption!.order!;\n        const result = await dispatch(\n          take({\n            order: bestTradeOption!.order!,\n            library,\n            contractType: swapType === \"swapWithWrap\" ? \"Wrapper\" : \"Light\",\n            onExpired: () => {\n              notifyError({\n                heading: t(\"orders.swapExpired\"),\n                cta: t(\"orders.swapExpiredCallToAction\"),\n              });\n            },\n          })\n        );\n        setIsSwapping(false);\n        await unwrapResult(result);\n        setShowOrderSubmitted(true);\n      } else {\n        // Setting quote amount prevents the UI from updating if pricing changes\n        dispatch(setTradeTermsQuoteAmount(bestTradeOption!.quoteAmount));\n        // Last look order.\n        const {\n          order: lastLookOrder,\n          senderWallet,\n        } = await LastLook.getSignedOrder({\n          locator: bestTradeOption!.pricing!.locator,\n          terms: { ...tradeTerms, quoteAmount: bestTradeOption!.quoteAmount },\n        });\n        order = lastLookOrder;\n        const errors = (await validator.checkSwap(\n          order,\n          senderWallet\n        )) as Error[];\n        if (errors.length) {\n          setValidatorErrors(errors);\n          setIsSwapping(false);\n          return;\n        }\n        const accepted = await LastLook.sendOrderForConsideration({\n          locator: bestTradeOption!.pricing!.locator,\n          order: order,\n        });\n        setIsSwapping(false);\n        if (accepted) {\n          setShowOrderSubmitted(true);\n          LastLook.unsubscribeAllServers();\n        } else {\n          notifyError({\n            heading: t(\"orders.swapRejected\"),\n            cta: t(\"orders.swapRejectedCallToAction\"),\n          });\n\n          dispatch(\n            declineTransaction({\n              signerWallet: order.signerWallet,\n              nonce: order.nonce,\n              reason: \"Pricing expired\",\n            })\n          );\n        }\n      }\n    } catch (e: any) {\n      if (bestTradeOption!.protocol !== \"request-for-quote\") {\n        setIsSwapping(false);\n        dispatch(clearTradeTermsQuoteAmount());\n      }\n\n      if (e.code && e.code === 4001) {\n        // 4001 is metamask user declining transaction sig\n      } else {\n        notifyError({\n          heading: t(\"orders.swapFailed\"),\n          cta: t(\"orders.swapFailedCallToAction\"),\n        });\n\n        dispatch(\n          revertTransaction({\n            signerWallet: order?.signerWallet,\n            nonce: order?.nonce,\n            reason: e.message,\n          })\n        );\n      }\n    }\n  };\n\n  const doWrap = async () => {\n    const method = baseTokenInfo === nativeETH[chainId!] ? deposit : withdraw;\n    setIsSwapping(true);\n    try {\n      const result = await dispatch(\n        method({\n          chainId: chainId!,\n          senderAmount: baseAmount,\n          senderTokenDecimals: baseTokenInfo!.decimals,\n          provider: library!,\n        })\n      );\n      await unwrapResult(result);\n      setIsSwapping(false);\n      setIsWrapping(false);\n      setShowOrderSubmitted(true);\n    } catch (e) {\n      // user cancelled metamask dialog\n      setIsSwapping(false);\n      setIsWrapping(false);\n    }\n  };\n\n  const handleButtonClick = async (action: ButtonActions) => {\n    switch (action) {\n      case ButtonActions.goBack:\n        setIsWrapping(false);\n        setPairUnavailable(false);\n        dispatch(clearTradeTerms());\n        dispatch(clear());\n        unsubscribeFromGasPrice();\n        unsubscribeFromTokenPrice();\n        LastLook.unsubscribeAllServers();\n        break;\n\n      case ButtonActions.restart:\n        setShowOrderSubmitted(false);\n        setValidatorErrors([]);\n        dispatch(clearTradeTerms());\n        dispatch(clear());\n        unsubscribeFromGasPrice();\n        unsubscribeFromTokenPrice();\n        LastLook.unsubscribeAllServers();\n        setBaseAmount(initialBaseAmount);\n        break;\n\n      case ButtonActions.reloadPage:\n        window.location.reload();\n        break;\n\n      case ButtonActions.connectWallet:\n        setShowWalletList(true);\n        break;\n\n      case ButtonActions.switchNetwork:\n        try {\n          (window as any).ethereum.request!({\n            method: \"wallet_switchEthereumChain\",\n            params: [\n              {\n                chainId: \"0x1\",\n              },\n            ],\n          });\n        } catch (e) {\n          // unable to switch network, but doesn't matter too much as button\n          // looks like a call to action in this case anyway.\n        }\n        break;\n\n      case ButtonActions.requestQuotes:\n        dispatch(\n          setTradeTerms({\n            baseToken: {\n              address: baseToken!,\n              decimals: baseTokenInfo!.decimals,\n            },\n            baseAmount: baseAmount,\n            quoteToken: {\n              address: quoteToken!,\n              decimals: quoteTokenInfo!.decimals,\n            },\n            quoteAmount: null,\n            side: \"sell\",\n          })\n        );\n        subscribeToGasPrice();\n        subscribeToTokenPrice(\n          quoteTokenInfo!,\n          // @ts-ignore\n          library!,\n          chainId\n        );\n        await requestQuotes();\n\n        break;\n\n      case ButtonActions.approve:\n        setIsApproving(true);\n        await dispatch(\n          approve({\n            token: baseToken!,\n            library,\n            contractType: swapType === \"swapWithWrap\" ? \"Wrapper\" : \"Light\",\n            chainId: chainId!,\n          })\n        );\n        setIsApproving(false);\n        break;\n\n      case ButtonActions.takeQuote:\n        if ([\"swap\", \"swapWithWrap\"].includes(swapType)) {\n          await takeBestOption();\n        } else if (swapType === \"wrapOrUnwrap\") {\n          await doWrap();\n        }\n        break;\n\n      case ButtonActions.trackTransaction:\n        onTrackTransactionClicked();\n        break;\n\n      default:\n      // Do nothing.\n    }\n  };\n\n  return (\n    <>\n      <StyledSwapWidget>\n        <SwapWidgetHeader\n          title={isApproving ? t(\"orders.approve\") : t(\"common.swap\")}\n          isQuote={!isRequestingQuotes && !showOrderSubmitted}\n          onGasFreeTradeButtonClick={() => setShowGasFeeInfo(true)}\n          protocol={bestTradeOption?.protocol as ProtocolType}\n          expiry={bestTradeOption?.order?.expiry}\n        />\n        {showOrderSubmitted ? (\n          <HugeTicks />\n        ) : isApproving || isSwapping ? (\n          <></>\n        ) : (\n          <SwapInputs\n            baseAmount={baseAmount}\n            onBaseAmountChange={setBaseAmount}\n            baseTokenInfo={baseTokenInfo}\n            quoteTokenInfo={quoteTokenInfo}\n            onChangeTokenClick={setShowTokenSelectModalFor}\n            onMaxButtonClick={() => setBaseAmount(maxAmount || \"0\")}\n            side=\"sell\"\n            tradeNotAllowed={pairUnavailable}\n            isRequesting={isRequestingQuotes}\n            // Note that using the quoteAmount from tradeTerms will stop this\n            // updating when the user clicks the take button.\n            quoteAmount={quoteAmount}\n            disabled={!active || (!!quoteAmount && allowanceFetchFailed)}\n            readOnly={\n              !!bestTradeOption ||\n              isWrapping ||\n              isRequestingQuotes ||\n              pairUnavailable ||\n              !active\n            }\n            showMaxButton={!!maxAmount && baseAmount !== maxAmount}\n          />\n        )}\n        <InfoContainer>\n          <InfoSection\n            orderSubmitted={showOrderSubmitted}\n            isConnected={active}\n            isPairUnavailable={pairUnavailable}\n            isFetchingOrders={isRequestingQuotes}\n            isApproving={isApproving}\n            isSwapping={isSwapping}\n            failedToFetchAllowances={allowanceFetchFailed}\n            // @ts-ignore\n            bestTradeOption={bestTradeOption}\n            requiresApproval={\n              bestRfqOrder && !hasSufficientAllowance(baseToken!)\n            }\n            baseTokenInfo={baseTokenInfo}\n            baseAmount={baseAmount}\n            quoteTokenInfo={quoteTokenInfo}\n            isWrapping={isWrapping}\n            onFeeButtonClick={() => setProtocolFeeDiscountInfo(true)}\n          />\n        </InfoContainer>\n        <ButtonContainer>\n          {!isApproving && !isSwapping && (\n            <ActionButtons\n              walletIsActive={active}\n              unsupportedNetwork={\n                !!web3Error && web3Error instanceof UnsupportedChainIdError\n              }\n              requiresReload={allowanceFetchFailed}\n              orderComplete={showOrderSubmitted}\n              baseTokenInfo={baseTokenInfo}\n              quoteTokenInfo={quoteTokenInfo}\n              hasAmount={\n                !!baseAmount.length && baseAmount !== \"0\" && baseAmount !== \".\"\n              }\n              hasQuote={\n                !isRequestingQuotes && (!!bestTradeOption || isWrapping)\n              }\n              hasSufficientBalance={!insufficientBalance}\n              needsApproval={!!baseToken && !hasSufficientAllowance(baseToken)}\n              pairUnavailable={pairUnavailable}\n              onButtonClicked={handleButtonClick}\n              isLoading={\n                isConnecting ||\n                isRequestingQuotes ||\n                [\"approving\", \"taking\"].includes(ordersStatus) ||\n                (!!baseToken && hasApprovalPending(baseToken))\n              }\n              transactionsTabOpen={transactionsTabOpen}\n            />\n          )}\n        </ButtonContainer>\n      </StyledSwapWidget>\n\n      <Overlay\n        onCloseButtonClick={() => setShowTokenSelectModalFor(null)}\n        isHidden={!showTokenSelectModalFor}\n      >\n        <TokenList\n          onSelectToken={(newTokenAddress) => {\n            // e.g. handleSetToken(\"base\", \"0x123\")\n            handleSetToken(showTokenSelectModalFor, newTokenAddress);\n            // Close the modal\n            setShowTokenSelectModalFor(null);\n          }}\n          balances={balances}\n          allTokens={allTokens}\n          activeTokens={activeTokens}\n          supportedTokenAddresses={supportedTokens}\n          addActiveToken={handleAddActiveToken}\n          removeActiveToken={handleRemoveActiveToken}\n          chainId={chainId || 1}\n        />\n      </Overlay>\n\n      <Overlay\n        title={t(\"wallet.selectWallet\")}\n        onCloseButtonClick={() => setShowWalletList(false)}\n        isHidden={!showWalletList}\n      >\n        <StyledWalletProviderList\n          onClose={() => setShowWalletList(false)}\n          onProviderSelected={(provider) => {\n            dispatch(setActiveProvider(provider.name));\n            setIsConnecting(true);\n            activate(provider.getConnector()).finally(() =>\n              setIsConnecting(false)\n            );\n          }}\n        />\n      </Overlay>\n      <Overlay\n        title={t(\"validatorErrors.unableSwap\")}\n        subTitle={t(\"validatorErrors.swapFail\")}\n        onCloseButtonClick={() => handleButtonClick(ButtonActions.restart)}\n        isHidden={!validatorErrors.length}\n      >\n        <ErrorList\n          errors={validatorErrors}\n          handleClick={() => handleButtonClick(ButtonActions.restart)}\n        />\n      </Overlay>\n      <Overlay\n        title={t(\"information.gasFreeSwaps.title\")}\n        onCloseButtonClick={() => setShowGasFeeInfo(false)}\n        isHidden={!showGasFeeInfo}\n      >\n        <GasFreeSwapsModal\n          onCloseButtonClick={() => setShowGasFeeInfo(false)}\n        />\n      </Overlay>\n      <Overlay\n        title={t(\"information.protocolFeeDiscount.title\")}\n        onCloseButtonClick={() => setProtocolFeeDiscountInfo(false)}\n        isHidden={!protocolFeeDiscountInfo}\n      >\n        <ProtocolFeeDiscountModal />\n      </Overlay>\n\n      <Overlay\n        title={t(\"information.join.title\")}\n        onCloseButtonClick={onInformationModalCloseButtonClick}\n        isHidden={activeInformationModal !== AppRoutes.join}\n      >\n        <JoinModal />\n      </Overlay>\n    </>\n  );\n};\n\nexport default SwapWidget;\n"]},"metadata":{},"sourceType":"module"}