{"ast":null,"code":"import { fetchTokens, scrapeToken } from \"@airswap/metadata\";\nimport uniqBy from \"lodash.uniqby\";\nconst tokensCache = {};\nexport const getActiveTokensLocalStorageKey = (account, chainId) => `airswap/activeTokens/${account}/${chainId}`;\nexport const getCachedMetadataLocalStorageKey = chainId => `airswap/metadataCache/${chainId}`;\nexport const getAllTokens = async chainId => {\n  let tokens;\n\n  if (!tokensCache[chainId]) {\n    tokensCache[chainId] = (await fetchTokens(chainId)).tokens; //TODO: handle failure here, need to decide what to do with errors\n  }\n\n  tokens = tokensCache[chainId];\n  return tokens;\n};\nexport const getUnknownTokens = async (chainId, supportedTokenAddresses, allTokens, provider) => {\n  const storageKey = getCachedMetadataLocalStorageKey(chainId); // Get a list of all token addresses from token lists\n\n  const uniqueTokenListAddresses = uniqBy(allTokens, t => t.address).map(t => t.address); // Get any tokens we've previously manually looked up from cache\n\n  let localStorageTokens = [];\n  const localStorageData = localStorage.getItem(storageKey);\n\n  if (localStorageData) {\n    try {\n      localStorageTokens = JSON.parse(localStorageData).filter( // This filter ensures we don't continue to store tokens that become\n      // unsupported or contained in token lists.\n      t => !uniqueTokenListAddresses.includes(t.address) && supportedTokenAddresses.includes(t.address));\n    } catch (e) {\n      localStorage.removeItem(storageKey);\n    }\n  }\n\n  const localStorageTokenAddresses = localStorageTokens.map(t => t.address);\n  const knownTokens = uniqueTokenListAddresses.concat(localStorageTokenAddresses); // Determine tokens we still don't know about.\n\n  const unknownTokens = supportedTokenAddresses.filter(supportedTokenAddr => !knownTokens.includes(supportedTokenAddr));\n  let scrapedTokens = [];\n\n  if (unknownTokens.length) {\n    // @ts-ignore provider type mismatch w/ metadata repo\n    const scrapePromises = unknownTokens.map(t => scrapeToken(t, provider));\n    const results = await Promise.allSettled(scrapePromises);\n    scrapedTokens = results.filter(r => r.status === \"fulfilled\").map(r => {\n      const tokenInfo = r.value;\n      return { ...tokenInfo,\n        address: tokenInfo.address.toLowerCase()\n      };\n    });\n  }\n\n  localStorageTokens = localStorageTokens.concat(scrapedTokens);\n  localStorage.setItem(storageKey, JSON.stringify(localStorageTokens));\n  return localStorageTokens;\n};\nexport const getActiveTokensFromLocalStorage = (account, chainId) => {\n  const savedTokens = (localStorage.getItem(getActiveTokensLocalStorageKey(account, chainId)) || \"\").split(\",\").filter(address => address.length);\n  return savedTokens.length && savedTokens || [];\n};\nexport const getSavedActiveTokensInfo = async (account, chainId) => {\n  const tokens = await getAllTokens(chainId);\n  const activeTokens = getActiveTokensFromLocalStorage(account, chainId);\n  const matchingTokens = tokens.filter(tokenInfo => activeTokens.includes(tokenInfo.address));\n  return uniqBy(matchingTokens, token => token.address);\n};\nexport const getTransactionsLocalStorageKey = (walletAddress, chainId) => `airswap/transactions/${walletAddress}/${chainId}`;","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/features/metadata/metadataApi.ts"],"names":["fetchTokens","scrapeToken","uniqBy","tokensCache","getActiveTokensLocalStorageKey","account","chainId","getCachedMetadataLocalStorageKey","getAllTokens","tokens","getUnknownTokens","supportedTokenAddresses","allTokens","provider","storageKey","uniqueTokenListAddresses","t","address","map","localStorageTokens","localStorageData","localStorage","getItem","JSON","parse","filter","includes","e","removeItem","localStorageTokenAddresses","knownTokens","concat","unknownTokens","supportedTokenAddr","scrapedTokens","length","scrapePromises","results","Promise","allSettled","r","status","tokenInfo","value","toLowerCase","setItem","stringify","getActiveTokensFromLocalStorage","savedTokens","split","getSavedActiveTokensInfo","activeTokens","matchingTokens","token","getTransactionsLocalStorageKey","walletAddress"],"mappings":"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","sourcesContent":["import { fetchTokens, scrapeToken } from \"@airswap/metadata\";\nimport { TokenInfo } from \"@airswap/types\";\n\nimport { providers } from \"ethers\";\nimport uniqBy from \"lodash.uniqby\";\n\nconst tokensCache: {\n  [chainId: number]: TokenInfo[];\n} = {};\n\nexport const getActiveTokensLocalStorageKey: (\n  account: string,\n  chainId: number\n) => string = (account, chainId) =>\n  `airswap/activeTokens/${account}/${chainId}`;\n\nexport const getCachedMetadataLocalStorageKey = (chainId: number): string =>\n  `airswap/metadataCache/${chainId}`;\n\nexport const getAllTokens = async (chainId: number) => {\n  let tokens;\n  if (!tokensCache[chainId]) {\n    tokensCache[chainId] = (await fetchTokens(chainId)).tokens;\n    //TODO: handle failure here, need to decide what to do with errors\n  }\n  tokens = tokensCache[chainId];\n  return tokens;\n};\n\nexport const getUnknownTokens = async (\n  chainId: number,\n  supportedTokenAddresses: string[],\n  allTokens: TokenInfo[],\n  provider: providers.Provider\n): Promise<TokenInfo[]> => {\n  const storageKey = getCachedMetadataLocalStorageKey(chainId);\n  // Get a list of all token addresses from token lists\n  const uniqueTokenListAddresses = uniqBy(allTokens, (t) => t.address).map(\n    (t) => t.address\n  );\n\n  // Get any tokens we've previously manually looked up from cache\n  let localStorageTokens: TokenInfo[] = [];\n  const localStorageData = localStorage.getItem(storageKey);\n  if (localStorageData) {\n    try {\n      localStorageTokens = (JSON.parse(localStorageData) as TokenInfo[]).filter(\n        // This filter ensures we don't continue to store tokens that become\n        // unsupported or contained in token lists.\n        (t) =>\n          !uniqueTokenListAddresses.includes(t.address) &&\n          supportedTokenAddresses.includes(t.address)\n      );\n    } catch (e) {\n      localStorage.removeItem(storageKey);\n    }\n  }\n\n  const localStorageTokenAddresses = localStorageTokens.map((t) => t.address);\n  const knownTokens = uniqueTokenListAddresses.concat(\n    localStorageTokenAddresses\n  );\n\n  // Determine tokens we still don't know about.\n  const unknownTokens = supportedTokenAddresses.filter(\n    (supportedTokenAddr) => !knownTokens.includes(supportedTokenAddr)\n  );\n\n  let scrapedTokens: TokenInfo[] = [];\n  if (unknownTokens.length) {\n    // @ts-ignore provider type mismatch w/ metadata repo\n    const scrapePromises = unknownTokens.map((t) => scrapeToken(t, provider));\n    const results = await Promise.allSettled(scrapePromises);\n    scrapedTokens = results\n      .filter((r) => r.status === \"fulfilled\")\n      .map((r) => {\n        const tokenInfo = (r as PromiseFulfilledResult<TokenInfo>).value;\n        return {\n          ...tokenInfo,\n          address: tokenInfo.address.toLowerCase(),\n        };\n      });\n  }\n\n  localStorageTokens = localStorageTokens.concat(scrapedTokens);\n  localStorage.setItem(storageKey, JSON.stringify(localStorageTokens));\n\n  return localStorageTokens;\n};\n\nexport const getActiveTokensFromLocalStorage = (\n  account: string,\n  chainId: number\n) => {\n  const savedTokens = (\n    localStorage.getItem(getActiveTokensLocalStorageKey(account, chainId)) || \"\"\n  )\n    .split(\",\")\n    .filter((address) => address.length);\n  return (savedTokens.length && savedTokens) || [];\n};\n\nexport const getSavedActiveTokensInfo = async (\n  account: string,\n  chainId: number\n) => {\n  const tokens = await getAllTokens(chainId);\n  const activeTokens = getActiveTokensFromLocalStorage(account, chainId);\n  const matchingTokens = tokens.filter((tokenInfo) =>\n    activeTokens.includes(tokenInfo.address)\n  );\n  return uniqBy(matchingTokens, (token) => token.address);\n};\n\nexport const getTransactionsLocalStorageKey: (\n  walletAddress: string,\n  chainId: number\n) => string = (walletAddress, chainId) =>\n  `airswap/transactions/${walletAddress}/${chainId}`;\n"]},"metadata":{},"sourceType":"module"}