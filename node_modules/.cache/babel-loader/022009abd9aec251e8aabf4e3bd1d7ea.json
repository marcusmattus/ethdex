{"ast":null,"code":"import * as RegistryContract from \"@airswap/registry/build/contracts/Registry.sol/Registry.json\";\nimport registryDeploys from \"@airswap/registry/deploys.js\";\nimport { utils, Contract } from \"ethers\";\nconst RegistryInterface = new utils.Interface(JSON.stringify(RegistryContract.abi));\n\nasync function getStakerTokens(chainId, provider) {\n  const registryContract = new Contract(registryDeploys[chainId], RegistryInterface, provider);\n  const addTokensEventFilter = registryContract.filters.AddTokens();\n  const removeTokensEventFilter = registryContract.filters.RemoveTokens(); // Fetch all AddTokens and RemoveTokens events from the registry\n\n  const [addEvents, removeEvents] = await Promise.all([registryContract.queryFilter(addTokensEventFilter), registryContract.queryFilter(removeTokensEventFilter)]); // Order matters here, so order AddTokens and RemoveTokens chronologically\n\n  const sortedEvents = [...addEvents, ...removeEvents].filter(log => !log.removed).sort((a, b) => {\n    // Sort by oldest first. If they're not in the same block, sort based\n    // on blocknumber\n    if (a.blockNumber !== b.blockNumber) return a.blockNumber - b.blockNumber; // if in the same block, sort by the index of the log in the block\n\n    return a.logIndex - b.logIndex;\n  }); // Hold a list of tokens for each staker.\n\n  const stakerTokens = {};\n  sortedEvents.forEach(log => {\n    if (!log.args) return; // @ts-ignore (args are not typed)\n\n    const [staker, tokens] = log.args;\n    const lowerCasedTokens = tokens.map(t => t.toLowerCase());\n\n    if (log.event === \"AddTokens\") {\n      // Adding tokens\n      stakerTokens[staker] = (stakerTokens[staker] || []).concat(lowerCasedTokens);\n    } else {\n      // Removing tokens\n      stakerTokens[staker] = (stakerTokens[staker] || []).filter(token => !lowerCasedTokens.includes(token));\n    }\n  });\n  return stakerTokens;\n}\n\nexport { getStakerTokens };","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/src/features/registry/registryApi.ts"],"names":["RegistryContract","registryDeploys","utils","Contract","RegistryInterface","Interface","JSON","stringify","abi","getStakerTokens","chainId","provider","registryContract","addTokensEventFilter","filters","AddTokens","removeTokensEventFilter","RemoveTokens","addEvents","removeEvents","Promise","all","queryFilter","sortedEvents","filter","log","removed","sort","a","b","blockNumber","logIndex","stakerTokens","forEach","args","staker","tokens","lowerCasedTokens","map","t","toLowerCase","event","concat","token","includes"],"mappings":"AAAA,OAAO,KAAKA,gBAAZ,MAAkC,8DAAlC;AACA,OAAOC,eAAP,MAA4B,8BAA5B;AAEA,SAAoBC,KAApB,EAA2BC,QAA3B,QAAkD,QAAlD;AAEA,MAAMC,iBAAiB,GAAG,IAAIF,KAAK,CAACG,SAAV,CACxBC,IAAI,CAACC,SAAL,CAAeP,gBAAgB,CAACQ,GAAhC,CADwB,CAA1B;;AAIA,eAAeC,eAAf,CAA+BC,OAA/B,EAAgDC,QAAhD,EAA8E;AAC5E,QAAMC,gBAAgB,GAAG,IAAIT,QAAJ,CACvBF,eAAe,CAACS,OAAD,CADQ,EAEvBN,iBAFuB,EAGvBO,QAHuB,CAAzB;AAMA,QAAME,oBAAoB,GAAGD,gBAAgB,CAACE,OAAjB,CAAyBC,SAAzB,EAA7B;AACA,QAAMC,uBAAuB,GAAGJ,gBAAgB,CAACE,OAAjB,CAAyBG,YAAzB,EAAhC,CAR4E,CAU5E;;AACA,QAAM,CAACC,SAAD,EAAYC,YAAZ,IAA4B,MAAMC,OAAO,CAACC,GAAR,CAAY,CAClDT,gBAAgB,CAACU,WAAjB,CAA6BT,oBAA7B,CADkD,EAElDD,gBAAgB,CAACU,WAAjB,CAA6BN,uBAA7B,CAFkD,CAAZ,CAAxC,CAX4E,CAgB5E;;AACA,QAAMO,YAAqB,GAAG,CAAC,GAAGL,SAAJ,EAAe,GAAGC,YAAlB,EAC3BK,MAD2B,CACnBC,GAAD,IAAS,CAACA,GAAG,CAACC,OADM,EAE3BC,IAF2B,CAEtB,CAACC,CAAD,EAAIC,CAAJ,KAAU;AACd;AACA;AACA,QAAID,CAAC,CAACE,WAAF,KAAkBD,CAAC,CAACC,WAAxB,EAAqC,OAAOF,CAAC,CAACE,WAAF,GAAgBD,CAAC,CAACC,WAAzB,CAHvB,CAId;;AACA,WAAOF,CAAC,CAACG,QAAF,GAAaF,CAAC,CAACE,QAAtB;AACD,GAR2B,CAA9B,CAjB4E,CA2B5E;;AACA,QAAMC,YAAsC,GAAG,EAA/C;AAEAT,EAAAA,YAAY,CAACU,OAAb,CAAsBR,GAAD,IAAS;AAC5B,QAAI,CAACA,GAAG,CAACS,IAAT,EAAe,OADa,CAE5B;;AACA,UAAM,CAACC,MAAD,EAASC,MAAT,IAAmBX,GAAG,CAACS,IAA7B;AACA,UAAMG,gBAAgB,GAAGD,MAAM,CAACE,GAAP,CAAYC,CAAD,IAAOA,CAAC,CAACC,WAAF,EAAlB,CAAzB;;AACA,QAAIf,GAAG,CAACgB,KAAJ,KAAc,WAAlB,EAA+B;AAC7B;AACAT,MAAAA,YAAY,CAACG,MAAD,CAAZ,GAAuB,CAACH,YAAY,CAACG,MAAD,CAAZ,IAAwB,EAAzB,EAA6BO,MAA7B,CACrBL,gBADqB,CAAvB;AAGD,KALD,MAKO;AACL;AACAL,MAAAA,YAAY,CAACG,MAAD,CAAZ,GAAuB,CAACH,YAAY,CAACG,MAAD,CAAZ,IAAwB,EAAzB,EAA6BX,MAA7B,CACpBmB,KAAD,IAAW,CAACN,gBAAgB,CAACO,QAAjB,CAA0BD,KAA1B,CADS,CAAvB;AAGD;AACF,GAhBD;AAkBA,SAAOX,YAAP;AACD;;AAED,SAASvB,eAAT","sourcesContent":["import * as RegistryContract from \"@airswap/registry/build/contracts/Registry.sol/Registry.json\";\nimport registryDeploys from \"@airswap/registry/deploys.js\";\n\nimport { providers, utils, Contract, Event } from \"ethers\";\n\nconst RegistryInterface = new utils.Interface(\n  JSON.stringify(RegistryContract.abi)\n);\n\nasync function getStakerTokens(chainId: number, provider: providers.Provider) {\n  const registryContract = new Contract(\n    registryDeploys[chainId],\n    RegistryInterface,\n    provider\n  );\n\n  const addTokensEventFilter = registryContract.filters.AddTokens();\n  const removeTokensEventFilter = registryContract.filters.RemoveTokens();\n\n  // Fetch all AddTokens and RemoveTokens events from the registry\n  const [addEvents, removeEvents] = await Promise.all([\n    registryContract.queryFilter(addTokensEventFilter),\n    registryContract.queryFilter(removeTokensEventFilter),\n  ]);\n\n  // Order matters here, so order AddTokens and RemoveTokens chronologically\n  const sortedEvents: Event[] = [...addEvents, ...removeEvents]\n    .filter((log) => !log.removed)\n    .sort((a, b) => {\n      // Sort by oldest first. If they're not in the same block, sort based\n      // on blocknumber\n      if (a.blockNumber !== b.blockNumber) return a.blockNumber - b.blockNumber;\n      // if in the same block, sort by the index of the log in the block\n      return a.logIndex - b.logIndex;\n    });\n\n  // Hold a list of tokens for each staker.\n  const stakerTokens: Record<string, string[]> = {};\n\n  sortedEvents.forEach((log) => {\n    if (!log.args) return;\n    // @ts-ignore (args are not typed)\n    const [staker, tokens] = log.args as [string, string[]];\n    const lowerCasedTokens = tokens.map((t) => t.toLowerCase());\n    if (log.event === \"AddTokens\") {\n      // Adding tokens\n      stakerTokens[staker] = (stakerTokens[staker] || []).concat(\n        lowerCasedTokens\n      );\n    } else {\n      // Removing tokens\n      stakerTokens[staker] = (stakerTokens[staker] || []).filter(\n        (token) => !lowerCasedTokens.includes(token)\n      );\n    }\n  });\n\n  return stakerTokens;\n}\n\nexport { getStakerTokens };\n"]},"metadata":{},"sourceType":"module"}