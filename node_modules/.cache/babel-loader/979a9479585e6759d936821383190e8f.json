{"ast":null,"code":"const stringToSignificantDecimals = (input, sigDecimals = 6) => {\n  // Don't do anything if there's no decimal point.\n  if (input.indexOf(\".\") === -1) {\n    return input;\n  }\n\n  const [beforeDecimalPoint, afterDecimalPoint] = input.split(\".\");\n  let trimmedDecimals = \"\";\n\n  if (afterDecimalPoint.length <= sigDecimals) {\n    // No need to trim\n    trimmedDecimals = afterDecimalPoint;\n  } else if (beforeDecimalPoint.match(/[1-9]/)) {\n    // Number greater than zero, all decimal places significant:\n    // just trim decimals to correct length\n    trimmedDecimals = afterDecimalPoint.slice(0, 4);\n  } else {\n    // Number less than zero, some decimal places may not be significant\n    let sigDecimalsRemaining = sigDecimals;\n    let i = 0;\n    let inLeadingZeroes = true;\n\n    while (sigDecimalsRemaining > 0 && i < afterDecimalPoint.length - 1) {\n      const currentDigit = afterDecimalPoint[i];\n      trimmedDecimals += currentDigit;\n\n      if (!inLeadingZeroes || currentDigit !== \"0\") {\n        inLeadingZeroes = false;\n        sigDecimalsRemaining--;\n      }\n\n      i++;\n    }\n  }\n\n  return `${beforeDecimalPoint}.${trimmedDecimals}`;\n};\n\nexport default stringToSignificantDecimals;","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/src/helpers/stringToSignificantDecimals.ts"],"names":["stringToSignificantDecimals","input","sigDecimals","indexOf","beforeDecimalPoint","afterDecimalPoint","split","trimmedDecimals","length","match","slice","sigDecimalsRemaining","i","inLeadingZeroes","currentDigit"],"mappings":"AAAA,MAAMA,2BAGK,GAAG,CAACC,KAAD,EAAQC,WAAW,GAAG,CAAtB,KAA4B;AACxC;AACA,MAAID,KAAK,CAACE,OAAN,CAAc,GAAd,MAAuB,CAAC,CAA5B,EAA+B;AAC7B,WAAOF,KAAP;AACD;;AAED,QAAM,CAACG,kBAAD,EAAqBC,iBAArB,IAA0CJ,KAAK,CAACK,KAAN,CAAY,GAAZ,CAAhD;AACA,MAAIC,eAAe,GAAG,EAAtB;;AACA,MAAIF,iBAAiB,CAACG,MAAlB,IAA4BN,WAAhC,EAA6C;AAC3C;AACAK,IAAAA,eAAe,GAAGF,iBAAlB;AACD,GAHD,MAGO,IAAID,kBAAkB,CAACK,KAAnB,CAAyB,OAAzB,CAAJ,EAAuC;AAC5C;AACA;AACAF,IAAAA,eAAe,GAAGF,iBAAiB,CAACK,KAAlB,CAAwB,CAAxB,EAA2B,CAA3B,CAAlB;AACD,GAJM,MAIA;AACL;AACA,QAAIC,oBAAoB,GAAGT,WAA3B;AACA,QAAIU,CAAC,GAAG,CAAR;AACA,QAAIC,eAAe,GAAG,IAAtB;;AACA,WAAOF,oBAAoB,GAAG,CAAvB,IAA4BC,CAAC,GAAGP,iBAAiB,CAACG,MAAlB,GAA2B,CAAlE,EAAqE;AACnE,YAAMM,YAAY,GAAGT,iBAAiB,CAACO,CAAD,CAAtC;AACAL,MAAAA,eAAe,IAAIO,YAAnB;;AACA,UAAI,CAACD,eAAD,IAAoBC,YAAY,KAAK,GAAzC,EAA8C;AAC5CD,QAAAA,eAAe,GAAG,KAAlB;AACAF,QAAAA,oBAAoB;AACrB;;AACDC,MAAAA,CAAC;AACF;AACF;;AAED,SAAQ,GAAER,kBAAmB,IAAGG,eAAgB,EAAhD;AACD,CAnCD;;AAoCA,eAAeP,2BAAf","sourcesContent":["const stringToSignificantDecimals: (\n  input: string,\n  sigDecimals?: number\n) => string = (input, sigDecimals = 6) => {\n  // Don't do anything if there's no decimal point.\n  if (input.indexOf(\".\") === -1) {\n    return input;\n  }\n\n  const [beforeDecimalPoint, afterDecimalPoint] = input.split(\".\");\n  let trimmedDecimals = \"\";\n  if (afterDecimalPoint.length <= sigDecimals) {\n    // No need to trim\n    trimmedDecimals = afterDecimalPoint;\n  } else if (beforeDecimalPoint.match(/[1-9]/)) {\n    // Number greater than zero, all decimal places significant:\n    // just trim decimals to correct length\n    trimmedDecimals = afterDecimalPoint.slice(0, 4);\n  } else {\n    // Number less than zero, some decimal places may not be significant\n    let sigDecimalsRemaining = sigDecimals;\n    let i = 0;\n    let inLeadingZeroes = true;\n    while (sigDecimalsRemaining > 0 && i < afterDecimalPoint.length - 1) {\n      const currentDigit = afterDecimalPoint[i];\n      trimmedDecimals += currentDigit;\n      if (!inLeadingZeroes || currentDigit !== \"0\") {\n        inLeadingZeroes = false;\n        sigDecimalsRemaining--;\n      }\n      i++;\n    }\n  }\n\n  return `${beforeDecimalPoint}.${trimmedDecimals}`;\n};\nexport default stringToSignificantDecimals;\n"]},"metadata":{},"sourceType":"module"}