{"ast":null,"code":"import { createSlice, createSelector, createAsyncThunk } from \"@reduxjs/toolkit\";\nimport { ASSUMED_EXPIRY_NOTIFICATION_BUFFER_MS } from \"../../constants/configParams\";\nimport { declineTransaction, expireTransaction, mineTransaction, revertTransaction, submitTransaction } from \"./transactionActions\";\nconst initialState = {\n  all: []\n};\n\nfunction updateTransaction(params) {\n  const {\n    state,\n    nonce,\n    hash,\n    signerWallet,\n    status\n  } = params;\n\n  if (!!signerWallet && !!nonce) {\n    const swap = state.all.find(s => s.nonce === nonce && s.order.signerWallet.toLowerCase() === signerWallet.toLowerCase());\n\n    if (swap) {\n      swap.timestamp = Date.now();\n      swap.status = status;\n      swap.hash = hash;\n    }\n  } else if (hash) {\n    const swap = state.all.find(s => s.hash === hash);\n\n    if (swap) {\n      swap.status = status;\n    }\n  } else {\n    console.warn(\"Can't update transaction without either signerWallet and nonce, \", \"or transaction hash\\n\", \"Supplied params: \", params);\n  }\n}\n\nconst expiryTimeouts = {};\n\nconst clearExpiry = (signerWallet, nonce) => {\n  const uniqueKey = `${signerWallet}/${nonce}`;\n\n  if (expiryTimeouts[uniqueKey]) {\n    clearTimeout(expiryTimeouts[uniqueKey]);\n    delete expiryTimeouts[uniqueKey];\n  }\n};\n\nexport const submitTransactionWithExpiry = createAsyncThunk(\"orders/approve\", async ({\n  transaction,\n  signerWallet,\n  onExpired\n}, {\n  getState,\n  dispatch\n}) => {\n  dispatch(submitTransaction(transaction));\n\n  if (!transaction.expiry) {\n    console.warn(\"submitTransactionWithExpiry called with transaction that has no expiry\");\n    return;\n  }\n\n  const expiresAtMs = parseInt(transaction.expiry) * 1000;\n  const timeToExpiryNotification = expiresAtMs - Date.now() + ASSUMED_EXPIRY_NOTIFICATION_BUFFER_MS;\n  const uniqueTransactionKey = `${signerWallet}/${transaction.nonce}`;\n  expiryTimeouts[uniqueTransactionKey] = window.setTimeout(() => {\n    dispatch(expireTransaction({\n      signerWallet,\n      nonce: transaction.nonce\n    }));\n    onExpired();\n  }, timeToExpiryNotification);\n});\nexport const transactionsSlice = createSlice({\n  name: \"transactions\",\n  initialState,\n  reducers: {\n    clear: state => {\n      state.all = [];\n    },\n    setTransactions: (state, action) => {\n      try {\n        state.all = action.payload.all;\n      } catch (err) {\n        console.error(err);\n        state.all = [];\n      }\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(submitTransaction, (state, action) => {\n      state.all.unshift(action.payload);\n    });\n    builder.addCase(declineTransaction, (state, action) => {\n      console.error(action.payload);\n      clearExpiry(action.payload.signerWallet, action.payload.nonce);\n      updateTransaction({\n        state,\n        hash: action.payload.hash,\n        nonce: action.payload.nonce,\n        signerWallet: action.payload.signerWallet,\n        status: \"declined\",\n        protocol: action.payload.protocol\n      });\n    });\n    builder.addCase(revertTransaction, (state, action) => {\n      clearExpiry(action.payload.signerWallet, action.payload.nonce);\n      updateTransaction({\n        state,\n        signerWallet: action.payload.signerWallet,\n        nonce: action.payload.nonce,\n        hash: action.payload.hash,\n        status: \"reverted\"\n      });\n    });\n    builder.addCase(expireTransaction, (state, action) => {\n      const {\n        signerWallet,\n        nonce\n      } = action.payload;\n      clearExpiry(signerWallet, nonce);\n      updateTransaction({\n        state,\n        signerWallet,\n        nonce,\n        status: \"expired\"\n      });\n    });\n    builder.addCase(mineTransaction, (state, action) => {\n      clearExpiry(action.payload.signerWallet, action.payload.nonce);\n      updateTransaction({\n        state,\n        hash: action.payload.hash,\n        nonce: action.payload.nonce,\n        signerWallet: action.payload.signerWallet,\n        status: \"succeeded\",\n        protocol: action.payload.protocol\n      });\n    });\n  }\n});\nexport const {\n  clear,\n  setTransactions\n} = transactionsSlice.actions;\nexport const selectTransactions = state => state.transactions.all;\nexport const selectPendingTransactions = createSelector(selectTransactions, transactions => {\n  return transactions.filter(tx => tx.status === \"processing\");\n});\nexport const selectPendingApprovals = state => state.transactions.all.filter(tx => tx.status === \"processing\" && tx.type === \"Approval\");\nexport default transactionsSlice.reducer;","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/src/features/transactions/transactionsSlice.ts"],"names":["createSlice","createSelector","createAsyncThunk","ASSUMED_EXPIRY_NOTIFICATION_BUFFER_MS","declineTransaction","expireTransaction","mineTransaction","revertTransaction","submitTransaction","initialState","all","updateTransaction","params","state","nonce","hash","signerWallet","status","swap","find","s","order","toLowerCase","timestamp","Date","now","console","warn","expiryTimeouts","clearExpiry","uniqueKey","clearTimeout","submitTransactionWithExpiry","transaction","onExpired","getState","dispatch","expiry","expiresAtMs","parseInt","timeToExpiryNotification","uniqueTransactionKey","window","setTimeout","transactionsSlice","name","reducers","clear","setTransactions","action","payload","err","error","extraReducers","builder","addCase","unshift","protocol","actions","selectTransactions","transactions","selectPendingTransactions","filter","tx","selectPendingApprovals","type","reducer"],"mappings":"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","sourcesContent":["import { LightOrder } from \"@airswap/types\";\nimport {\n  createSlice,\n  createSelector,\n  createAsyncThunk,\n} from \"@reduxjs/toolkit\";\n\nimport { AppDispatch, RootState } from \"../../app/store\";\nimport { ASSUMED_EXPIRY_NOTIFICATION_BUFFER_MS } from \"../../constants/configParams\";\nimport {\n  declineTransaction,\n  expireTransaction,\n  mineTransaction,\n  revertTransaction,\n  submitTransaction,\n} from \"./transactionActions\";\n\nexport interface DepositOrWithdrawOrder {\n  signerToken: string;\n  signerAmount: string;\n  senderToken: string;\n  senderAmount: string;\n}\n\nexport type TransactionType = \"Approval\" | \"Order\" | \"Deposit\" | \"Withdraw\";\n\nexport type StatusType =\n  | \"processing\"\n  | \"succeeded\"\n  | \"reverted\"\n  | \"declined\"\n  | \"expired\";\n\nexport type ProtocolType = \"request-for-quote\" | \"last-look\";\n\nexport interface SubmittedTransaction {\n  type: TransactionType;\n  hash?: string; // LL orders doesn't have hash\n  status: StatusType;\n  nonce?: string;\n  expiry?: string;\n  timestamp: number;\n  protocol?: ProtocolType;\n}\n\nexport interface SubmittedTransactionWithOrder extends SubmittedTransaction {\n  order: LightOrder;\n}\n\nexport interface SubmittedRFQOrder extends SubmittedTransactionWithOrder {}\n\nexport interface SubmittedLastLookOrder extends SubmittedTransactionWithOrder {}\n\nexport interface LastLookTransaction\n  extends SubmittedTransaction,\n    SubmittedLastLookOrder {}\nexport interface RfqTransaction\n  extends SubmittedTransaction,\n    SubmittedRFQOrder {}\n\nexport interface SubmittedApproval extends SubmittedTransaction {\n  tokenAddress: string;\n}\n\nexport interface SubmittedDepositOrder extends SubmittedTransaction {\n  order: DepositOrWithdrawOrder;\n}\n\nexport interface SubmittedWithdrawOrder extends SubmittedTransaction {\n  order: DepositOrWithdrawOrder;\n}\n\nexport interface TransactionsState {\n  all: SubmittedTransaction[];\n}\n\nconst initialState: TransactionsState = {\n  all: [],\n};\n\nfunction updateTransaction(params: {\n  state: TransactionsState;\n  nonce?: string;\n  hash?: string;\n  signerWallet?: string;\n  status: StatusType;\n  protocol?: ProtocolType;\n}): void {\n  const { state, nonce, hash, signerWallet, status } = params;\n  if (!!signerWallet && !!nonce) {\n    const swap = state.all.find(\n      (s) =>\n        s.nonce === nonce &&\n        (s as SubmittedLastLookOrder).order.signerWallet.toLowerCase() ===\n          signerWallet!.toLowerCase()\n    );\n    if (swap) {\n      swap.timestamp = Date.now();\n      swap.status = status;\n      swap.hash = hash;\n    }\n  } else if (hash) {\n    const swap = state.all.find((s) => s.hash === hash);\n    if (swap) {\n      swap.status = status;\n    }\n  } else {\n    console.warn(\n      \"Can't update transaction without either signerWallet and nonce, \",\n      \"or transaction hash\\n\",\n      \"Supplied params: \",\n      params\n    );\n  }\n}\n\nconst expiryTimeouts: Record<string, number> = {};\n\nconst clearExpiry = (signerWallet?: string, nonce?: string) => {\n  const uniqueKey = `${signerWallet}/${nonce}`;\n\n  if (expiryTimeouts[uniqueKey]) {\n    clearTimeout(expiryTimeouts[uniqueKey]);\n    delete expiryTimeouts[uniqueKey];\n  }\n};\n\nexport const submitTransactionWithExpiry = createAsyncThunk<\n  // Return type of the payload creator\n  void,\n  // Params\n  {\n    transaction: SubmittedTransaction;\n    signerWallet: string;\n    onExpired: () => void;\n  },\n  // Types for ThunkAPI\n  {\n    dispatch: AppDispatch;\n    state: RootState;\n  }\n>(\n  \"orders/approve\",\n  async ({ transaction, signerWallet, onExpired }, { getState, dispatch }) => {\n    dispatch(submitTransaction(transaction));\n    if (!transaction.expiry) {\n      console.warn(\n        \"submitTransactionWithExpiry called with transaction that has no expiry\"\n      );\n      return;\n    }\n\n    const expiresAtMs = parseInt(transaction.expiry) * 1000;\n    const timeToExpiryNotification =\n      expiresAtMs - Date.now() + ASSUMED_EXPIRY_NOTIFICATION_BUFFER_MS;\n    const uniqueTransactionKey = `${signerWallet}/${transaction.nonce}`;\n\n    expiryTimeouts[uniqueTransactionKey] = window.setTimeout(() => {\n      dispatch(\n        expireTransaction({\n          signerWallet,\n          nonce: transaction.nonce!,\n        })\n      );\n      onExpired();\n    }, timeToExpiryNotification);\n  }\n);\n\nexport const transactionsSlice = createSlice({\n  name: \"transactions\",\n  initialState,\n  reducers: {\n    clear: (state) => {\n      state.all = [];\n    },\n    setTransactions: (state, action) => {\n      try {\n        state.all = action.payload.all;\n      } catch (err) {\n        console.error(err);\n        state.all = [];\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    builder.addCase(submitTransaction, (state, action) => {\n      state.all.unshift(action.payload);\n    });\n    builder.addCase(declineTransaction, (state, action) => {\n      console.error(action.payload);\n      clearExpiry(action.payload.signerWallet, action.payload.nonce);\n      updateTransaction({\n        state,\n        hash: action.payload.hash,\n        nonce: action.payload.nonce,\n        signerWallet: action.payload.signerWallet,\n        status: \"declined\",\n        protocol: action.payload.protocol,\n      });\n    });\n    builder.addCase(revertTransaction, (state, action) => {\n      clearExpiry(action.payload.signerWallet, action.payload.nonce);\n      updateTransaction({\n        state,\n        signerWallet: action.payload.signerWallet,\n        nonce: action.payload.nonce,\n        hash: action.payload.hash,\n        status: \"reverted\",\n      });\n    });\n    builder.addCase(expireTransaction, (state, action) => {\n      const { signerWallet, nonce } = action.payload;\n      clearExpiry(signerWallet, nonce);\n      updateTransaction({\n        state,\n        signerWallet,\n        nonce,\n        status: \"expired\",\n      });\n    });\n    builder.addCase(mineTransaction, (state, action) => {\n      clearExpiry(action.payload.signerWallet, action.payload.nonce);\n      updateTransaction({\n        state,\n        hash: action.payload.hash,\n        nonce: action.payload.nonce,\n        signerWallet: action.payload.signerWallet,\n        status: \"succeeded\",\n        protocol: action.payload.protocol,\n      });\n    });\n  },\n});\n\nexport const { clear, setTransactions } = transactionsSlice.actions;\nexport const selectTransactions = (state: RootState) => state.transactions.all;\n\nexport const selectPendingTransactions = createSelector(\n  selectTransactions,\n  (transactions) => {\n    return transactions.filter((tx) => tx.status === \"processing\");\n  }\n);\n\nexport const selectPendingApprovals = (state: RootState) =>\n  state.transactions.all.filter(\n    (tx) => tx.status === \"processing\" && tx.type === \"Approval\"\n  ) as SubmittedApproval[];\nexport default transactionsSlice.reducer;\n"]},"metadata":{},"sourceType":"module"}