{"ast":null,"code":"'use strict';\n\nconst WebSocket = require('isomorphic-ws');\n\nconst utils = require('../utils');\n\nconst delay = require('delay');\n\nconst Client = require('../client');\n/**\n *  Constructor for a Jayson Websocket Client\n *  @class ClientWebsocket\n *  @constructor\n *  @extends Client\n *  @param {Object} [options]\n *  @param {String} [options.url] When options.ws not provided this will be the URL to open the websocket to\n *  @param {ws.WebSocket} [options.ws] When not provided will create a WebSocket instance with options.url\n *  @param {Number} [options.timeout] Will wait this long in ms until callbacking with an error\n *  @return {ClientWebsocket}\n */\n\n\nconst ClientWebsocket = function (options) {\n  if (!(this instanceof ClientWebsocket)) {\n    return new ClientWebsocket(options);\n  }\n\n  Client.call(this, options);\n  const defaults = utils.merge(this.options, {});\n  this.options = utils.merge(defaults, options || {});\n  const self = this;\n  this.ws = this.options.ws || new WebSocket(this.options.url);\n  this.outstandingRequests = [];\n  this.handlers = {};\n\n  this.handlers.message = function (str) {\n    utils.JSON.parse(str, self.options, function (err, response) {\n      if (err) {\n        // invalid JSON is ignored\n        return;\n      }\n\n      if (Array.isArray(response)) {\n        // we have a batch reply\n        const matchingRequest = self.outstandingRequests.find(function ([request]) {\n          if (Array.isArray(request)) {\n            // a batch is considered matching if at least one response id matches one request id\n            return response.some(function (resp) {\n              if (utils.Response.isValidResponse(resp)) {\n                return request.some(function (req) {\n                  return req.id === resp.id;\n                });\n              }\n\n              return false;\n            });\n          }\n        });\n\n        if (matchingRequest) {\n          const [, resolve] = matchingRequest;\n          return resolve(response);\n        }\n      } else if (utils.Response.isValidResponse(response)) {\n        const matchingRequest = self.outstandingRequests.find(function ([request]) {\n          return !Array.isArray(request) && request.id === response.id;\n        });\n\n        if (matchingRequest) {\n          const [, resolve] = matchingRequest;\n          return resolve(response);\n        }\n      }\n    });\n  };\n\n  this.ws.on('message', this.handlers.message);\n};\n\nrequire('util').inherits(ClientWebsocket, Client);\n\nmodule.exports = ClientWebsocket;\n/**\n * @desc Removes all event listeners from Websocket instance which cancels all outstanding requests too\n */\n\nClientWebsocket.prototype.unlisten = function () {\n  for (const eventName in this.handlers) {\n    this.ws.off(eventName, this.handlers[eventName]);\n  }\n};\n\nClientWebsocket.prototype._request = function (request, callback) {\n  const self = this;\n  const {\n    ws,\n    options\n  } = this; // we have to remove the object representing this request when the promise resolves/rejects\n\n  let outstandingItem;\n  Promise.race([options.timeout > 0 ? delay(options.timeout).then(function () {\n    throw new Error('timeout reached after ' + options.timeout + ' ms');\n  }) : null, new Promise(function (resolve, reject) {\n    utils.JSON.stringify(request, options, function (err, body) {\n      if (err) {\n        return resolve(err);\n      }\n\n      ws.send(body);\n\n      if (utils.Request.isNotification(request)) {\n        // notifications callback immediately since they don't have a reply\n        return resolve();\n      }\n\n      outstandingItem = [request, resolve, reject];\n      self.outstandingRequests.push(outstandingItem);\n    });\n  })].filter(v => v !== null)).then(function (result) {\n    removeOutstandingRequest();\n    callback(null, result);\n  }).catch(function (err) {\n    removeOutstandingRequest();\n    callback(err);\n  });\n\n  function removeOutstandingRequest() {\n    if (!outstandingItem) {\n      return;\n    }\n\n    self.outstandingRequests = self.outstandingRequests.filter(v => v !== outstandingItem);\n  }\n};","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/node_modules/jayson/lib/client/websocket.js"],"names":["WebSocket","require","utils","delay","Client","ClientWebsocket","options","call","defaults","merge","self","ws","url","outstandingRequests","handlers","message","str","JSON","parse","err","response","Array","isArray","matchingRequest","find","request","some","resp","Response","isValidResponse","req","id","resolve","on","inherits","module","exports","prototype","unlisten","eventName","off","_request","callback","outstandingItem","Promise","race","timeout","then","Error","reject","stringify","body","send","Request","isNotification","push","filter","v","result","removeOutstandingRequest","catch"],"mappings":"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","sourcesContent":["'use strict';\n\nconst WebSocket = require('isomorphic-ws');\nconst utils = require('../utils');\nconst delay = require('delay');\nconst Client = require('../client');\n\n/**\n *  Constructor for a Jayson Websocket Client\n *  @class ClientWebsocket\n *  @constructor\n *  @extends Client\n *  @param {Object} [options]\n *  @param {String} [options.url] When options.ws not provided this will be the URL to open the websocket to\n *  @param {ws.WebSocket} [options.ws] When not provided will create a WebSocket instance with options.url\n *  @param {Number} [options.timeout] Will wait this long in ms until callbacking with an error\n *  @return {ClientWebsocket}\n */\nconst ClientWebsocket = function(options) {\n  if(!(this instanceof ClientWebsocket)) {\n    return new ClientWebsocket(options);\n  }\n  Client.call(this, options);\n\n  const defaults = utils.merge(this.options, {});\n  this.options = utils.merge(defaults, options || {});\n\n  const self = this;\n  \n  this.ws = this.options.ws || new WebSocket(this.options.url);\n  this.outstandingRequests = [];\n  this.handlers = {};\n\n  this.handlers.message = function (str) {\n    utils.JSON.parse(str, self.options, function(err, response) {\n      if (err) {\n        // invalid JSON is ignored\n        return;\n      }\n\n      if (Array.isArray(response)) {\n\n        // we have a batch reply\n        const matchingRequest = self.outstandingRequests.find(function ([request]) {\n          if (Array.isArray(request)) {\n            // a batch is considered matching if at least one response id matches one request id\n            return response.some(function (resp) {\n              if (utils.Response.isValidResponse(resp)) {\n                return request.some(function (req) {\n                  return req.id === resp.id;\n                });\n              }\n              return false;\n            });\n          }\n        });\n\n        if (matchingRequest) {\n          const [ , resolve ] = matchingRequest;\n          return resolve(response);\n        }\n\n      } else if (utils.Response.isValidResponse(response)) {\n\n        const matchingRequest = self.outstandingRequests.find(function ([request]) {\n          return !Array.isArray(request) && request.id === response.id;\n        });\n\n        if (matchingRequest) {\n          const [ , resolve ] = matchingRequest;\n          return resolve(response);\n        }\n      }\n\n    });\n  };\n\n  this.ws.on('message', this.handlers.message);\n};\nrequire('util').inherits(ClientWebsocket, Client);\n\nmodule.exports = ClientWebsocket;\n\n/**\n * @desc Removes all event listeners from Websocket instance which cancels all outstanding requests too\n */\nClientWebsocket.prototype.unlisten = function () {\n  for (const eventName in this.handlers) {\n    this.ws.off(eventName, this.handlers[eventName]);\n  }\n};\n\nClientWebsocket.prototype._request = function(request, callback) {\n  const self = this;\n  const { ws, options } = this;\n\n  // we have to remove the object representing this request when the promise resolves/rejects\n  let outstandingItem;\n\n  Promise.race([\n    options.timeout > 0 ? delay(options.timeout).then(function () {\n      throw new Error('timeout reached after ' + options.timeout + ' ms');\n    }) : null,\n    new Promise(function (resolve, reject) {\n      utils.JSON.stringify(request, options, function(err, body) {\n        if (err) {\n          return resolve(err);\n        }\n\n        ws.send(body);\n\n        if (utils.Request.isNotification(request)) {\n          // notifications callback immediately since they don't have a reply\n          return resolve();\n        }\n\n        outstandingItem = [request, resolve, reject];\n        self.outstandingRequests.push(outstandingItem);\n      });\n    }),\n  ].filter(v => v !== null)).then(function (result) {\n    removeOutstandingRequest();\n    callback(null, result);\n  }).catch(function (err) {\n    removeOutstandingRequest();\n    callback(err);\n  });\n\n  function removeOutstandingRequest () {\n    if (!outstandingItem) {\n      return;\n    }\n    self.outstandingRequests = self.outstandingRequests.filter(v => v !== outstandingItem);\n  }\n};\n"]},"metadata":{},"sourceType":"script"}