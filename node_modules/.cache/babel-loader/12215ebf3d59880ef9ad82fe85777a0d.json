{"ast":null,"code":"import { mineTransaction, revertTransaction } from \"./transactionActions\";\n\n/**\n * if pending, call getTransaction to see if it was a success/failure/pending\n * update accordingly. if pending: wait() and poll at a sensible interval.\n * this is only good for request-for-quote orders\n * @param transactionInState\n * @param walletHasChanged\n * @param dispatch\n * @param library\n */\nasync function handleTransaction(transactionInState, walletHasChanged, dispatch, library) {\n  if (transactionInState.status === \"processing\" && transactionInState.hash) {\n    let receipt = await library.getTransactionReceipt(transactionInState.hash);\n\n    if (receipt !== null) {\n      if (walletHasChanged) return;\n      const status = receipt.status;\n      if (status === 1) dispatch(mineTransaction({\n        hash: transactionInState.hash\n      })); // success\n      else if (status === 0) dispatch(revertTransaction({\n        hash: transactionInState.hash,\n        reason: \"Reverted\"\n      })); // reverted\n\n      return; // Orders will automatically be picked up by swapEventSubscriber\n    } else if (transactionInState.type !== \"Order\") {\n      // Receipt was null, so the transaction is incomplete\n      // Try to get a reference to the transaction in the mem pool - this\n      // can sometimes also return null (e.g. gas price too low or tx only\n      // recently sent) depending on backend.\n      const transaction = await library.getTransaction(transactionInState.hash);\n\n      if (transaction) {\n        try {\n          await transaction.wait(1);\n          if (!walletHasChanged) dispatch(mineTransaction({\n            hash: transactionInState.hash\n          })); // success\n        } catch (err) {\n          console.error(err);\n          if (!walletHasChanged) dispatch(revertTransaction({\n            hash: transactionInState.hash,\n            reason: \"Reverted\"\n          }));\n        }\n\n        return;\n      } else {\n        // if transaction === null, we poll at intervals\n        // assume failed after 30 mins\n        const assumedFailureTime = Date.now() + 30 * 60 * 1000;\n\n        while (receipt === null && Date.now() <= assumedFailureTime) {\n          // wait 30 seconds\n          await new Promise(res => setTimeout(res, 30000));\n          receipt = await library.getTransactionReceipt(transactionInState.hash);\n        }\n\n        if (!receipt || receipt.status === 0) {\n          if (!walletHasChanged) dispatch(revertTransaction({\n            hash: transactionInState.hash,\n            reason: \"Reverted\"\n          }));\n        } else {\n          if (!walletHasChanged) dispatch(mineTransaction({\n            hash: transactionInState.hash\n          })); // success\n        }\n      }\n    }\n  }\n}\n\nexport default handleTransaction;","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/features/transactions/handleTransaction.ts"],"names":["mineTransaction","revertTransaction","handleTransaction","transactionInState","walletHasChanged","dispatch","library","status","hash","receipt","getTransactionReceipt","reason","type","transaction","getTransaction","wait","err","console","error","assumedFailureTime","Date","now","Promise","res","setTimeout"],"mappings":"AAGA,SAASA,eAAT,EAA0BC,iBAA1B,QAAmD,sBAAnD;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAeC,iBAAf,CACEC,kBADF,EAEEC,gBAFF,EAGEC,QAHF,EAIEC,OAJF,EAKE;AACA,MAAIH,kBAAkB,CAACI,MAAnB,KAA8B,YAA9B,IAA8CJ,kBAAkB,CAACK,IAArE,EAA2E;AACzE,QAAIC,OAAO,GAAG,MAAMH,OAAO,CAACI,qBAAR,CAA8BP,kBAAkB,CAACK,IAAjD,CAApB;;AACA,QAAIC,OAAO,KAAK,IAAhB,EAAsB;AACpB,UAAIL,gBAAJ,EAAsB;AACtB,YAAMG,MAAM,GAAGE,OAAO,CAACF,MAAvB;AACA,UAAIA,MAAM,KAAK,CAAf,EACEF,QAAQ,CAACL,eAAe,CAAC;AAAEQ,QAAAA,IAAI,EAAEL,kBAAkB,CAACK;AAA3B,OAAD,CAAhB,CAAR,CADF,CAEA;AAFA,WAGK,IAAID,MAAM,KAAK,CAAf,EACHF,QAAQ,CACNJ,iBAAiB,CAAC;AAChBO,QAAAA,IAAI,EAAEL,kBAAkB,CAACK,IADT;AAEhBG,QAAAA,MAAM,EAAE;AAFQ,OAAD,CADX,CAAR,CAPkB,CAYf;;AACL,aAboB,CAcpB;AACD,KAfD,MAeO,IAAIR,kBAAkB,CAACS,IAAnB,KAA4B,OAAhC,EAAyC;AAC9C;AACA;AACA;AACA;AACA,YAAMC,WAAW,GAAG,MAAMP,OAAO,CAACQ,cAAR,CAAuBX,kBAAkB,CAACK,IAA1C,CAA1B;;AACA,UAAIK,WAAJ,EAAiB;AACf,YAAI;AACF,gBAAMA,WAAW,CAACE,IAAZ,CAAiB,CAAjB,CAAN;AACA,cAAI,CAACX,gBAAL,EACEC,QAAQ,CAACL,eAAe,CAAC;AAAEQ,YAAAA,IAAI,EAAEL,kBAAkB,CAACK;AAA3B,WAAD,CAAhB,CAAR,CAHA,CAG8D;AACjE,SAJD,CAIE,OAAOQ,GAAP,EAAY;AACZC,UAAAA,OAAO,CAACC,KAAR,CAAcF,GAAd;AACA,cAAI,CAACZ,gBAAL,EACEC,QAAQ,CACNJ,iBAAiB,CAAC;AAChBO,YAAAA,IAAI,EAAEL,kBAAkB,CAACK,IADT;AAEhBG,YAAAA,MAAM,EAAE;AAFQ,WAAD,CADX,CAAR;AAMH;;AACD;AACD,OAhBD,MAgBO;AACL;AACA;AACA,cAAMQ,kBAAkB,GAAGC,IAAI,CAACC,GAAL,KAAa,KAAK,EAAL,GAAU,IAAlD;;AACA,eAAOZ,OAAO,KAAK,IAAZ,IAAoBW,IAAI,CAACC,GAAL,MAAcF,kBAAzC,EAA6D;AAC3D;AACA,gBAAM,IAAIG,OAAJ,CAAaC,GAAD,IAASC,UAAU,CAACD,GAAD,EAAM,KAAN,CAA/B,CAAN;AACAd,UAAAA,OAAO,GAAG,MAAMH,OAAO,CAAEI,qBAAT,CACdP,kBAAkB,CAACK,IADL,CAAhB;AAGD;;AACD,YAAI,CAACC,OAAD,IAAYA,OAAO,CAACF,MAAR,KAAmB,CAAnC,EAAsC;AACpC,cAAI,CAACH,gBAAL,EACEC,QAAQ,CACNJ,iBAAiB,CAAC;AAChBO,YAAAA,IAAI,EAAEL,kBAAkB,CAACK,IADT;AAEhBG,YAAAA,MAAM,EAAE;AAFQ,WAAD,CADX,CAAR;AAMH,SARD,MAQO;AACL,cAAI,CAACP,gBAAL,EACEC,QAAQ,CAACL,eAAe,CAAC;AAAEQ,YAAAA,IAAI,EAAEL,kBAAkB,CAACK;AAA3B,WAAD,CAAhB,CAAR,CAFG,CAE2D;AACjE;AACF;AACF;AACF;AACF;;AACD,eAAeN,iBAAf","sourcesContent":["import { Web3Provider } from \"@ethersproject/providers\";\nimport { Action, Dispatch } from \"@reduxjs/toolkit\";\n\nimport { mineTransaction, revertTransaction } from \"./transactionActions\";\nimport { SubmittedTransaction } from \"./transactionsSlice\";\n\n/**\n * if pending, call getTransaction to see if it was a success/failure/pending\n * update accordingly. if pending: wait() and poll at a sensible interval.\n * this is only good for request-for-quote orders\n * @param transactionInState\n * @param walletHasChanged\n * @param dispatch\n * @param library\n */\nasync function handleTransaction(\n  transactionInState: SubmittedTransaction,\n  walletHasChanged: boolean,\n  dispatch: Dispatch<Action>,\n  library: Web3Provider\n) {\n  if (transactionInState.status === \"processing\" && transactionInState.hash) {\n    let receipt = await library.getTransactionReceipt(transactionInState.hash);\n    if (receipt !== null) {\n      if (walletHasChanged) return;\n      const status = receipt.status;\n      if (status === 1)\n        dispatch(mineTransaction({ hash: transactionInState.hash }));\n      // success\n      else if (status === 0)\n        dispatch(\n          revertTransaction({\n            hash: transactionInState.hash,\n            reason: \"Reverted\",\n          })\n        ); // reverted\n      return;\n      // Orders will automatically be picked up by swapEventSubscriber\n    } else if (transactionInState.type !== \"Order\") {\n      // Receipt was null, so the transaction is incomplete\n      // Try to get a reference to the transaction in the mem pool - this\n      // can sometimes also return null (e.g. gas price too low or tx only\n      // recently sent) depending on backend.\n      const transaction = await library.getTransaction(transactionInState.hash);\n      if (transaction) {\n        try {\n          await transaction.wait(1);\n          if (!walletHasChanged)\n            dispatch(mineTransaction({ hash: transactionInState.hash })); // success\n        } catch (err) {\n          console.error(err);\n          if (!walletHasChanged)\n            dispatch(\n              revertTransaction({\n                hash: transactionInState.hash,\n                reason: \"Reverted\",\n              })\n            );\n        }\n        return;\n      } else {\n        // if transaction === null, we poll at intervals\n        // assume failed after 30 mins\n        const assumedFailureTime = Date.now() + 30 * 60 * 1000;\n        while (receipt === null && Date.now() <= assumedFailureTime) {\n          // wait 30 seconds\n          await new Promise((res) => setTimeout(res, 30000));\n          receipt = await library!.getTransactionReceipt(\n            transactionInState.hash\n          );\n        }\n        if (!receipt || receipt.status === 0) {\n          if (!walletHasChanged)\n            dispatch(\n              revertTransaction({\n                hash: transactionInState.hash,\n                reason: \"Reverted\",\n              })\n            );\n        } else {\n          if (!walletHasChanged)\n            dispatch(mineTransaction({ hash: transactionInState.hash })); // success\n        }\n      }\n    }\n  }\n}\nexport default handleTransaction;\n"]},"metadata":{},"sourceType":"module"}