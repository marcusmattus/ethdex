{"ast":null,"code":"import { formatUnits } from \"@ethersproject/units\";\nexport function sortTokensByBalance(tokens, balances) {\n  return tokens.sort((a, b) => parseFloat(formatUnits(balances.values[a.address], a.decimals)) < parseFloat(formatUnits(balances.values[b.address], b.decimals)) ? 1 : parseFloat(formatUnits(balances.values[a.address], a.decimals)) === parseFloat(formatUnits(balances.values[b.address], b.decimals)) ? a.symbol > b.symbol ? 1 : -1 : -1);\n}\nexport function sortTokensBySymbol(tokens) {\n  return tokens.sort((a, b) => a.symbol.toLocaleLowerCase() < b.symbol.toLocaleLowerCase() ? -1 : 1);\n}\n\nfunction getTokenBalance(token, balances) {\n  const balance = balances.values[token.address];\n\n  if (!balance) {\n    return 0;\n  }\n\n  return parseFloat(formatUnits(balances.values[token.address], token.decimals));\n}\n\nexport function sortTokensBySymbolAndBalance(tokens, balances) {\n  return tokens.sort((a, b) => {\n    const aBalance = getTokenBalance(a, balances);\n    const bBalance = getTokenBalance(b, balances);\n\n    if (aBalance === 0 && bBalance !== 0) {\n      return 1;\n    } else if (bBalance === 0 && aBalance !== 0) {\n      return -1;\n    }\n\n    return a.symbol.toLocaleLowerCase() < b.symbol.toLocaleLowerCase() ? -1 : 1;\n  });\n}\nexport function sortTokenByExactMatch(filteredTokens, tokenQuery) {\n  if (!filteredTokens.length) return [];\n  if (!tokenQuery || tokenQuery === \"\") return filteredTokens; // split query into word array\n\n  const symbolMatch = tokenQuery.toLowerCase().split(/\\s+/).filter(s => s.length > 0); // don't filter against symbol if query is multiple words\n\n  if (symbolMatch.length > 1) return filteredTokens; // filter based off symbol match -> substring match -> remainder of filtered tokens\n\n  const exactMatches = [];\n  const symbolSubtrings = [];\n  const remainder = [];\n  filteredTokens.forEach(token => {\n    var _token$symbol, _token$symbol2;\n\n    // add exact matches\n    if (((_token$symbol = token.symbol) === null || _token$symbol === void 0 ? void 0 : _token$symbol.toLowerCase()) === symbolMatch[0]) {\n      return exactMatches.push(token);\n    } // add matches with starting values\n    else if ((_token$symbol2 = token.symbol) === null || _token$symbol2 === void 0 ? void 0 : _token$symbol2.toLowerCase().startsWith(tokenQuery.toLowerCase().trim())) {\n      return symbolSubtrings.push(token);\n    } // add remaining filtered tokens\n    else {\n      return remainder.push(token);\n    }\n  });\n  return [...exactMatches, ...symbolSubtrings, ...remainder];\n}","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/src/components/TokenList/sort.ts"],"names":["formatUnits","sortTokensByBalance","tokens","balances","sort","a","b","parseFloat","values","address","decimals","symbol","sortTokensBySymbol","toLocaleLowerCase","getTokenBalance","token","balance","sortTokensBySymbolAndBalance","aBalance","bBalance","sortTokenByExactMatch","filteredTokens","tokenQuery","length","symbolMatch","toLowerCase","split","filter","s","exactMatches","symbolSubtrings","remainder","forEach","push","startsWith","trim"],"mappings":"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","sourcesContent":["import { TokenInfo } from \"@airswap/types\";\nimport { formatUnits } from \"@ethersproject/units\";\n\nimport { BalancesState } from \"../../features/balances/balancesSlice\";\n\nexport function sortTokensByBalance(\n  tokens: TokenInfo[],\n  balances: BalancesState\n) {\n  return tokens.sort((a, b) =>\n    parseFloat(formatUnits(balances.values[a.address]!, a.decimals)) <\n    parseFloat(formatUnits(balances.values[b.address]!, b.decimals))\n      ? 1\n      : parseFloat(formatUnits(balances.values[a.address]!, a.decimals)) ===\n        parseFloat(formatUnits(balances.values[b.address]!, b.decimals))\n      ? a.symbol > b.symbol\n        ? 1\n        : -1\n      : -1\n  );\n}\n\nexport function sortTokensBySymbol(tokens: TokenInfo[]) {\n  return tokens.sort((a, b) =>\n    a.symbol.toLocaleLowerCase() < b.symbol.toLocaleLowerCase() ? -1 : 1\n  );\n}\n\nfunction getTokenBalance(token: TokenInfo, balances: BalancesState): number {\n  const balance = balances.values[token.address];\n\n  if (!balance) {\n    return 0;\n  }\n\n  return parseFloat(\n    formatUnits(balances.values[token.address]!, token.decimals)\n  );\n}\n\nexport function sortTokensBySymbolAndBalance(\n  tokens: TokenInfo[],\n  balances: BalancesState\n) {\n  return tokens.sort((a, b) => {\n    const aBalance = getTokenBalance(a, balances);\n    const bBalance = getTokenBalance(b, balances);\n\n    if (aBalance === 0 && bBalance !== 0) {\n      return 1;\n    } else if (bBalance === 0 && aBalance !== 0) {\n      return -1;\n    }\n\n    return a.symbol.toLocaleLowerCase() < b.symbol.toLocaleLowerCase() ? -1 : 1;\n  });\n}\n\nexport function sortTokenByExactMatch(\n  filteredTokens: TokenInfo[],\n  tokenQuery: string\n) {\n  if (!filteredTokens.length) return [];\n  if (!tokenQuery || tokenQuery === \"\") return filteredTokens;\n\n  // split query into word array\n  const symbolMatch = tokenQuery\n    .toLowerCase()\n    .split(/\\s+/)\n    .filter((s) => s.length > 0);\n\n  // don't filter against symbol if query is multiple words\n  if (symbolMatch.length > 1) return filteredTokens;\n\n  // filter based off symbol match -> substring match -> remainder of filtered tokens\n  const exactMatches: TokenInfo[] = [];\n  const symbolSubtrings: TokenInfo[] = [];\n  const remainder: TokenInfo[] = [];\n\n  filteredTokens.forEach((token) => {\n    // add exact matches\n    if (token.symbol?.toLowerCase() === symbolMatch[0]) {\n      return exactMatches.push(token);\n    }\n    // add matches with starting values\n    else if (\n      token.symbol?.toLowerCase().startsWith(tokenQuery.toLowerCase().trim())\n    ) {\n      return symbolSubtrings.push(token);\n    }\n    // add remaining filtered tokens\n    else {\n      return remainder.push(token);\n    }\n  });\n\n  return [...exactMatches, ...symbolSubtrings, ...remainder];\n}\n"]},"metadata":{},"sourceType":"module"}