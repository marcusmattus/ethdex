{"ast":null,"code":"'use strict';\n\nconst net = require('net');\n\nconst utils = require('../utils');\n\nconst Client = require('../client');\n/**\n *  Constructor for a Jayson TCP Client\n *  @class ClientTcp\n *  @constructor\n *  @extends Client\n *  @param {Object|String} [options] Object goes into options for net.connect, String goes into options.path. String option argument is NOT recommended.\n *  @return {ClientTcp}\n */\n\n\nconst ClientTcp = function (options) {\n  if (typeof options === 'string') {\n    options = {\n      path: options\n    };\n  }\n\n  if (!(this instanceof ClientTcp)) {\n    return new ClientTcp(options);\n  }\n\n  Client.call(this, options);\n  const defaults = utils.merge(this.options, {\n    encoding: 'utf8'\n  });\n  this.options = utils.merge(defaults, options || {});\n};\n\nrequire('util').inherits(ClientTcp, Client);\n\nmodule.exports = ClientTcp;\n\nClientTcp.prototype._request = function (request, callback) {\n  const self = this; // copies options so object can be modified in this context\n\n  const options = utils.merge({}, this.options);\n  const delimiter = options.delimiter || '\\n';\n  utils.JSON.stringify(request, options, function (err, body) {\n    if (err) {\n      return callback(err);\n    }\n\n    let handled = false;\n    const conn = net.connect(options, function () {\n      conn.setEncoding(options.encoding); // wont get anything for notifications, just end here\n\n      if (utils.Request.isNotification(request)) {\n        handled = true;\n        conn.end(body + delimiter);\n        callback();\n      } else {\n        utils.parseStream(conn, options, function (err, response) {\n          handled = true;\n          conn.end();\n\n          if (err) {\n            return callback(err);\n          }\n\n          callback(null, response);\n        });\n        conn.write(body + delimiter);\n      }\n    });\n    self.emit('tcp socket', conn);\n    conn.on('error', function (err) {\n      self.emit('tcp error', err);\n      callback(err);\n    });\n    conn.on('end', function () {\n      if (!handled) {\n        callback();\n      }\n    });\n  });\n};","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/node_modules/jayson/lib/client/tcp.js"],"names":["net","require","utils","Client","ClientTcp","options","path","call","defaults","merge","encoding","inherits","module","exports","prototype","_request","request","callback","self","delimiter","JSON","stringify","err","body","handled","conn","connect","setEncoding","Request","isNotification","end","parseStream","response","write","emit","on"],"mappings":"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","sourcesContent":["'use strict';\n\nconst net = require('net');\nconst utils = require('../utils');\nconst Client = require('../client');\n\n/**\n *  Constructor for a Jayson TCP Client\n *  @class ClientTcp\n *  @constructor\n *  @extends Client\n *  @param {Object|String} [options] Object goes into options for net.connect, String goes into options.path. String option argument is NOT recommended.\n *  @return {ClientTcp}\n */\nconst ClientTcp = function(options) {\n  if(typeof(options) === 'string') {\n    options = {path: options};\n  }\n\n  if(!(this instanceof ClientTcp)) {\n    return new ClientTcp(options);\n  }\n  Client.call(this, options);\n\n  const defaults = utils.merge(this.options, {\n    encoding: 'utf8'\n  });\n\n  this.options = utils.merge(defaults, options || {});\n};\nrequire('util').inherits(ClientTcp, Client);\n\nmodule.exports = ClientTcp;\n\nClientTcp.prototype._request = function(request, callback) {\n  const self = this;\n\n  // copies options so object can be modified in this context\n  const options = utils.merge({}, this.options);\n  const delimiter = options.delimiter || '\\n';\n\n  utils.JSON.stringify(request, options, function(err, body) {\n    if(err) {\n      return callback(err);\n    }\n\n    let handled = false;\n\n    const conn = net.connect(options, function() {\n\n      conn.setEncoding(options.encoding);\n\n      // wont get anything for notifications, just end here\n      if(utils.Request.isNotification(request)) {\n\n        handled = true;\n        conn.end(body + delimiter);\n        callback();\n\n      } else {\n\n        utils.parseStream(conn, options, function(err, response) {\n          handled = true;\n          conn.end();\n          if(err) {\n            return callback(err);\n          }\n          callback(null, response);\n        });\n\n        conn.write(body + delimiter);\n\n      }\n\n    });\n\n    self.emit('tcp socket', conn);\n\n    conn.on('error', function(err) {\n      self.emit('tcp error', err);\n      callback(err);\n    });\n\n    conn.on('end', function() {\n      if(!handled) {\n        callback();\n      }\n    });\n  });\n};\n"]},"metadata":{},"sourceType":"script"}