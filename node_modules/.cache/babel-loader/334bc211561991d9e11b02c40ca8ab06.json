{"ast":null,"code":"import { createAsyncThunk, createSlice } from \"@reduxjs/toolkit\";\nimport uniqBy from \"lodash.uniqby\";\nimport { getActiveTokensFromLocalStorage } from \"../metadata/metadataApi\";\nimport { setWalletConnected, setWalletDisconnected } from \"../wallet/walletSlice\";\nimport { getStakerTokens } from \"./registryApi\";\nconst initialState = {\n  stakerTokens: {},\n  allSupportedTokens: [],\n  status: \"idle\"\n};\nexport const fetchSupportedTokens = createAsyncThunk(\"registry/fetchSupportedTokens\", async ({\n  provider\n}, {\n  getState\n}) => {\n  const {\n    wallet\n  } = getState();\n  const stakerTokens = await getStakerTokens(wallet.chainId, provider); // Combine token lists from all makers and flatten them.\n\n  const allSupportedTokens = uniqBy(Object.values(stakerTokens).flat(), i => i);\n  const activeTokensLocalStorage = getActiveTokensFromLocalStorage(wallet.address, wallet.chainId);\n  const activeTokens = activeTokensLocalStorage.length && activeTokensLocalStorage || allSupportedTokens || [];\n  return {\n    stakerTokens,\n    allSupportedTokens,\n    activeTokens\n  };\n});\nexport const registrySlice = createSlice({\n  name: \"registry\",\n  initialState,\n  reducers: {\n    setStakerTokens: (state, action) => {\n      state.stakerTokens = { ...action.payload\n      };\n    },\n    setAllSupportedTokens: (state, action) => {\n      state.allSupportedTokens = [...action.payload];\n    },\n    reset: () => {\n      return { ...initialState\n      };\n    }\n  },\n  extraReducers: builder => {\n    builder.addCase(fetchSupportedTokens.pending, state => {\n      state.status = \"fetching\";\n    }).addCase(fetchSupportedTokens.fulfilled, (state, action) => {\n      state.status = \"idle\";\n      state.allSupportedTokens = [...action.payload.allSupportedTokens];\n      state.stakerTokens = { ...action.payload.stakerTokens\n      };\n    }).addCase(fetchSupportedTokens.rejected, state => {\n      state.status = \"failed\";\n    }) // Reset on wallet connect or disconnect\n    .addCase(setWalletConnected, () => initialState).addCase(setWalletDisconnected, () => initialState);\n  }\n});\nexport const {\n  setStakerTokens,\n  setAllSupportedTokens,\n  reset\n} = registrySlice.actions;\nexport const selectAllSupportedTokens = state => state.registry.allSupportedTokens;\nexport default registrySlice.reducer;","map":{"version":3,"sources":["/Users/marcusmattus/ethdex/airswap-web/src/features/registry/registrySlice.ts"],"names":["createAsyncThunk","createSlice","uniqBy","getActiveTokensFromLocalStorage","setWalletConnected","setWalletDisconnected","getStakerTokens","initialState","stakerTokens","allSupportedTokens","status","fetchSupportedTokens","provider","getState","wallet","chainId","Object","values","flat","i","activeTokensLocalStorage","address","activeTokens","length","registrySlice","name","reducers","setStakerTokens","state","action","payload","setAllSupportedTokens","reset","extraReducers","builder","addCase","pending","fulfilled","rejected","actions","selectAllSupportedTokens","registry","reducer"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from \"@reduxjs/toolkit\";\n\nimport { providers } from \"ethers\";\nimport uniqBy from \"lodash.uniqby\";\n\nimport { AppDispatch, RootState } from \"../../app/store\";\nimport { getActiveTokensFromLocalStorage } from \"../metadata/metadataApi\";\nimport {\n  setWalletConnected,\n  setWalletDisconnected,\n} from \"../wallet/walletSlice\";\nimport { getStakerTokens } from \"./registryApi\";\n\nexport interface RegistryState {\n  stakerTokens: Record<string, string[]>;\n  allSupportedTokens: string[];\n  status: \"idle\" | \"fetching\" | \"failed\";\n}\n\nconst initialState: RegistryState = {\n  stakerTokens: {},\n  allSupportedTokens: [],\n  status: \"idle\",\n};\n\nexport const fetchSupportedTokens = createAsyncThunk<\n  {\n    allSupportedTokens: string[];\n    stakerTokens: Record<string, string[]>;\n    activeTokens: string[];\n  },\n  {\n    provider: providers.Provider;\n  },\n  {\n    // Optional fields for defining thunkApi field types\n    dispatch: AppDispatch;\n    state: RootState;\n  }\n>(\"registry/fetchSupportedTokens\", async ({ provider }, { getState }) => {\n  const { wallet } = getState();\n  const stakerTokens = await getStakerTokens(wallet.chainId!, provider);\n  // Combine token lists from all makers and flatten them.\n  const allSupportedTokens = uniqBy(\n    Object.values(stakerTokens).flat(),\n    (i) => i\n  );\n  const activeTokensLocalStorage = getActiveTokensFromLocalStorage(\n    wallet.address!,\n    wallet.chainId!\n  );\n  const activeTokens =\n    (activeTokensLocalStorage.length && activeTokensLocalStorage) ||\n    allSupportedTokens ||\n    [];\n  return { stakerTokens, allSupportedTokens, activeTokens };\n});\n\nexport const registrySlice = createSlice({\n  name: \"registry\",\n  initialState,\n  reducers: {\n    setStakerTokens: (\n      state,\n      action: PayloadAction<Record<string, string[]>>\n    ) => {\n      state.stakerTokens = { ...action.payload };\n    },\n    setAllSupportedTokens: (state, action: PayloadAction<string[]>) => {\n      state.allSupportedTokens = [...action.payload];\n    },\n    reset: () => {\n      return { ...initialState };\n    },\n  },\n  extraReducers: (builder) => {\n    builder\n      .addCase(fetchSupportedTokens.pending, (state) => {\n        state.status = \"fetching\";\n      })\n      .addCase(fetchSupportedTokens.fulfilled, (state, action) => {\n        state.status = \"idle\";\n        state.allSupportedTokens = [...action.payload.allSupportedTokens];\n        state.stakerTokens = { ...action.payload.stakerTokens };\n      })\n      .addCase(fetchSupportedTokens.rejected, (state) => {\n        state.status = \"failed\";\n      })\n      // Reset on wallet connect or disconnect\n      .addCase(setWalletConnected, () => initialState)\n      .addCase(setWalletDisconnected, () => initialState);\n  },\n});\n\nexport const {\n  setStakerTokens,\n  setAllSupportedTokens,\n  reset,\n} = registrySlice.actions;\nexport const selectAllSupportedTokens = (state: RootState) =>\n  state.registry.allSupportedTokens;\nexport default registrySlice.reducer;\n"]},"metadata":{},"sourceType":"module"}