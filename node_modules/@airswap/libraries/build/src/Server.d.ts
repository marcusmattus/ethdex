import { ethers } from 'ethers';
import { JsonRpcError } from '@airswap/jsonrpc-client-websocket';
import { Quote, LightOrder, Pricing } from '@airswap/types';
import { TypedEmitter } from 'tiny-typed-emitter';
export declare type SupportedProtocolInfo = {
    name: string;
    version: string;
    params?: any;
};
export declare type ServerOptions = {
    initializeTimeout?: number;
    swapContract?: string;
};
export interface ServerEvents {
    pricing: (pricing: Pricing[]) => void;
    error: (error: JsonRpcError) => void;
}
export declare class Server extends TypedEmitter<ServerEvents> {
    locator: string;
    private swapContract;
    transportProtocol: 'websocket' | 'http';
    private supportedProtocols;
    private isInitialized;
    private httpClient;
    private webSocketClient;
    private senderServer;
    private senderWallet;
    constructor(locator: string, swapContract?: string);
    static at(locator: string, options?: ServerOptions): Promise<Server>;
    getSupportedProtocolVersion(protocol: string): string | null;
    supportsProtocol(protocol: string, requestedVersion?: string): boolean;
    getMaxQuote(signerToken: string, senderToken: string): Promise<Quote>;
    getSignerSideQuote(senderAmount: string, signerToken: string, senderToken: string): Promise<Quote>;
    getSenderSideQuote(signerAmount: string, signerToken: string, senderToken: string): Promise<Quote>;
    getSignerSideOrder(senderAmount: string, signerToken: string, senderToken: string, senderWallet: string): Promise<LightOrder>;
    getSenderSideOrder(signerAmount: string | ethers.BigNumber, signerToken: string, senderToken: string, senderWallet: string): Promise<LightOrder>;
    subscribe(pairs: {
        baseToken: string;
        quoteToken: string;
    }[]): Promise<Pricing[]>;
    unsubscribe(pairs: {
        baseToken: string;
        quoteToken: string;
    }[]): Promise<boolean>;
    subscribeAll(): Promise<boolean>;
    unsubscribeAll(): Promise<boolean>;
    getSenderWallet(): string;
    consider(order: LightOrder): Promise<boolean>;
    disconnect(): void;
    private _init;
    private _initHTTPClient;
    private _initWebSocketClient;
    private requireInitialized;
    private requireRFQSupport;
    private requireLastLookSupport;
    private requireProtocolSupport;
    private compare;
    private throwInvalidParams;
    private validateInitializeParams;
    private validateUpdatePricingParams;
    private updatePricing;
    private initialize;
    private httpCall;
    private webSocketCall;
    /**
     * This method should instantiate the relevenat transport client and also
     * trigger initialization, setting `isInitialized` when complete.
     */
    private callRPCMethod;
}
