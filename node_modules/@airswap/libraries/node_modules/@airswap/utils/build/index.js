"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
var __exportStar = (this && this.__exportStar) || function(m, exports) {
    for (var p in m) if (p !== "default" && !exports.hasOwnProperty(p)) __createBinding(exports, m, p);
};
var __importDefault = (this && this.__importDefault) || function (mod) {
    return (mod && mod.__esModule) ? mod : { "default": mod };
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.lowerCaseAddresses = exports.flattenObject = exports.getEtherscanURL = exports.parseUrl = exports.getTimestamp = exports.toAtomicString = exports.toDecimalString = exports.getBestByHighestSenderAmount = exports.getBestByHighestSignerAmount = exports.getBestByLowestSignerAmount = exports.getBestByLowestSenderAmount = exports.calculateCostFromLevels = exports.calculateCost = void 0;
/* eslint-disable @typescript-eslint/explicit-module-boundary-types */
var ethers_1 = require("ethers");
var url = __importStar(require("url"));
var bignumber_js_1 = __importDefault(require("bignumber.js"));
var constants_1 = require("@airswap/constants");
__exportStar(require("./src/hashes"), exports);
__exportStar(require("./src/orders"), exports);
__exportStar(require("./src/quotes"), exports);
function calculateCost(amount, pricing) {
    // TODO: Formula support
    if (typeof pricing !== 'string') {
        return calculateCostFromLevels(amount, pricing);
    }
    return null;
}
exports.calculateCost = calculateCost;
function calculateCostFromLevels(amount, levels) {
    var totalAmount = new bignumber_js_1.default(amount);
    var totalAvailable = new bignumber_js_1.default(levels[levels.length - 1][0]);
    var totalCost = new bignumber_js_1.default(0);
    var previousLevel = new bignumber_js_1.default(0);
    if (totalAmount.gt(totalAvailable)) {
        throw new Error("Requested amount (" + totalAmount.toFixed() + ") exceeds maximum available (" + totalAvailable.toFixed() + ").");
    }
    // Steps through levels and multiplies each incremental amount by the level price
    // Levels takes the form of [[ level, price ], ... ] as in [[ '100', '0.5' ], ... ]
    for (var i = 0; i < levels.length; i++) {
        var incrementalAmount = void 0;
        if (totalAmount.gt(new bignumber_js_1.default(levels[i][0]))) {
            incrementalAmount = new bignumber_js_1.default(levels[i][0]).minus(previousLevel);
        }
        else {
            incrementalAmount = new bignumber_js_1.default(totalAmount).minus(previousLevel);
        }
        totalCost = totalCost.plus(new bignumber_js_1.default(incrementalAmount).multipliedBy(levels[i][1]));
        previousLevel = new bignumber_js_1.default(levels[i][0]);
        if (totalAmount.lt(previousLevel))
            break;
    }
    return totalCost.decimalPlaces(6).toFixed();
}
exports.calculateCostFromLevels = calculateCostFromLevels;
function getLowest(objects, key) {
    var best;
    var bestAmount;
    var amount;
    for (var _i = 0, objects_1 = objects; _i < objects_1.length; _i++) {
        var obj = objects_1[_i];
        if (!obj[key])
            continue;
        if (obj[key].amount != undefined) {
            // if its a quote, it has .amount
            amount = ethers_1.ethers.BigNumber.from(obj[key].amount);
        }
        else {
            // if its an order, it has .data
            amount = ethers_1.ethers.BigNumber.from(obj[key].data.slice(0, 66));
        }
        if (!best || amount.lt(bestAmount)) {
            bestAmount = amount;
            best = obj;
        }
    }
    return best;
}
function getHighest(objects, key) {
    var best;
    var bestAmount;
    var amount;
    for (var _i = 0, objects_2 = objects; _i < objects_2.length; _i++) {
        var obj = objects_2[_i];
        if (!obj[key])
            continue;
        if (obj[key].amount != undefined) {
            // if its a quote, it has .amount
            amount = ethers_1.ethers.BigNumber.from(obj[key].amount);
        }
        else {
            // if its an order, it has .data
            amount = ethers_1.ethers.BigNumber.from(obj[key].data.slice(0, 66));
        }
        if (!best || amount.gt(bestAmount)) {
            bestAmount = amount;
            best = obj;
        }
    }
    return best;
}
function getBestByLowestSenderAmount(objects) {
    return getLowest(objects, 'sender');
}
exports.getBestByLowestSenderAmount = getBestByLowestSenderAmount;
function getBestByLowestSignerAmount(objects) {
    return getLowest(objects, 'signer');
}
exports.getBestByLowestSignerAmount = getBestByLowestSignerAmount;
function getBestByHighestSignerAmount(objects) {
    return getHighest(objects, 'signer');
}
exports.getBestByHighestSignerAmount = getBestByHighestSignerAmount;
function getBestByHighestSenderAmount(objects) {
    return getHighest(objects, 'sender');
}
exports.getBestByHighestSenderAmount = getBestByHighestSenderAmount;
function toDecimalString(value, decimals) {
    return ethers_1.ethers.utils.formatUnits(value.toString(), decimals).toString();
}
exports.toDecimalString = toDecimalString;
function toAtomicString(value, decimals) {
    return ethers_1.ethers.utils.parseUnits(value.toString(), decimals).toString();
}
exports.toAtomicString = toAtomicString;
function getTimestamp() {
    return Math.round(Date.now() / 1000).toString();
}
exports.getTimestamp = getTimestamp;
function parseUrl(locator) {
    if (!/(http|ws)s?:\/\//.test(locator)) {
        locator = "https://" + locator;
    }
    return url.parse(locator);
}
exports.parseUrl = parseUrl;
function getEtherscanURL(chainId, hash) {
    return "https://" + constants_1.etherscanDomains[chainId] + "/tx/" + hash;
}
exports.getEtherscanURL = getEtherscanURL;
function flattenObject(obj, propName, result) {
    if (propName === void 0) { propName = ''; }
    if (result === void 0) { result = {}; }
    if (Object(obj) !== obj) {
        result[propName] = obj;
    }
    else {
        for (var prop in obj) {
            flattenObject(obj[prop], propName
                ? propName + prop.charAt(0).toUpperCase() + prop.slice(1)
                : prop, result);
        }
    }
    return result;
}
exports.flattenObject = flattenObject;
function lowerCaseAddresses(obj) {
    for (var key in obj) {
        if (typeof obj[key] === 'object') {
            lowerCaseAddresses(obj[key]);
        }
        else if (typeof obj[key] === 'string' && obj[key].indexOf('0x') === 0) {
            obj[key] = obj[key].toLowerCase();
        }
        else {
            obj[key] = obj[key].toString();
        }
    }
    return obj;
}
exports.lowerCaseAddresses = lowerCaseAddresses;
//# sourceMappingURL=index.js.map